module.exports = {

"[project]/node_modules/mathjs/lib/esm/utils/customs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getSafeMethod": (()=>getSafeMethod),
    "getSafeProperty": (()=>getSafeProperty),
    "isPlainObject": (()=>isPlainObject),
    "isSafeMethod": (()=>isSafeMethod),
    "isSafeProperty": (()=>isSafeProperty),
    "setSafeProperty": (()=>setSafeProperty)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
/**
 * Get a property of a plain object
 * Throws an error in case the object is not a plain object or the
 * property is not defined on the object itself
 * @param {Object} object
 * @param {string} prop
 * @return {*} Returns the property value when safe
 */ function getSafeProperty(object, prop) {
    // only allow getting safe properties of a plain object
    if (isSafeProperty(object, prop)) {
        return object[prop];
    }
    if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
        throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
}
/**
 * Set a property on a plain object.
 * Throws an error in case the object is not a plain object or the
 * property would override an inherited property like .constructor or .toString
 * @param {Object} object
 * @param {string} prop
 * @param {*} value
 * @return {*} Returns the value
 */ // TODO: merge this function into access.js?
function setSafeProperty(object, prop, value) {
    // only allow setting safe properties of a plain object
    if (isSafeProperty(object, prop)) {
        object[prop] = value;
        return value;
    }
    throw new Error('No access to property "' + prop + '"');
}
/**
 * Test whether a property is safe to use on an object or Array.
 * For example .toString and .constructor are not safe
 * @param {Object | Array} object
 * @param {string} prop
 * @return {boolean} Returns true when safe
 */ function isSafeProperty(object, prop) {
    if (!isPlainObject(object) && !Array.isArray(object)) {
        return false;
    }
    // SAFE: whitelisted
    // e.g length
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasOwnProperty"])(safeNativeProperties, prop)) {
        return true;
    }
    // UNSAFE: inherited from Object prototype
    // e.g constructor
    if (prop in Object.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Object.prototype is a root object
        return false;
    }
    // UNSAFE: inherited from Function prototype
    // e.g call, apply
    if (prop in Function.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Function.prototype is a root object
        return false;
    }
    return true;
}
/**
 * Validate whether a method is safe.
 * Throws an error when that's not the case.
 * @param {Object} object
 * @param {string} method
 * @return {function} Returns the method when valid
 */ function getSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
        throw new Error('No access to method "' + method + '"');
    }
    return object[method];
}
/**
 * Check whether a method is safe.
 * Throws an error when that's not the case (for example for `constructor`).
 * @param {Object} object
 * @param {string} method
 * @return {boolean} Returns true when safe, false otherwise
 */ function isSafeMethod(object, method) {
    if (object === null || object === undefined || typeof object[method] !== 'function') {
        return false;
    }
    // UNSAFE: ghosted
    // e.g overridden toString
    // Note that IE10 doesn't support __proto__ and we can't do this check there.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasOwnProperty"])(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
        return false;
    }
    // SAFE: whitelisted
    // e.g toString
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasOwnProperty"])(safeNativeMethods, method)) {
        return true;
    }
    // UNSAFE: inherited from Object prototype
    // e.g constructor
    if (method in Object.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Object.prototype is a root object
        return false;
    }
    // UNSAFE: inherited from Function prototype
    // e.g call, apply
    if (method in Function.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Function.prototype is a root object
        return false;
    }
    return true;
}
function isPlainObject(object) {
    return typeof object === 'object' && object && object.constructor === Object;
}
var safeNativeProperties = {
    length: true,
    name: true
};
var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
};
;
;
;
;
;
;
}}),
"[project]/node_modules/mathjs/lib/esm/utils/map.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ObjectWrappingMap": (()=>ObjectWrappingMap),
    "PartitionedMap": (()=>PartitionedMap),
    "assign": (()=>assign),
    "createEmptyMap": (()=>createEmptyMap),
    "createMap": (()=>createMap),
    "toObject": (()=>toObject)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/customs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
class ObjectWrappingMap {
    constructor(object){
        this.wrappedObject = object;
        this[Symbol.iterator] = this.entries;
    }
    keys() {
        return Object.keys(this.wrappedObject).filter((key)=>this.has(key)).values();
    }
    get(key) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSafeProperty"])(this.wrappedObject, key);
    }
    set(key, value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setSafeProperty"])(this.wrappedObject, key, value);
        return this;
    }
    has(key) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSafeProperty"])(this.wrappedObject, key) && key in this.wrappedObject;
    }
    entries() {
        return mapIterator(this.keys(), (key)=>[
                key,
                this.get(key)
            ]);
    }
    forEach(callback) {
        for (var key of this.keys()){
            callback(this.get(key), key, this);
        }
    }
    delete(key) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSafeProperty"])(this.wrappedObject, key)) {
            delete this.wrappedObject[key];
        }
    }
    clear() {
        for (var key of this.keys()){
            this.delete(key);
        }
    }
    get size() {
        return Object.keys(this.wrappedObject).length;
    }
}
class PartitionedMap {
    /**
   * @param {Map} a
   * @param {Map} b
   * @param {Set} bKeys
   */ constructor(a, b, bKeys){
        this.a = a;
        this.b = b;
        this.bKeys = bKeys;
        this[Symbol.iterator] = this.entries;
    }
    get(key) {
        return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
    }
    set(key, value) {
        if (this.bKeys.has(key)) {
            this.b.set(key, value);
        } else {
            this.a.set(key, value);
        }
        return this;
    }
    has(key) {
        return this.b.has(key) || this.a.has(key);
    }
    keys() {
        return new Set([
            ...this.a.keys(),
            ...this.b.keys()
        ])[Symbol.iterator]();
    }
    entries() {
        return mapIterator(this.keys(), (key)=>[
                key,
                this.get(key)
            ]);
    }
    forEach(callback) {
        for (var key of this.keys()){
            callback(this.get(key), key, this);
        }
    }
    delete(key) {
        return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);
    }
    clear() {
        this.a.clear();
        this.b.clear();
    }
    get size() {
        return [
            ...this.keys()
        ].length;
    }
}
/**
 * Create a new iterator that maps over the provided iterator, applying a mapping function to each item
 */ function mapIterator(it, callback) {
    return {
        next: ()=>{
            var n = it.next();
            return n.done ? n : {
                value: callback(n.value),
                done: false
            };
        }
    };
}
function createEmptyMap() {
    return new Map();
}
function createMap(mapOrObject) {
    if (!mapOrObject) {
        return createEmptyMap();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMap"])(mapOrObject)) {
        return mapOrObject;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(mapOrObject)) {
        return new ObjectWrappingMap(mapOrObject);
    }
    throw new Error('createMap can create maps from objects or Maps');
}
function toObject(map) {
    if (map instanceof ObjectWrappingMap) {
        return map.wrappedObject;
    }
    var object = {};
    for (var key of map.keys()){
        var value = map.get(key);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setSafeProperty"])(object, key, value);
    }
    return object;
}
function assign(map) {
    for(var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        objects[_key - 1] = arguments[_key];
    }
    for (var args of objects){
        if (!args) {
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMap"])(args)) {
            for (var key of args.keys()){
                map.set(key, args.get(key));
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(args)) {
            for (var _key2 of Object.keys(args)){
                map.set(_key2, args[_key2]);
            }
        }
    }
    return map;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// type checks for all known types
//
// note that:
//
// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
//   instanceof cannot be used because that would not allow to pass data from
//   one instance of math.js to another since each has it's own instance of Unit.
// - check the `isUnit` property via the constructor, so there will be no
//   matches for "fake" instances like plain objects with a property `isUnit`.
//   That is important for security reasons.
// - It must not be possible to override the type checks used internally,
//   for security reasons, so these functions are not exposed in the expression
//   parser.
__turbopack_context__.s({
    "isAccessorNode": (()=>isAccessorNode),
    "isArray": (()=>isArray),
    "isArrayNode": (()=>isArrayNode),
    "isAssignmentNode": (()=>isAssignmentNode),
    "isBigInt": (()=>isBigInt),
    "isBigNumber": (()=>isBigNumber),
    "isBlockNode": (()=>isBlockNode),
    "isBoolean": (()=>isBoolean),
    "isChain": (()=>isChain),
    "isCollection": (()=>isCollection),
    "isComplex": (()=>isComplex),
    "isConditionalNode": (()=>isConditionalNode),
    "isConstantNode": (()=>isConstantNode),
    "isDate": (()=>isDate),
    "isDenseMatrix": (()=>isDenseMatrix),
    "isFraction": (()=>isFraction),
    "isFunction": (()=>isFunction),
    "isFunctionAssignmentNode": (()=>isFunctionAssignmentNode),
    "isFunctionNode": (()=>isFunctionNode),
    "isHelp": (()=>isHelp),
    "isIndex": (()=>isIndex),
    "isIndexNode": (()=>isIndexNode),
    "isMap": (()=>isMap),
    "isMatrix": (()=>isMatrix),
    "isNode": (()=>isNode),
    "isNull": (()=>isNull),
    "isNumber": (()=>isNumber),
    "isObject": (()=>isObject),
    "isObjectNode": (()=>isObjectNode),
    "isObjectWrappingMap": (()=>isObjectWrappingMap),
    "isOperatorNode": (()=>isOperatorNode),
    "isParenthesisNode": (()=>isParenthesisNode),
    "isPartitionedMap": (()=>isPartitionedMap),
    "isRange": (()=>isRange),
    "isRangeNode": (()=>isRangeNode),
    "isRegExp": (()=>isRegExp),
    "isRelationalNode": (()=>isRelationalNode),
    "isResultSet": (()=>isResultSet),
    "isSparseMatrix": (()=>isSparseMatrix),
    "isString": (()=>isString),
    "isSymbolNode": (()=>isSymbolNode),
    "isUndefined": (()=>isUndefined),
    "isUnit": (()=>isUnit),
    "rule2Node": (()=>rule2Node),
    "typeOf": (()=>typeOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/map.js [app-ssr] (ecmascript)");
;
function isNumber(x) {
    return typeof x === 'number';
}
function isBigNumber(x) {
    if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {
        return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {
        return true;
    }
    if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {
        return true;
    }
    return false;
}
function isBigInt(x) {
    return typeof x === 'bigint';
}
function isComplex(x) {
    return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
    return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
    return typeof x === 'string';
}
var isArray = Array.isArray;
function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
    return typeof x === 'boolean';
}
function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
    return typeof x === 'function';
}
function isDate(x) {
    return x instanceof Date;
}
function isRegExp(x) {
    return x instanceof RegExp;
}
function isObject(x) {
    return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isMap(object) {
    // We can use the fast instanceof, or a slower duck typing check.
    // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
    if (!object) {
        return false;
    }
    return object instanceof Map || object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObjectWrappingMap"] || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';
}
function isPartitionedMap(object) {
    return isMap(object) && isMap(object.a) && isMap(object.b);
}
function isObjectWrappingMap(object) {
    return isMap(object) && isObject(object.wrappedObject);
}
function isNull(x) {
    return x === null;
}
function isUndefined(x) {
    return x === undefined;
}
function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
    return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && '-+~'.includes(node.op);
}
function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x) {
    return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
    var t = typeof x;
    if (t === 'object') {
        if (x === null) return 'null';
        if (isBigNumber(x)) return 'BigNumber'; // Special: weird mashup with Decimal
        if (x.constructor && x.constructor.name) return x.constructor.name;
        return 'Object'; // just in case
    }
    return t; // can be 'string', 'number', 'boolean', 'function', 'bigint', ...
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "canDefineProperty": (()=>canDefineProperty),
    "clone": (()=>clone),
    "deepExtend": (()=>deepExtend),
    "deepFlatten": (()=>deepFlatten),
    "deepStrictEqual": (()=>deepStrictEqual),
    "extend": (()=>extend),
    "get": (()=>get),
    "hasOwnProperty": (()=>hasOwnProperty),
    "isLegacyFactory": (()=>isLegacyFactory),
    "lazy": (()=>lazy),
    "mapObject": (()=>mapObject),
    "pick": (()=>pick),
    "pickShallow": (()=>pickShallow),
    "set": (()=>set),
    "traverse": (()=>traverse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
function clone(x) {
    var type = typeof x;
    // immutable primitive types
    if (type === 'number' || type === 'bigint' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
        return x;
    }
    // use clone function of the object when available
    if (typeof x.clone === 'function') {
        return x.clone();
    }
    // array
    if (Array.isArray(x)) {
        return x.map(function(value) {
            return clone(value);
        });
    }
    if (x instanceof Date) return new Date(x.valueOf());
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(x)) return x; // bignumbers are immutable
    // object
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(x)) {
        return mapObject(x, clone);
    }
    if (type === 'function') {
        // we assume that the function is immutable
        return x;
    }
    throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
}
function mapObject(object, callback) {
    var clone = {};
    for(var key in object){
        if (hasOwnProperty(object, key)) {
            clone[key] = callback(object[key]);
        }
    }
    return clone;
}
function extend(a, b) {
    for(var prop in b){
        if (hasOwnProperty(b, prop)) {
            a[prop] = b[prop];
        }
    }
    return a;
}
function deepExtend(a, b) {
    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
        throw new TypeError('Arrays are not supported by deepExtend');
    }
    for(var prop in b){
        // We check against prop not being in Object.prototype or Function.prototype
        // to prevent polluting for example Object.__proto__.
        if (hasOwnProperty(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
            if (b[prop] && b[prop].constructor === Object) {
                if (a[prop] === undefined) {
                    a[prop] = {};
                }
                if (a[prop] && a[prop].constructor === Object) {
                    deepExtend(a[prop], b[prop]);
                } else {
                    a[prop] = b[prop];
                }
            } else if (Array.isArray(b[prop])) {
                throw new TypeError('Arrays are not supported by deepExtend');
            } else {
                a[prop] = b[prop];
            }
        }
    }
    return a;
}
function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
            return false;
        }
        if (a.length !== b.length) {
            return false;
        }
        for(i = 0, len = a.length; i < len; i++){
            if (!deepStrictEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else if (typeof a === 'function') {
        return a === b;
    } else if (a instanceof Object) {
        if (Array.isArray(b) || !(b instanceof Object)) {
            return false;
        }
        for(prop in a){
            // noinspection JSUnfilteredForInLoop
            if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
                return false;
            }
        }
        for(prop in b){
            // noinspection JSUnfilteredForInLoop
            if (!(prop in a)) {
                return false;
            }
        }
        return true;
    } else {
        return a === b;
    }
}
function deepFlatten(nestedObject) {
    var flattenedObject = {};
    _deepFlatten(nestedObject, flattenedObject);
    return flattenedObject;
}
// helper function used by deepFlatten
function _deepFlatten(nestedObject, flattenedObject) {
    for(var prop in nestedObject){
        if (hasOwnProperty(nestedObject, prop)) {
            var value = nestedObject[prop];
            if (typeof value === 'object' && value !== null) {
                _deepFlatten(value, flattenedObject);
            } else {
                flattenedObject[prop] = value;
            }
        }
    }
}
function canDefineProperty() {
    // test needed for broken IE8 implementation
    try {
        if (Object.defineProperty) {
            Object.defineProperty({}, 'x', {
                get: function get() {
                    return null;
                }
            });
            return true;
        }
    } catch (e) {}
    return false;
}
function lazy(object, prop, valueResolver) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
        get: function get() {
            if (_uninitialized) {
                _value = valueResolver();
                _uninitialized = false;
            }
            return _value;
        },
        set: function set(value) {
            _value = value;
            _uninitialized = false;
        },
        configurable: true,
        enumerable: true
    });
}
function traverse(object, path) {
    if (path && typeof path === 'string') {
        return traverse(object, path.split('.'));
    }
    var obj = object;
    if (path) {
        for(var i = 0; i < path.length; i++){
            var key = path[i];
            if (!(key in obj)) {
                obj[key] = {};
            }
            obj = obj[key];
        }
    }
    return obj;
}
function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
}
function isLegacyFactory(object) {
    return object && typeof object.factory === 'function';
}
function get(object, path) {
    if (typeof path === 'string') {
        if (isPath(path)) {
            return get(object, path.split('.'));
        } else {
            return object[path];
        }
    }
    var child = object;
    for(var i = 0; i < path.length; i++){
        var key = path[i];
        child = child ? child[key] : undefined;
    }
    return child;
}
function set(object, path, value) {
    if (typeof path === 'string') {
        if (isPath(path)) {
            return set(object, path.split('.'), value);
        } else {
            object[path] = value;
            return object;
        }
    }
    var child = object;
    for(var i = 0; i < path.length - 1; i++){
        var key = path[i];
        if (child[key] === undefined) {
            child[key] = {};
        }
        child = child[key];
    }
    if (path.length > 0) {
        var lastKey = path[path.length - 1];
        child[lastKey] = value;
    }
    return object;
}
function pick(object, properties, transform) {
    var copy = {};
    for(var i = 0; i < properties.length; i++){
        var key = properties[i];
        var value = get(object, key);
        if (value !== undefined) {
            set(copy, key, transform ? transform(value, key) : value);
        }
    }
    return copy;
}
function pickShallow(object, properties) {
    var copy = {};
    for(var i = 0; i < properties.length; i++){
        var key = properties[i];
        var value = object[key];
        if (value !== undefined) {
            copy[key] = value;
        }
    }
    return copy;
}
// helper function to test whether a string contains a path like 'user.name'
function isPath(str) {
    return str.includes('.');
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "assertDependencies": (()=>assertDependencies),
    "create": (()=>create),
    "factory": (()=>factory),
    "isFactory": (()=>isFactory),
    "isOptionalDependency": (()=>isOptionalDependency),
    "sortFactories": (()=>sortFactories),
    "stripOptionalNotation": (()=>stripOptionalNotation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
function factory(name, dependencies, create, meta) {
    function assertAndCreate(scope) {
        // we only pass the requested dependencies to the factory function
        // to prevent functions to rely on dependencies that are not explicitly
        // requested.
        var deps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pickShallow"])(scope, dependencies.map(stripOptionalNotation));
        assertDependencies(name, dependencies, scope);
        return create(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name;
    assertAndCreate.dependencies = dependencies.slice().sort();
    if (meta) {
        assertAndCreate.meta = meta;
    }
    return assertAndCreate;
}
function sortFactories(factories) {
    var factoriesByName = {};
    factories.forEach((factory)=>{
        factoriesByName[factory.fn] = factory;
    });
    function containsDependency(factory, dependency) {
        // TODO: detect circular references
        if (isFactory(factory)) {
            if (factory.dependencies.includes(dependency.fn || dependency.name)) {
                return true;
            }
            if (factory.dependencies.some((d)=>containsDependency(factoriesByName[d], dependency))) {
                return true;
            }
        }
        return false;
    }
    var sorted = [];
    function addFactory(factory) {
        var index = 0;
        while(index < sorted.length && !containsDependency(sorted[index], factory)){
            index++;
        }
        sorted.splice(index, 0, factory);
    }
    // sort regular factory functions
    factories.filter(isFactory).forEach(addFactory);
    // sort legacy factory functions AFTER the regular factory functions
    factories.filter((factory)=>!isFactory(factory)).forEach(addFactory);
    return sorted;
}
function create(factories) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    sortFactories(factories).forEach((factory)=>factory(scope));
    return scope;
}
function isFactory(obj) {
    return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);
}
function assertDependencies(name, dependencies, scope) {
    var allDefined = dependencies.filter((dependency)=>!isOptionalDependency(dependency)) // filter optionals
    .every((dependency)=>scope[dependency] !== undefined);
    if (!allDefined) {
        var missingDependencies = dependencies.filter((dependency)=>scope[dependency] === undefined);
        // TODO: create a custom error class for this, a MathjsError or something like that
        throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map((d)=>"\"".concat(d, "\"")).join(', '), "."));
    }
}
function isOptionalDependency(dependency) {
    return dependency && dependency[0] === '?';
}
function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "acosh": (()=>acosh),
    "asinh": (()=>asinh),
    "atanh": (()=>atanh),
    "cbrt": (()=>cbrt),
    "copysign": (()=>copysign),
    "cosh": (()=>cosh),
    "digits": (()=>digits),
    "expm1": (()=>expm1),
    "format": (()=>format),
    "isInteger": (()=>isInteger),
    "log10": (()=>log10),
    "log1p": (()=>log1p),
    "log2": (()=>log2),
    "nearlyEqual": (()=>nearlyEqual),
    "normalizeFormatOptions": (()=>normalizeFormatOptions),
    "roundDigits": (()=>roundDigits),
    "safeNumberType": (()=>safeNumberType),
    "sign": (()=>sign),
    "sinh": (()=>sinh),
    "splitNumber": (()=>splitNumber),
    "tanh": (()=>tanh),
    "toEngineering": (()=>toEngineering),
    "toExponential": (()=>toExponential),
    "toFixed": (()=>toFixed),
    "toPrecision": (()=>toPrecision)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
function isInteger(value) {
    if (typeof value === 'boolean') {
        return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
}
function safeNumberType(numberStr, config) {
    if (config.number === 'bigint') {
        try {
            BigInt(numberStr);
        } catch (_unused) {
            return config.numberFallback;
        }
    }
    return config.number;
}
var sign = Math.sign || function(x) {
    if (x > 0) {
        return 1;
    } else if (x < 0) {
        return -1;
    } else {
        return 0;
    }
};
var log2 = Math.log2 || function log2(x) {
    return Math.log(x) / Math.LN2;
};
var log10 = Math.log10 || function log10(x) {
    return Math.log(x) / Math.LN10;
};
var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
};
var cbrt = Math.cbrt || function cbrt(x) {
    if (x === 0) {
        return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
        x = -x;
    }
    if (isFinite(x)) {
        result = Math.exp(Math.log(x) / 3);
        // from https://en.wikipedia.org/wiki/Cube_root#Numerical_methods
        result = (x / (result * result) + 2 * result) / 3;
    } else {
        result = x;
    }
    return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm1(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
/**
 * Formats a number in a given base
 * @param {number} n
 * @param {number} base
 * @param {number} size
 * @returns {string}
 */ function formatNumberToBase(n, base, size) {
    var prefixes = {
        2: '0b',
        8: '0o',
        16: '0x'
    };
    var prefix = prefixes[base];
    var suffix = '';
    if (size) {
        if (size < 1) {
            throw new Error('size must be in greater than 0');
        }
        if (!isInteger(size)) {
            throw new Error('size must be an integer');
        }
        if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
            throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
        }
        if (!isInteger(n)) {
            throw new Error('Value must be an integer');
        }
        if (n < 0) {
            n = n + 2 ** size;
        }
        suffix = "i".concat(size);
    }
    var sign = '';
    if (n < 0) {
        n = -n;
        sign = '-';
    }
    return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format(value, options) {
    if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value);
    }
    // handle special cases
    if (value === Infinity) {
        return 'Infinity';
    } else if (value === -Infinity) {
        return '-Infinity';
    } else if (isNaN(value)) {
        return 'NaN';
    }
    var { notation, precision, wordSize } = normalizeFormatOptions(options);
    // handle the various notations
    switch(notation){
        case 'fixed':
            return toFixed(value, precision);
        case 'exponential':
            return toExponential(value, precision);
        case 'engineering':
            return toEngineering(value, precision);
        case 'bin':
            return formatNumberToBase(value, 2, wordSize);
        case 'oct':
            return formatNumberToBase(value, 8, wordSize);
        case 'hex':
            return formatNumberToBase(value, 16, wordSize);
        case 'auto':
            // remove trailing zeros after the decimal point
            return toPrecision(value, precision, options).replace(/((\.\d*?)(0+))($|e)/, function() {
                var digits = arguments[2];
                var e = arguments[4];
                return digits !== '.' ? digits + e : e;
            });
        default:
            throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
}
function normalizeFormatOptions(options) {
    // default values for options
    var notation = 'auto';
    var precision;
    var wordSize;
    if (options !== undefined) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(options)) {
            precision = options;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(options)) {
            precision = options.toNumber();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) {
            if (options.precision !== undefined) {
                precision = _toNumberOrThrow(options.precision, ()=>{
                    throw new Error('Option "precision" must be a number or BigNumber');
                });
            }
            if (options.wordSize !== undefined) {
                wordSize = _toNumberOrThrow(options.wordSize, ()=>{
                    throw new Error('Option "wordSize" must be a number or BigNumber');
                });
            }
            if (options.notation) {
                notation = options.notation;
            }
        } else {
            throw new Error('Unsupported type of options, number, BigNumber, or object expected');
        }
    }
    return {
        notation,
        precision,
        wordSize
    };
}
function splitNumber(value) {
    // parse the input value
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
        throw new SyntaxError('Invalid number ' + value);
    }
    var sign = match[1];
    var digits = match[2];
    var exponent = parseFloat(match[4] || '0');
    var dot = digits.indexOf('.');
    exponent += dot !== -1 ? dot - 1 : digits.length - 1;
    var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
    .replace(/^0*/, function(zeros) {
        // remove leading zeros, add their count to the exponent
        exponent -= zeros.length;
        return '';
    }).replace(/0*$/, '') // remove trailing zeros
    .split('').map(function(d) {
        return parseInt(d);
    });
    if (coefficients.length === 0) {
        coefficients.push(0);
        exponent++;
    }
    return {
        sign,
        coefficients,
        exponent
    };
}
function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
        return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e = rounded.exponent;
    var c = rounded.coefficients;
    // find nearest lower multiple of 3 for exponent
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(precision)) {
        // add zeroes to give correct sig figs
        while(precision > c.length || e - newExp + 1 > c.length){
            c.push(0);
        }
    } else {
        // concatenate coefficients with necessary zeros
        // add zeros if necessary (for example: 1e+8 -> 100e+6)
        var missingZeros = Math.abs(e - newExp) - (c.length - 1);
        for(var i = 0; i < missingZeros; i++){
            c.push(0);
        }
    }
    // find difference in exponents
    var expDiff = Math.abs(e - newExp);
    var decimalIdx = 1;
    // push decimal index over by expDiff times
    while(expDiff > 0){
        decimalIdx++;
        expDiff--;
    }
    // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
    // otherwise concat with the rest of the coefficients
    var decimals = c.slice(decimalIdx).join('');
    var decimalVal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
    var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
    return rounded.sign + str;
}
function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
        return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1; // exponent may have changed
    // append zeros if needed
    var pp = p + (precision || 0);
    if (c.length < pp) {
        c = c.concat(zeros(pp - c.length));
    }
    // prepend zeros if needed
    if (p < 0) {
        c = zeros(-p + 1).concat(c);
        p = 1;
    }
    // insert a dot if needed
    if (p < c.length) {
        c.splice(p, 0, p === 0 ? '0.' : '.');
    }
    return rounded.sign + c.join('');
}
function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
        return String(value);
    }
    // round if needed, else create a clone
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e = rounded.exponent;
    // append zeros if needed
    if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
    }
    // format as `C.CCCe+EEE` or `C.CCCe-EEE`
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
}
function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
        return String(value);
    }
    // determine lower and upper bound for exponential notation.
    var lowerExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
    var upperExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.upperExp, 5);
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
        // exponential notation
        return toExponential(value, precision);
    } else {
        var c = rounded.coefficients;
        var e = rounded.exponent;
        // append trailing zeros
        if (c.length < precision) {
            c = c.concat(zeros(precision - c.length));
        }
        // append trailing zeros
        // TODO: simplify the next statement
        c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
        // prepend zeros
        c = zeros(-e).concat(c);
        var dot = e > 0 ? e : 0;
        if (dot < c.length - 1) {
            c.splice(dot + 1, 0, '.');
        }
        return rounded.sign + c.join('');
    }
}
function roundDigits(split, precision) {
    // create a clone
    var rounded = {
        sign: split.sign,
        coefficients: split.coefficients,
        exponent: split.exponent
    };
    var c = rounded.coefficients;
    // prepend zeros if needed
    while(precision <= 0){
        c.unshift(0);
        rounded.exponent++;
        precision++;
    }
    if (c.length > precision) {
        var removed = c.splice(precision, c.length - precision);
        if (removed[0] >= 5) {
            var i = precision - 1;
            c[i]++;
            while(c[i] === 10){
                c.pop();
                if (i === 0) {
                    c.unshift(0);
                    rounded.exponent++;
                    i++;
                }
                i--;
                c[i]++;
            }
        }
    }
    return rounded;
}
/**
 * Create an array filled with zeros.
 * @param {number} length
 * @return {Array}
 */ function zeros(length) {
    var arr = [];
    for(var i = 0; i < length; i++){
        arr.push(0);
    }
    return arr;
}
function digits(value) {
    return value.toExponential().replace(/e.*$/, '') // remove exponential notation
    .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
    .length;
}
function nearlyEqual(a, b) {
    var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-8;
    var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (relTol <= 0) {
        throw new Error('Relative tolerance must be greater than 0');
    }
    if (absTol < 0) {
        throw new Error('Absolute tolerance must be at least 0');
    }
    // NaN
    if (isNaN(a) || isNaN(b)) {
        return false;
    }
    if (!isFinite(a) || !isFinite(b)) {
        return a === b;
    }
    if (a === b) {
        return true;
    }
    // abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
    return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), absTol);
}
var acosh = Math.acosh || function(x) {
    return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh = Math.asinh || function(x) {
    return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh = Math.atanh || function(x) {
    return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh = Math.tanh || function(x) {
    var e = Math.exp(2 * x);
    return (e - 1) / (e + 1);
};
function copysign(x, y) {
    var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
    var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
    return signx ^ signy ? -x : x;
}
function _toNumberOrThrow(value, onError) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(value)) {
        return value;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
        return value.toNumber();
    } else {
        onError();
    }
}
function _toNumberOrDefault(value, defaultValue) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(value)) {
        return value;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
        return value.toNumber();
    } else {
        return defaultValue;
    }
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/lruQueue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// (c) 2018, Mariusz Nowak
// SPDX-License-Identifier: ISC
// Derived from https://github.com/medikoo/lru-queue
__turbopack_context__.s({
    "lruQueue": (()=>lruQueue)
});
function lruQueue(limit) {
    var size = 0;
    var base = 1;
    var queue = Object.create(null);
    var map = Object.create(null);
    var index = 0;
    var del = function del(id) {
        var oldIndex = map[id];
        if (!oldIndex) return;
        delete queue[oldIndex];
        delete map[id];
        --size;
        if (base !== oldIndex) return;
        if (!size) {
            index = 0;
            base = 1;
            return;
        }
        while(!Object.prototype.hasOwnProperty.call(queue, ++base)){}
    };
    limit = Math.abs(limit);
    return {
        hit: function hit(id) {
            var oldIndex = map[id];
            var nuIndex = ++index;
            queue[nuIndex] = id;
            map[id] = nuIndex;
            if (!oldIndex) {
                ++size;
                if (size <= limit) return undefined;
                id = queue[base];
                del(id);
                return id;
            }
            delete queue[oldIndex];
            if (base !== oldIndex) return undefined;
            while(!Object.prototype.hasOwnProperty.call(queue, ++base)){}
            return undefined;
        },
        delete: del,
        clear: function clear() {
            size = index = 0;
            base = 1;
            queue = Object.create(null);
            map = Object.create(null);
        }
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/function.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// function utils
__turbopack_context__.s({
    "memoize": (()=>memoize),
    "memoizeCompare": (()=>memoizeCompare)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$lruQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/lruQueue.js [app-ssr] (ecmascript)");
;
function memoize(fn) {
    var { hasher, limit } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    limit = limit == null ? Number.POSITIVE_INFINITY : limit;
    hasher = hasher == null ? JSON.stringify : hasher;
    return function memoize() {
        if (typeof memoize.cache !== 'object') {
            memoize.cache = {
                values: new Map(),
                lru: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$lruQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lruQueue"])(limit || Number.POSITIVE_INFINITY)
            };
        }
        var args = [];
        for(var i = 0; i < arguments.length; i++){
            args[i] = arguments[i];
        }
        var hash = hasher(args);
        if (memoize.cache.values.has(hash)) {
            memoize.cache.lru.hit(hash);
            return memoize.cache.values.get(hash);
        }
        var newVal = fn.apply(fn, args);
        memoize.cache.values.set(hash, newVal);
        memoize.cache.values.delete(memoize.cache.lru.hit(hash));
        return newVal;
    };
}
function memoizeCompare(fn, isEqual) {
    var memoize = function memoize() {
        var args = [];
        for(var i = 0; i < arguments.length; i++){
            args[i] = arguments[i];
        }
        for(var c = 0; c < memoize.cache.length; c++){
            var cached = memoize.cache[c];
            if (isEqual(args, cached.args)) {
                // TODO: move this cache entry to the top so recently used entries move up?
                return cached.res;
            }
        }
        var res = fn.apply(fn, args);
        memoize.cache.unshift({
            args,
            res
        });
        return res;
    };
    memoize.cache = [];
    return memoize;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/bignumber/constants.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBigNumberE": (()=>createBigNumberE),
    "createBigNumberPhi": (()=>createBigNumberPhi),
    "createBigNumberPi": (()=>createBigNumberPi),
    "createBigNumberTau": (()=>createBigNumberTau)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/function.js [app-ssr] (ecmascript)");
;
var createBigNumberE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memoize"])(function(BigNumber) {
    return new BigNumber(1).exp();
}, {
    hasher
});
var createBigNumberPhi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memoize"])(function(BigNumber) {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
}, {
    hasher
});
var createBigNumberPi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memoize"])(function(BigNumber) {
    return BigNumber.acos(-1);
}, {
    hasher
});
var createBigNumberTau = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memoize"])(function(BigNumber) {
    return createBigNumberPi(BigNumber).times(2);
}, {
    hasher
});
/**
 * Create a hash for a BigNumber constructor function. The created has is
 * the configured precision
 * @param {Array} args         Supposed to contain a single entry with
 *                             a BigNumber constructor
 * @return {number} precision
 * @private
 */ function hasher(args) {
    return args[0].precision;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/bignumber/formatter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "format": (()=>format),
    "toEngineering": (()=>toEngineering),
    "toExponential": (()=>toExponential),
    "toFixed": (()=>toFixed)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
/**
 * Formats a BigNumber in a given base
 * @param {BigNumber} n
 * @param {number} base
 * @param {number} size
 * @returns {string}
 */ function formatBigNumberToBase(n, base, size) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = '';
    if (size) {
        if (size < 1) {
            throw new Error('size must be in greater than 0');
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(size)) {
            throw new Error('size must be an integer');
        }
        if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
            throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
        }
        if (!n.isInteger()) {
            throw new Error('Value must be an integer');
        }
        if (n.lessThan(0)) {
            n = n.add(big2.pow(size));
        }
        suffix = "i".concat(size);
    }
    switch(base){
        case 2:
            return "".concat(n.toBinary()).concat(suffix);
        case 8:
            return "".concat(n.toOctal()).concat(suffix);
        case 16:
            return "".concat(n.toHexadecimal()).concat(suffix);
        default:
            throw new Error("Base ".concat(base, " not supported "));
    }
}
function format(value, options) {
    if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value);
    }
    // handle special cases
    if (!value.isFinite()) {
        return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
    }
    var { notation, precision, wordSize } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeFormatOptions"])(options);
    // handle the various notations
    switch(notation){
        case 'fixed':
            return toFixed(value, precision);
        case 'exponential':
            return toExponential(value, precision);
        case 'engineering':
            return toEngineering(value, precision);
        case 'bin':
            return formatBigNumberToBase(value, 2, wordSize);
        case 'oct':
            return formatBigNumberToBase(value, 8, wordSize);
        case 'hex':
            return formatBigNumberToBase(value, 16, wordSize);
        case 'auto':
            {
                // determine lower and upper bound for exponential notation.
                // TODO: implement support for upper and lower to be BigNumbers themselves
                var lowerExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
                var upperExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.upperExp, 5);
                // handle special case zero
                if (value.isZero()) return '0';
                // determine whether or not to output exponential notation
                var str;
                var rounded = value.toSignificantDigits(precision);
                var exp = rounded.e;
                if (exp >= lowerExp && exp < upperExp) {
                    // normal number notation
                    str = rounded.toFixed();
                } else {
                    // exponential notation
                    str = toExponential(value, precision);
                }
                // remove trailing zeros after the decimal point
                return str.replace(/((\.\d*?)(0+))($|e)/, function() {
                    var digits = arguments[2];
                    var e = arguments[4];
                    return digits !== '.' ? digits + e : e;
                });
            }
        default:
            throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
}
function toEngineering(value, precision) {
    // find nearest lower multiple of 3 for exponent
    var e = value.e;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    // find difference in exponents, and calculate the value without exponent
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.includes('e')) {
        var BigNumber = value.constructor;
        valueStr = new BigNumber(valueStr).toFixed();
    }
    return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
}
function toExponential(value, precision) {
    if (precision !== undefined) {
        return value.toExponential(precision - 1); // Note the offset of one
    } else {
        return value.toExponential();
    }
}
function toFixed(value, precision) {
    return value.toFixed(precision);
}
function _toNumberOrDefault(value, defaultValue) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(value)) {
        return value;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
        return value.toNumber();
    } else {
        return defaultValue;
    }
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "compareText": (()=>compareText),
    "endsWith": (()=>endsWith),
    "escape": (()=>escape),
    "format": (()=>format),
    "stringify": (()=>stringify)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/formatter.js [app-ssr] (ecmascript)");
;
;
;
function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
}
function format(value, options) {
    var result = _format(value, options);
    if (options && typeof options === 'object' && 'truncate' in options && result.length > options.truncate) {
        return result.substring(0, options.truncate - 3) + '...';
    }
    return result;
}
function _format(value, options) {
    if (typeof value === 'number') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(value, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(value, options);
    }
    // note: we use unsafe duck-typing here to check for Fractions, this is
    // ok here since we're only invoking toString or concatenating its values
    if (looksLikeFraction(value)) {
        if (!options || options.fraction !== 'decimal') {
            // output as ratio, like '1/3'
            return "".concat(value.s * value.n, "/").concat(value.d);
        } else {
            // output as decimal, like '0.(3)'
            return value.toString();
        }
    }
    if (Array.isArray(value)) {
        return formatArray(value, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(value)) {
        return stringify(value);
    }
    if (typeof value === 'function') {
        return value.syntax ? String(value.syntax) : 'function';
    }
    if (value && typeof value === 'object') {
        if (typeof value.format === 'function') {
            return value.format(options);
        } else if (value && value.toString(options) !== ({}).toString()) {
            // this object has a non-native toString method, use that one
            return value.toString(options);
        } else {
            var entries = Object.keys(value).map((key)=>{
                return stringify(key) + ': ' + format(value[key], options);
            });
            return '{' + entries.join(', ') + '}';
        }
    }
    return String(value);
}
function stringify(value) {
    var text = String(value);
    var escaped = '';
    var i = 0;
    while(i < text.length){
        var c = text.charAt(i);
        escaped += c in controlCharacters ? controlCharacters[c] : c;
        i++;
    }
    return '"' + escaped + '"';
}
var controlCharacters = {
    '"': '\\"',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
};
function escape(value) {
    var text = String(value);
    text = text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return text;
}
/**
 * Recursively format an n-dimensional matrix
 * Example output: "[[1, 2], [3, 4]]"
 * @param {Array} array
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {string} str
 */ function formatArray(array, options) {
    if (Array.isArray(array)) {
        var str = '[';
        var len = array.length;
        for(var i = 0; i < len; i++){
            if (i !== 0) {
                str += ', ';
            }
            str += formatArray(array[i], options);
        }
        str += ']';
        return str;
    } else {
        return format(array, options);
    }
}
/**
 * Check whether a value looks like a Fraction (unsafe duck-type check)
 * @param {*} value
 * @return {boolean}
 */ function looksLikeFraction(value) {
    return value && typeof value === 'object' && typeof value.s === 'bigint' && typeof value.n === 'bigint' && typeof value.d === 'bigint' || false;
}
function compareText(x, y) {
    // we don't want to convert numbers to string, only accept string input
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(x)) {
        throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(x) + ', index: 0)');
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(y)) {
        throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(y) + ', index: 1)');
    }
    return x === y ? 0 : x > y ? 1 : -1;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "arraySize": (()=>arraySize),
    "broadcastArrays": (()=>broadcastArrays),
    "broadcastSizes": (()=>broadcastSizes),
    "broadcastTo": (()=>broadcastTo),
    "checkBroadcastingRules": (()=>checkBroadcastingRules),
    "clone": (()=>clone),
    "concat": (()=>concat),
    "deepForEach": (()=>deepForEach),
    "deepMap": (()=>deepMap),
    "filter": (()=>filter),
    "filterRegExp": (()=>filterRegExp),
    "flatten": (()=>flatten),
    "forEach": (()=>forEach),
    "generalize": (()=>generalize),
    "get": (()=>get),
    "getArrayDataType": (()=>getArrayDataType),
    "identify": (()=>identify),
    "initial": (()=>initial),
    "isEmptyIndex": (()=>isEmptyIndex),
    "join": (()=>join),
    "last": (()=>last),
    "map": (()=>map),
    "processSizesWildcard": (()=>processSizesWildcard),
    "reshape": (()=>reshape),
    "resize": (()=>resize),
    "squeeze": (()=>squeeze),
    "stretch": (()=>stretch),
    "unsqueeze": (()=>unsqueeze),
    "validate": (()=>validate),
    "validateIndex": (()=>validateIndex),
    "validateIndexSourceSize": (()=>validateIndexSourceSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/extends.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/IndexError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
function arraySize(x) {
    var s = [];
    while(Array.isArray(x)){
        s.push(x.length);
        x = x[0];
    }
    return s;
}
/**
 * Recursively validate whether each element in a multi dimensional array
 * has a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @param {number} dim     Current dimension
 * @throws DimensionError
 * @private
 */ function _validate(array, size, dim) {
    var i;
    var len = array.length;
    if (len !== size[dim]) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](len, size[dim]);
    }
    if (dim < size.length - 1) {
        // recursively validate each child array
        var dimNext = dim + 1;
        for(i = 0; i < len; i++){
            var child = array[i];
            if (!Array.isArray(child)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](size.length - 1, size.length, '<');
            }
            _validate(array[i], size, dimNext);
        }
    } else {
        // last dimension. none of the children may be an array
        for(i = 0; i < len; i++){
            if (Array.isArray(array[i])) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](size.length + 1, size.length, '>');
            }
        }
    }
}
function validate(array, size) {
    var isScalar = size.length === 0;
    if (isScalar) {
        // scalar
        if (Array.isArray(array)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](array.length, 0);
        }
    } else {
        // array
        _validate(array, size, 0);
    }
}
function validateIndexSourceSize(value, index) {
    var valueSize = value.isMatrix ? value._size : arraySize(value);
    var sourceSize = index._sourceSize;
    // checks if the source size is not null and matches the valueSize
    sourceSize.forEach((sourceDim, i)=>{
        if (sourceDim !== null && sourceDim !== valueSize[i]) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](sourceDim, valueSize[i]);
        }
    });
}
function validateIndex(index, length) {
    if (index !== undefined) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(index) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(index)) {
            throw new TypeError('Index must be an integer (value: ' + index + ')');
        }
        if (index < 0 || typeof length === 'number' && index >= length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IndexError"](index, length);
        }
    }
}
function isEmptyIndex(index) {
    for(var i = 0; i < index._dimensions.length; ++i){
        var dimension = index._dimensions[i];
        if (dimension._data && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isArray"])(dimension._data)) {
            if (dimension._size[0] === 0) {
                return true;
            }
        } else if (dimension.isRange) {
            if (dimension.start === dimension.end) {
                return true;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(dimension)) {
            if (dimension.length === 0) {
                return true;
            }
        }
    }
    return false;
}
function resize(array, size, defaultValue) {
    // check the type of the arguments
    if (!Array.isArray(size)) {
        throw new TypeError('Array expected');
    }
    if (size.length === 0) {
        throw new Error('Resizing to scalar is not supported');
    }
    // check whether size contains positive integers
    size.forEach(function(value) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(value) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(value) || value < 0) {
            throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
        }
    });
    // convert number to an array
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(array) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(array)) {
        array = [
            array
        ];
    }
    // recursively resize the array
    var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
    _resize(array, size, 0, _defaultValue);
    return array;
}
/**
 * Recursively resize a multi dimensional array
 * @param {Array} array         Array to be resized
 * @param {number[]} size       Array with the size of each dimension
 * @param {number} dim          Current dimension
 * @param {*} [defaultValue]    Value to be filled in new entries,
 *                              undefined by default.
 * @private
 */ function _resize(array, size, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size[dim];
    var minLen = Math.min(oldLen, newLen);
    // apply new length
    array.length = newLen;
    if (dim < size.length - 1) {
        // non-last dimension
        var dimNext = dim + 1;
        // resize existing child arrays
        for(i = 0; i < minLen; i++){
            // resize child array
            elem = array[i];
            if (!Array.isArray(elem)) {
                elem = [
                    elem
                ]; // add a dimension
                array[i] = elem;
            }
            _resize(elem, size, dimNext, defaultValue);
        }
        // create new child arrays
        for(i = minLen; i < newLen; i++){
            // get child array
            elem = [];
            array[i] = elem;
            // resize new child array
            _resize(elem, size, dimNext, defaultValue);
        }
    } else {
        // last dimension
        // remove dimensions of existing values
        for(i = 0; i < minLen; i++){
            while(Array.isArray(array[i])){
                array[i] = array[i][0];
            }
        }
        // fill new elements with the default value
        for(i = minLen; i < newLen; i++){
            array[i] = defaultValue;
        }
    }
}
function reshape(array, sizes) {
    var flatArray = flatten(array, true); // since it has rectangular
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
        throw new TypeError('Array expected');
    }
    if (sizes.length === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](0, currentLength, '!=');
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](newLength, currentLength, '!=');
    }
    try {
        return _reshape(flatArray, sizes);
    } catch (e) {
        if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"]) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](newLength, currentLength, '!=');
        }
        throw e;
    }
}
function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
        throw new Error('More than one wildcard in sizes');
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
        if (canReplaceWildcard) {
            processedSizes[wildCardIndex] = -currentLength / newLength;
        } else {
            throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);
        }
    }
    return processedSizes;
}
/**
 * Computes the product of all array elements.
 * @param {number[]} array Array of factors
 * @returns {number}            Product of all elements
 */ function product(array) {
    return array.reduce((prev, curr)=>prev * curr, 1);
}
/**
 * Iteratively re-shape a multi dimensional array to fit the specified dimensions
 * @param {Array} array           Array to be reshaped
 * @param {number[]} sizes  List of sizes for each dimension
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 */ function _reshape(array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array;
    var tmpArray2;
    // for each dimension starting by the last one and ignoring the first one
    for(var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--){
        var size = sizes[sizeIndex];
        tmpArray2 = [];
        // aggregate the elements of the current tmpArray in elements of the requested size
        var length = tmpArray.length / size;
        for(var i = 0; i < length; i++){
            tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
        }
        // set it as the new tmpArray for the next loop turn or for return
        tmpArray = tmpArray2;
    }
    return tmpArray;
}
function squeeze(array, size) {
    var s = size || arraySize(array);
    // squeeze outer dimensions
    while(Array.isArray(array) && array.length === 1){
        array = array[0];
        s.shift();
    }
    // find the first dimension to be squeezed
    var dims = s.length;
    while(s[dims - 1] === 1){
        dims--;
    }
    // squeeze inner dimensions
    if (dims < s.length) {
        array = _squeeze(array, dims, 0);
        s.length = dims;
    }
    return array;
}
/**
 * Recursively squeeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */ function _squeeze(array, dims, dim) {
    var i, ii;
    if (dim < dims) {
        var next = dim + 1;
        for(i = 0, ii = array.length; i < ii; i++){
            array[i] = _squeeze(array[i], dims, next);
        }
    } else {
        while(Array.isArray(array)){
            array = array[0];
        }
    }
    return array;
}
function unsqueeze(array, dims, outer, size) {
    var s = size || arraySize(array);
    // unsqueeze outer dimensions
    if (outer) {
        for(var i = 0; i < outer; i++){
            array = [
                array
            ];
            s.unshift(1);
        }
    }
    // unsqueeze inner dimensions
    array = _unsqueeze(array, dims, 0);
    while(s.length < dims){
        s.push(1);
    }
    return array;
}
/**
 * Recursively unsqueeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the unsqueezed array
 * @private
 */ function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
        var next = dim + 1;
        for(i = 0, ii = array.length; i < ii; i++){
            array[i] = _unsqueeze(array[i], dims, next);
        }
    } else {
        for(var d = dim; d < dims; d++){
            array = [
                array
            ];
        }
    }
    return array;
}
function flatten(array) {
    var isRectangular = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!Array.isArray(array)) {
        // if not an array, return as is
        return array;
    }
    if (typeof isRectangular !== 'boolean') {
        throw new TypeError('Boolean expected for second argument of flatten');
    }
    var flat = [];
    if (isRectangular) {
        _flattenRectangular(array);
    } else {
        _flatten(array);
    }
    return flat;
    "TURBOPACK unreachable";
    function _flatten(array) {
        for(var i = 0; i < array.length; i++){
            var item = array[i];
            if (Array.isArray(item)) {
                _flatten(item);
            } else {
                flat.push(item);
            }
        }
    }
    function _flattenRectangular(array) {
        if (Array.isArray(array[0])) {
            for(var i = 0; i < array.length; i++){
                _flattenRectangular(array[i]);
            }
        } else {
            for(var _i = 0; _i < array.length; _i++){
                flat.push(array[_i]);
            }
        }
    }
}
function map(array, callback) {
    return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
    if (arraySize(array).length !== 1) {
        throw new Error('Only one dimensional matrices supported');
    }
    return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
        throw new Error('Only one dimensional matrices supported');
    }
    return Array.prototype.filter.call(array, (entry)=>regexp.test(entry));
}
function join(array, separator) {
    return Array.prototype.join.call(array, separator);
}
function identify(a) {
    if (!Array.isArray(a)) {
        throw new TypeError('Array input expected');
    }
    if (a.length === 0) {
        return a;
    }
    var b = [];
    var count = 0;
    b[0] = {
        value: a[0],
        identifier: 0
    };
    for(var i = 1; i < a.length; i++){
        if (a[i] === a[i - 1]) {
            count++;
        } else {
            count = 0;
        }
        b.push({
            value: a[i],
            identifier: count
        });
    }
    return b;
}
function generalize(a) {
    if (!Array.isArray(a)) {
        throw new TypeError('Array input expected');
    }
    if (a.length === 0) {
        return a;
    }
    var b = [];
    for(var i = 0; i < a.length; i++){
        b.push(a[i].value);
    }
    return b;
}
function getArrayDataType(array, typeOf) {
    var type; // to hold type info
    var length = 0; // to hold length value to ensure it has consistent sizes
    for(var i = 0; i < array.length; i++){
        var item = array[i];
        var _isArray = Array.isArray(item);
        // Saving the target matrix row size
        if (i === 0 && _isArray) {
            length = item.length;
        }
        // If the current item is an array but the length does not equal the targetVectorSize
        if (_isArray && item.length !== length) {
            return undefined;
        }
        var itemType = _isArray ? getArrayDataType(item, typeOf) // recurse into a nested array
         : typeOf(item);
        if (type === undefined) {
            type = itemType; // first item
        } else if (type !== itemType) {
            return 'mixed';
        } else {
        // we're good, everything has the same type so far
        }
    }
    return type;
}
function last(array) {
    return array[array.length - 1];
}
function initial(array) {
    return array.slice(0, array.length - 1);
}
/**
 * Recursively concatenate two matrices.
 * The contents of the matrices are not cloned.
 * @param {Array} a             Multi dimensional array
 * @param {Array} b             Multi dimensional array
 * @param {number} concatDim    The dimension on which to concatenate (zero-based)
 * @param {number} dim          The current dim (zero-based)
 * @return {Array} c            The concatenated matrix
 * @private
 */ function concatRecursive(a, b, concatDim, dim) {
    if (dim < concatDim) {
        // recurse into next dimension
        if (a.length !== b.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](a.length, b.length);
        }
        var c = [];
        for(var i = 0; i < a.length; i++){
            c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);
        }
        return c;
    } else {
        // concatenate this dimension
        return a.concat(b);
    }
}
function concat() {
    var arrays = Array.prototype.slice.call(arguments, 0, -1);
    var concatDim = Array.prototype.slice.call(arguments, -1);
    if (arrays.length === 1) {
        return arrays[0];
    }
    if (arrays.length > 1) {
        return arrays.slice(1).reduce(function(A, B) {
            return concatRecursive(A, B, concatDim, 0);
        }, arrays[0]);
    } else {
        throw new Error('Wrong number of arguments in function concat');
    }
}
function broadcastSizes() {
    for(var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++){
        sizes[_key] = arguments[_key];
    }
    var dimensions = sizes.map((s)=>s.length);
    var N = Math.max(...dimensions);
    var sizeMax = new Array(N).fill(null);
    // check for every size
    for(var i = 0; i < sizes.length; i++){
        var size = sizes[i];
        var dim = dimensions[i];
        for(var j = 0; j < dim; j++){
            var n = N - dim + j;
            if (size[j] > sizeMax[n]) {
                sizeMax[n] = size[j];
            }
        }
    }
    for(var _i2 = 0; _i2 < sizes.length; _i2++){
        checkBroadcastingRules(sizes[_i2], sizeMax);
    }
    return sizeMax;
}
function checkBroadcastingRules(size, toSize) {
    var N = toSize.length;
    var dim = size.length;
    for(var j = 0; j < dim; j++){
        var n = N - dim + j;
        if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {
            throw new Error("shape mismatch: mismatch is found in arg with shape (".concat(size, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size[j], " to size ").concat(toSize[n]));
        }
    }
}
function broadcastTo(array, toSize) {
    var Asize = arraySize(array);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepStrictEqual"])(Asize, toSize)) {
        return array;
    }
    checkBroadcastingRules(Asize, toSize);
    var broadcastedSize = broadcastSizes(Asize, toSize);
    var N = broadcastedSize.length;
    var paddedSize = [
        ...Array(N - Asize.length).fill(1),
        ...Asize
    ];
    var A = clone(array);
    // reshape A if needed to make it ready for concat
    if (Asize.length < N) {
        A = reshape(A, paddedSize);
        Asize = arraySize(A);
    }
    // stretches the array on each dimension to make it the same size as index
    for(var dim = 0; dim < N; dim++){
        if (Asize[dim] < broadcastedSize[dim]) {
            A = stretch(A, broadcastedSize[dim], dim);
            Asize = arraySize(A);
        }
    }
    return A;
}
function broadcastArrays() {
    for(var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
        arrays[_key2] = arguments[_key2];
    }
    if (arrays.length === 0) {
        throw new Error('Insufficient number of arguments in function broadcastArrays');
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    var sizes = arrays.map(function(array) {
        return arraySize(array);
    });
    var broadcastedSize = broadcastSizes(...sizes);
    var broadcastedArrays = [];
    arrays.forEach(function(array) {
        broadcastedArrays.push(broadcastTo(array, broadcastedSize));
    });
    return broadcastedArrays;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function get(array, index) {
    if (!Array.isArray(array)) {
        throw new Error('Array expected');
    }
    var size = arraySize(array);
    if (index.length !== size.length) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](index.length, size.length);
    }
    for(var x = 0; x < index.length; x++){
        validateIndex(index[x], size[x]);
    }
    return index.reduce((acc, curr)=>acc[curr], array);
}
function deepMap(array, callback) {
    var skipIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (array.length === 0) {
        return [];
    }
    if (skipIndex) {
        return recursiveMap(array);
    }
    var index = [];
    return recursiveMapWithIndex(array, 0);
    "TURBOPACK unreachable";
    function recursiveMapWithIndex(value, depth) {
        if (Array.isArray(value)) {
            var N = value.length;
            var result = Array(N);
            for(var i = 0; i < N; i++){
                index[depth] = i;
                result[i] = recursiveMapWithIndex(value[i], depth + 1);
            }
            return result;
        } else {
            return callback(value, index.slice(0, depth), array);
        }
    }
    function recursiveMap(value) {
        if (Array.isArray(value)) {
            var N = value.length;
            var result = Array(N);
            for(var i = 0; i < N; i++){
                result[i] = recursiveMap(value[i]);
            }
            return result;
        } else {
            return callback(value);
        }
    }
}
function deepForEach(array, callback) {
    var skipIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (array.length === 0) {
        return;
    }
    if (skipIndex) {
        recursiveForEach(array);
        return;
    }
    var index = [];
    recursiveForEachWithIndex(array, 0);
    function recursiveForEachWithIndex(value, depth) {
        if (Array.isArray(value)) {
            var N = value.length;
            for(var i = 0; i < N; i++){
                index[depth] = i;
                recursiveForEachWithIndex(value[i], depth + 1);
            }
        } else {
            callback(value, index.slice(0, depth), array);
        }
    }
    function recursiveForEach(value) {
        if (Array.isArray(value)) {
            var N = value.length;
            for(var i = 0; i < N; i++){
                recursiveForEach(value[i]);
            }
        } else {
            callback(value);
        }
    }
}
function clone(array) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([], array);
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "optimizeCallback": (()=>optimizeCallback)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typed$2d$function$2f$lib$2f$esm$2f$typed$2d$function$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typed-function/lib/esm/typed-function.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
function optimizeCallback(callback, array, name, isUnary) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typed$2d$function$2f$lib$2f$esm$2f$typed$2d$function$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].isTypedFunction(callback)) {
        var numberOfArguments;
        if (isUnary) {
            numberOfArguments = 1;
        } else {
            var firstIndex = (array.isMatrix ? array.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(array)).map(()=>0);
            var firstValue = array.isMatrix ? array.get(firstIndex) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(array, firstIndex);
            numberOfArguments = _findNumberOfArgumentsTyped(callback, firstValue, firstIndex, array);
        }
        var fastCallback;
        if (array.isMatrix && array.dataType !== 'mixed' && array.dataType !== undefined) {
            var singleSignature = _findSingleSignatureWithArity(callback, numberOfArguments);
            fastCallback = singleSignature !== undefined ? singleSignature : callback;
        } else {
            fastCallback = callback;
        }
        if (numberOfArguments >= 1 && numberOfArguments <= 3) {
            return {
                isUnary: numberOfArguments === 1,
                fn: function fn() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    return _tryFunctionWithArgs(fastCallback, args.slice(0, numberOfArguments), name, callback.name);
                }
            };
        }
        return {
            isUnary: false,
            fn: function fn() {
                for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
                    args[_key2] = arguments[_key2];
                }
                return _tryFunctionWithArgs(fastCallback, args, name, callback.name);
            }
        };
    }
    if (isUnary === undefined) {
        return {
            isUnary: _findIfCallbackIsUnary(callback),
            fn: callback
        };
    } else {
        return {
            isUnary,
            fn: callback
        };
    }
}
function _findSingleSignatureWithArity(callback, arity) {
    var matchingFunctions = [];
    Object.entries(callback.signatures).forEach((_ref)=>{
        var [signature, func] = _ref;
        if (signature.split(',').length === arity) {
            matchingFunctions.push(func);
        }
    });
    if (matchingFunctions.length === 1) {
        return matchingFunctions[0];
    }
}
/**
 * Determines if a given callback function is unary (i.e., takes exactly one argument).
 *
 * This function checks the following conditions to determine if the callback is unary:
 * 1. The callback function should have exactly one parameter.
 * 2. The callback function should not use the `arguments` object.
 * 3. The callback function should not use rest parameters (`...`).
 * If in doubt, this function shall return `false` to be safe
 *
 * @param {Function} callback - The callback function to be checked.
 * @returns {boolean} - Returns `true` if the callback is unary, otherwise `false`.
 */ function _findIfCallbackIsUnary(callback) {
    if (callback.length !== 1) return false;
    var callbackStr = callback.toString();
    // Check if the callback function uses `arguments`
    if (/arguments/.test(callbackStr)) return false;
    // Extract the parameters of the callback function
    var paramsStr = callbackStr.match(/\(.*?\)/);
    // Check if the callback function uses rest parameters
    if (/\.\.\./.test(paramsStr)) return false;
    return true;
}
function _findNumberOfArgumentsTyped(callback, value, index, array) {
    var testArgs = [
        value,
        index,
        array
    ];
    for(var i = 3; i > 0; i--){
        var args = testArgs.slice(0, i);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typed$2d$function$2f$lib$2f$esm$2f$typed$2d$function$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].resolve(callback, args) !== null) {
            return i;
        }
    }
}
/**
   * @param {function} func The selected function taken from one of the signatures of the callback function
   * @param {Array} args List with arguments to apply to the selected signature
   * @param {string} mappingFnName the name of the function that is using the callback
   * @param {string} callbackName the name of the callback function
   * @returns {*} Returns the return value of the invoked signature
   * @throws {TypeError} Throws an error when no matching signature was found
   */ function _tryFunctionWithArgs(func, args, mappingFnName, callbackName) {
    try {
        return func(...args);
    } catch (err) {
        _createCallbackError(err, args, mappingFnName, callbackName);
    }
}
/**
 * Creates and throws a detailed TypeError when a callback function fails.
 *
 * @param {Error} err The original error thrown by the callback function.
 * @param {Array} args The arguments that were passed to the callback function.
 * @param {string} mappingFnName The name of the function that is using the callback.
 * @param {string} callbackName The name of the callback function.
 * @throws {TypeError} Throws a detailed TypeError with enriched error message.
 */ function _createCallbackError(err, args, mappingFnName, callbackName) {
    var _err$data;
    // Enrich the error message so the user understands that it took place inside the callback function
    if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === 'wrongType') {
        var argsDesc = [];
        argsDesc.push("value: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(args[0])));
        if (args.length >= 2) {
            argsDesc.push("index: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(args[1])));
        }
        if (args.length >= 3) {
            argsDesc.push("array: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(args[2])));
        }
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callbackName, "(").concat(argsDesc.join(', '), ") at index ").concat(JSON.stringify(args[1])));
    } else {
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callbackName, ": ").concat(err.message));
    }
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/switch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */ __turbopack_context__.s({
    "_switch": (()=>_switch)
});
function _switch(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for(j = 0; j < J; j++){
        var tmp = [];
        for(i = 0; i < I; i++){
            tmp.push(mat[i][j]);
        }
        ret.push(tmp);
    }
    return ret;
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "containsCollections": (()=>containsCollections),
    "deepForEach": (()=>deepForEach),
    "deepMap": (()=>deepMap),
    "reduce": (()=>reduce),
    "scatter": (()=>scatter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/IndexError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$switch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/switch.js [app-ssr] (ecmascript)");
;
;
;
;
function containsCollections(array) {
    for(var i = 0; i < array.length; i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isCollection"])(array[i])) {
            return true;
        }
    }
    return false;
}
function deepForEach(array, callback) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(array)) {
        array.forEach((x)=>callback(x), false, true);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, callback, true);
    }
}
function deepMap(array, callback, skipZeros) {
    if (!skipZeros) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(array)) {
            return array.map((x)=>callback(x), false, true);
        } else {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(array, callback, true);
        }
    }
    var skipZerosCallback = (x)=>x === 0 ? x : callback(x);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(array)) {
        return array.map((x)=>skipZerosCallback(x), false, true);
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(array, skipZerosCallback, true);
    }
}
function reduce(mat, dim, callback) {
    var size = Array.isArray(mat) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(mat) : mat.size();
    if (dim < 0 || dim >= size.length) {
        // TODO: would be more clear when throwing a DimensionError here
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IndexError"](dim, size.length);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(mat)) {
        return mat.create(_reduce(mat.valueOf(), dim, callback), mat.datatype());
    } else {
        return _reduce(mat, dim, callback);
    }
}
/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */ function _reduce(mat, dim, callback) {
    var i, ret, val, tran;
    if (dim <= 0) {
        if (!Array.isArray(mat[0])) {
            val = mat[0];
            for(i = 1; i < mat.length; i++){
                val = callback(val, mat[i]);
            }
            return val;
        } else {
            tran = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$switch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_switch"])(mat);
            ret = [];
            for(i = 0; i < tran.length; i++){
                ret[i] = _reduce(tran[i], dim - 1, callback);
            }
            return ret;
        }
    } else {
        ret = [];
        for(i = 0; i < mat.length; i++){
            ret[i] = _reduce(mat[i], dim - 1, callback);
        }
        return ret;
    }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    // vars
    var k, k0, k1, i;
    // check we need to process values (pattern matrix)
    if (x) {
        // values in j
        for(k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
            // row
            i = aindex[k];
            // check value exists in current j
            if (w[i] !== mark) {
                // i is new entry in j
                w[i] = mark;
                // add i to pattern of C
                cindex.push(i);
                // x(i) = A, check we need to call function this time
                if (update) {
                    // copy value to workspace calling callback function
                    x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
                    // function was called on current row
                    u[i] = mark;
                } else {
                    // copy value to workspace
                    x[i] = avalues[k];
                }
            } else {
                // i exists in C already
                x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
                // function was called on current row
                u[i] = mark;
            }
        }
    } else {
        // values in j
        for(k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
            // row
            i = aindex[k];
            // check value exists in current j
            if (w[i] !== mark) {
                // i is new entry in j
                w[i] = mark;
                // add i to pattern of C
                cindex.push(i);
            } else {
                // indicate function was called on current row
                u[i] = mark;
            }
        }
    }
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Bitwise and for Bignumbers
 *
 * Special Cases:
 *   N &  n =  N
 *   n &  0 =  0
 *   n & -1 =  n
 *   n &  n =  n
 *   I &  I =  I
 *  -I & -I = -I
 *   I & -I =  0
 *   I &  n =  n
 *   I & -n =  I
 *  -I &  n =  0
 *  -I & -n = -I
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` & `y`, is fully precise
 * @private
 */ __turbopack_context__.s({
    "bitAndBigNumber": (()=>bitAndBigNumber),
    "bitNotBigNumber": (()=>bitNotBigNumber),
    "bitOrBigNumber": (()=>bitOrBigNumber),
    "bitXor": (()=>bitXor),
    "bitwise": (()=>bitwise),
    "leftShiftBigNumber": (()=>leftShiftBigNumber),
    "rightArithShiftBigNumber": (()=>rightArithShiftBigNumber)
});
function bitAndBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
        throw new Error('Integers expected in function bitAnd');
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
        return new BigNumber(NaN);
    }
    if (x.isZero() || y.eq(-1) || x.eq(y)) {
        return x;
    }
    if (y.isZero() || x.eq(-1)) {
        return y;
    }
    if (!x.isFinite() || !y.isFinite()) {
        if (!x.isFinite() && !y.isFinite()) {
            if (x.isNegative() === y.isNegative()) {
                return x;
            }
            return new BigNumber(0);
        }
        if (!x.isFinite()) {
            if (y.isNegative()) {
                return x;
            }
            if (x.isNegative()) {
                return new BigNumber(0);
            }
            return y;
        }
        if (!y.isFinite()) {
            if (x.isNegative()) {
                return y;
            }
            if (y.isNegative()) {
                return new BigNumber(0);
            }
            return x;
        }
    }
    return bitwise(x, y, function(a, b) {
        return a & b;
    });
}
function bitNotBigNumber(x) {
    if (x.isFinite() && !x.isInteger()) {
        throw new Error('Integer expected in function bitNot');
    }
    var BigNumber = x.constructor;
    var prevPrec = BigNumber.precision;
    BigNumber.config({
        precision: 1E9
    });
    var result = x.plus(new BigNumber(1));
    result.s = -result.s || null;
    BigNumber.config({
        precision: prevPrec
    });
    return result;
}
function bitOrBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
        throw new Error('Integers expected in function bitOr');
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
        return new BigNumber(NaN);
    }
    var negOne = new BigNumber(-1);
    if (x.isZero() || y.eq(negOne) || x.eq(y)) {
        return y;
    }
    if (y.isZero() || x.eq(negOne)) {
        return x;
    }
    if (!x.isFinite() || !y.isFinite()) {
        if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
            return negOne;
        }
        if (x.isNegative() && y.isNegative()) {
            return x.isFinite() ? x : y;
        }
        return x.isFinite() ? y : x;
    }
    return bitwise(x, y, function(a, b) {
        return a | b;
    });
}
function bitwise(x, y, func) {
    var BigNumber = x.constructor;
    var xBits, yBits;
    var xSign = +(x.s < 0);
    var ySign = +(y.s < 0);
    if (xSign) {
        xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
        for(var i = 0; i < xBits.length; ++i){
            xBits[i] ^= 1;
        }
    } else {
        xBits = decCoefficientToBinaryString(x);
    }
    if (ySign) {
        yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
        for(var _i = 0; _i < yBits.length; ++_i){
            yBits[_i] ^= 1;
        }
    } else {
        yBits = decCoefficientToBinaryString(y);
    }
    var minBits, maxBits, minSign;
    if (xBits.length <= yBits.length) {
        minBits = xBits;
        maxBits = yBits;
        minSign = xSign;
    } else {
        minBits = yBits;
        maxBits = xBits;
        minSign = ySign;
    }
    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber(expFuncVal ^ 1);
    var twoPower = new BigNumber(1);
    var two = new BigNumber(2);
    var prevPrec = BigNumber.precision;
    BigNumber.config({
        precision: 1E9
    });
    while(shortLen > 0){
        if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
            outVal = outVal.plus(twoPower);
        }
        twoPower = twoPower.times(two);
    }
    while(longLen > 0){
        if (func(minSign, maxBits[--longLen]) === expFuncVal) {
            outVal = outVal.plus(twoPower);
        }
        twoPower = twoPower.times(two);
    }
    BigNumber.config({
        precision: prevPrec
    });
    if (expFuncVal === 0) {
        outVal.s = -outVal.s;
    }
    return outVal;
}
/* Extracted from decimal.js, and edited to specialize. */ function decCoefficientToBinaryString(x) {
    // Convert to string
    var a = x.d; // array with digits
    var r = a[0] + '';
    for(var i = 1; i < a.length; ++i){
        var s = a[i] + '';
        for(var z = 7 - s.length; z--;){
            s = '0' + s;
        }
        r += s;
    }
    var j = r.length;
    while(r.charAt(j) === '0'){
        j--;
    }
    var xe = x.e;
    var str = r.slice(0, j + 1 || 1);
    var strL = str.length;
    if (xe > 0) {
        if (++xe > strL) {
            // Append zeros.
            xe -= strL;
            while(xe--){
                str += '0';
            }
        } else if (xe < strL) {
            str = str.slice(0, xe) + '.' + str.slice(xe);
        }
    }
    // Convert from base 10 (decimal) to base 2
    var arr = [
        0
    ];
    for(var _i2 = 0; _i2 < str.length;){
        var arrL = arr.length;
        while(arrL--){
            arr[arrL] *= 10;
        }
        arr[0] += parseInt(str.charAt(_i2++)); // convert to int
        for(var _j = 0; _j < arr.length; ++_j){
            if (arr[_j] > 1) {
                if (arr[_j + 1] === null || arr[_j + 1] === undefined) {
                    arr[_j + 1] = 0;
                }
                arr[_j + 1] += arr[_j] >> 1;
                arr[_j] &= 1;
            }
        }
    }
    return arr.reverse();
}
function bitXor(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
        throw new Error('Integers expected in function bitXor');
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
        return new BigNumber(NaN);
    }
    if (x.isZero()) {
        return y;
    }
    if (y.isZero()) {
        return x;
    }
    if (x.eq(y)) {
        return new BigNumber(0);
    }
    var negOne = new BigNumber(-1);
    if (x.eq(negOne)) {
        return bitNotBigNumber(y);
    }
    if (y.eq(negOne)) {
        return bitNotBigNumber(x);
    }
    if (!x.isFinite() || !y.isFinite()) {
        if (!x.isFinite() && !y.isFinite()) {
            return negOne;
        }
        return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
    }
    return bitwise(x, y, function(a, b) {
        return a ^ b;
    });
}
function leftShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
        throw new Error('Integers expected in function leftShift');
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
        return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
        return x;
    }
    if (!x.isFinite() && !y.isFinite()) {
        return new BigNumber(NaN);
    }
    // Math.pow(2, y) is fully precise for y < 55, and fast
    if (y.lt(55)) {
        return x.times(Math.pow(2, y.toNumber()) + '');
    }
    return x.times(new BigNumber(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
        throw new Error('Integers expected in function rightArithShift');
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
        return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
        return x;
    }
    if (!y.isFinite()) {
        if (x.isNegative()) {
            return new BigNumber(-1);
        }
        if (!x.isFinite()) {
            return new BigNumber(NaN);
        }
        return new BigNumber(0);
    }
    // Math.pow(2, y) is fully precise for y < 55, and fast
    if (y.lt(55)) {
        return x.div(Math.pow(2, y.toNumber()) + '').floor();
    }
    return x.div(new BigNumber(2).pow(y)).floor();
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/product.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @param {number} i
 *  @param {number} n
 *  @returns {number} product of i to n
 */ __turbopack_context__.s({
    "product": (()=>product)
});
function product(i, n) {
    if (n < i) {
        return 1;
    }
    if (n === i) {
        return n;
    }
    var half = n + i >> 1; // divide (n + i) by 2 and truncate to integer
    return product(i, half) * product(half + 1, n);
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Compares two BigNumbers.
 * @param {BigNumber} a - First value to compare
 * @param {BigNumber} b - Second value to compare
 * @param {number} [relTol=1e-09] - The relative tolerance, indicating the maximum allowed difference relative to the larger absolute value. Must be greater than 0.
 * @param {number} [absTol=0] - The minimum absolute tolerance, useful for comparisons near zero. Must be at least 0.
 * @returns {boolean} whether the two numbers are nearly equal
 * @throws {Error} If `relTol` is less than or equal to 0.
 * @throws {Error} If `absTol` is less than 0.
 *
 * @example
 * nearlyEqual(1.000000001, 1.0, 1e-9);            // true
 * nearlyEqual(1.000000002, 1.0, 0);            // false
 * nearlyEqual(1.0, 1.009, undefined, 0.02);       // true
 * nearlyEqual(0.000000001, 0.0, undefined, 1e-8); // true
 */ __turbopack_context__.s({
    "nearlyEqual": (()=>nearlyEqual)
});
function nearlyEqual(a, b) {
    var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-9;
    var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (relTol <= 0) {
        throw new Error('Relative tolerance must be greater than 0');
    }
    if (absTol < 0) {
        throw new Error('Absolute tolerance must be at least 0');
    }
    // NaN
    if (a.isNaN() || b.isNaN()) {
        return false;
    }
    if (!a.isFinite() || !b.isFinite()) {
        return a.eq(b);
    }
    // use "==" operator, handles infinities
    if (a.eq(b)) {
        return true;
    }
    // abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)
    return a.minus(b).abs().lte(a.constructor.max(a.constructor.max(a.abs(), b.abs()).mul(relTol), absTol));
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/complex.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "complexEquals": (()=>complexEquals)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
function complexEquals(x, y, relTol, absTol) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x.re, y.re, relTol, absTol) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x.im, y.im, relTol, absTol);
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Build a bigint logarithm function from a number logarithm,
 * still returning a number. The idea is that 15 hexadecimal digits
 * (60 bits) saturates the mantissa of the log, and each additional hex
 * digit effectively just adds the log of 16 to the resulting value. So
 * convert the most significant 15 hex digits to a number and take its
 * log, and then add the log of 16 for each additional hex digit that
 * was in the bigint.
 * For negative numbers (complex logarithms), following the bignum
 * implementation, it just downgrades to number and uses the complex result.
 * @param {number} log16  the log of 16
 * @param {(number) -> number} numberLog  the logarithm function for numbers
 * @param {ConfigurationObject} config  the mathjs configuration
 * @param {(number) -> Complex} cplx  the associated Complex log
 * @returns {(bigint) -> number}   the corresponding logarithm for bigints
 */ __turbopack_context__.s({
    "promoteLogarithm": (()=>promoteLogarithm)
});
function promoteLogarithm(log16, numberLog, config, cplx) {
    return function(b) {
        if (b > 0 || config.predictable) {
            if (b <= 0) return NaN;
            var s = b.toString(16);
            var s15 = s.substring(0, 15);
            return log16 * (s.length - s15.length) + numberLog(Number('0x' + s15));
        }
        return cplx(b.toNumber());
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/utils/print.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "printTemplate": (()=>printTemplate)
});
var printTemplate = /\$([\w.]+)/g;
}}),
"[project]/node_modules/mathjs/lib/esm/utils/noop.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "noBignumber": (()=>noBignumber),
    "noFraction": (()=>noFraction),
    "noIndex": (()=>noIndex),
    "noMatrix": (()=>noMatrix),
    "noSubset": (()=>noSubset)
});
function noBignumber() {
    throw new Error('No "bignumber" implementation available');
}
function noFraction() {
    throw new Error('No "fraction" implementation available');
}
function noMatrix() {
    throw new Error('No "matrix" implementation available');
}
function noIndex() {
    throw new Error('No "index" implementation available');
}
function noSubset() {
    throw new Error('No "matrix" implementation available');
}
}}),

};

//# sourceMappingURL=node_modules_mathjs_lib_esm_utils_92281bb1._.js.map