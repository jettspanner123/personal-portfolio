module.exports = {

"[project]/node_modules/mathjs/lib/esm/function/arithmetic/abs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAbs": (()=>createAbs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
var name = 'abs';
var dependencies = [
    'typed'
];
var createAbs = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5)                // returns number 3.5
   *    math.abs(-4.2)               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["absNumber"],
        'Complex | BigNumber | Fraction | Unit': (x)=>x.abs(),
        bigint: (x)=>x < 0n ? -x : x,
        // deep map collection, skip zeros since abs(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acos.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcos": (()=>createAcos)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'acos';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createAcos = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the inverse cosine of a value.
   *
   * To avoid confusion with the matrix arccosine, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5)           // returns number 1.0471975511965979
   *    math.acos(math.cos(1.5)) // returns number 1.5
   *
   *    math.acos(2)             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} The arc cosine of x
   */ return typed(name, {
        number: function number(x) {
            if (x >= -1 && x <= 1 || config.predictable) {
                return Math.acos(x);
            } else {
                return new Complex(x, 0).acos();
            }
        },
        Complex: function Complex(x) {
            return x.acos();
        },
        BigNumber: function BigNumber(x) {
            return x.acos();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcot": (()=>createAcot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'acot';
var dependencies = [
    'typed',
    'BigNumber'
];
var createAcot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
   *
   * To avoid confusion with the matrix arccotanget, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acot(x)
   *
   * Examples:
   *
   *    math.acot(0.5)           // returns number 1.1071487177940904
   *    math.acot(2)             // returns number 0.4636476090008061
   *    math.acot(math.cot(1.5)) // returns number 1.5
   *
   * See also:
   *
   *    cot, atan
   *
   * @param {number | BigNumber| Complex} x   Function input
   * @return {number | BigNumber| Complex} The arc cotangent of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["acotNumber"],
        Complex: function Complex(x) {
            return x.acot();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).atan();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acsc.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcsc": (()=>createAcsc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'acsc';
var dependencies = [
    'typed',
    'config',
    'Complex',
    'BigNumber'
];
var createAcsc = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
   *
   * To avoid confusion with the matrix arccosecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acsc(x)
   *
   * Examples:
   *
   *    math.acsc(2)             // returns 0.5235987755982989
   *    math.acsc(0.5)           // returns Complex 1.5707963267948966 -1.3169578969248166i
   *    math.acsc(math.csc(1.5)) // returns number 1.5
   *
   * See also:
   *
   *    csc, asin, asec
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc cosecant of x
   */ return typed(name, {
        number: function number(x) {
            if (x <= -1 || x >= 1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["acscNumber"])(x);
            }
            return new Complex(x, 0).acsc();
        },
        Complex: function Complex(x) {
            return x.acsc();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).asin();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAddScalar": (()=>createAddScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'addScalar';
var dependencies = [
    'typed'
];
var createAddScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Sum of `x` and `y`
   * @private
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.add(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.plus(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x + y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.add(y);
        },
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>{
                if (x.value === null || x.value === undefined) {
                    throw new Error('Parameter x contains a unit with undefined value');
                }
                if (y.value === null || y.value === undefined) {
                    throw new Error('Parameter y contains a unit with undefined value');
                }
                if (!x.equalBase(y)) throw new Error('Units do not match');
                var res = x.clone();
                res.value = typed.find(self, [
                    res.valueType(),
                    y.valueType()
                ])(res.value, y.value);
                res.fixPrefix = false;
                return res;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/complex/arg.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createArg": (()=>createArg)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
;
;
var name = 'arg';
var dependencies = [
    'typed'
];
var createArg = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the argument of a complex value.
   * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.arg(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 2)
   *    math.arg(a) / math.pi          // returns number 0.25
   *
   *    const b = math.complex('2 + 3i')
   *    math.arg(b)                    // returns number 0.982793723247329
   *    math.atan2(3, 2)               // returns number 0.982793723247329
   *
   * See also:
   *
   *    re, im, conj, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The argument of x
   */ return typed(name, {
        number: function number(x) {
            return Math.atan2(0, x);
        },
        BigNumber: function BigNumber(x) {
            return x.constructor.atan2(0, x);
        },
        Complex: function Complex(x) {
            return x.arg();
        },
        // TODO: implement BigNumber support for function arg
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/asech.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAsech": (()=>createAsech)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'asech';
var dependencies = [
    'typed',
    'config',
    'Complex',
    'BigNumber'
];
var createAsech = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the hyperbolic arcsecant of a value,
   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
   *
   * To avoid confusion with the matrix hyperbolic arcsecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.asech(x)
   *
   * Examples:
   *
   *    math.asech(0.5)       // returns 1.3169578969248166
   *
   * See also:
   *
   *    acsch, acoth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arcsecant of x
   */ return typed(name, {
        number: function number(x) {
            if (x <= 1 && x >= -1 || config.predictable) {
                var xInv = 1 / x;
                if (xInv > 0 || config.predictable) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asechNumber"])(x);
                }
                var ret = Math.sqrt(xInv * xInv - 1);
                return new Complex(Math.log(ret - xInv), Math.PI);
            }
            return new Complex(x, 0).asech();
        },
        Complex: function Complex(x) {
            return x.asech();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).acosh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/asinh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAsinh": (()=>createAsinh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'asinh';
var dependencies = [
    'typed'
];
var createAsinh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the hyperbolic arcsine of a value,
   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
   *
   * To avoid confusion with the matrix hyperbolic arcsine, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.asinh(x)
   *
   * Examples:
   *
   *    math.asinh(0.5)       // returns 0.48121182505960347
   *
   * See also:
   *
   *    acosh, atanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arcsine of x
   */ return typed('asinh', {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asinhNumber"],
        Complex: function Complex(x) {
            return x.asinh();
        },
        BigNumber: function BigNumber(x) {
            return x.asinh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/atan.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAtan": (()=>createAtan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'atan';
var dependencies = [
    'typed'
];
var createAtan = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the inverse tangent of a value.
   *
   * To avoid confusion with matrix arctangent, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5)           // returns number 0.4636476090008061
   *    math.atan(2)             // returns number 1.1071487177940904
   *    math.atan(math.tan(1.5)) // returns number 1.5
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc tangent of x
   */ return typed('atan', {
        number: function number(x) {
            return Math.atan(x);
        },
        Complex: function Complex(x) {
            return x.atan();
        },
        BigNumber: function BigNumber(x) {
            return x.atan();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/atanh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAtanh": (()=>createAtanh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'atanh';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createAtanh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the hyperbolic arctangent of a value,
   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
   *
   * To avoid confusion with the matrix hyperbolic arctangent, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.atanh(x)
   *
   * Examples:
   *
   *    math.atanh(0.5)       // returns 0.5493061443340549
   *
   * See also:
   *
   *    acosh, asinh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arctangent of x
   */ return typed(name, {
        number: function number(x) {
            if (x <= 1 && x >= -1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["atanhNumber"])(x);
            }
            return new Complex(x, 0).atanh();
        },
        Complex: function Complex(x) {
            return x.atanh();
        },
        BigNumber: function BigNumber(x) {
            return x.atanh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/bitNot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBitNot": (()=>createBitNot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'bitNot';
var dependencies = [
    'typed'
];
var createBitNot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Bitwise NOT value, `~x`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.bitNot(x)
   *
   * Examples:
   *
   *    math.bitNot(1)               // returns number -2
   *
   *    math.bitNot([2, -3, 4])      // returns Array [-3, 2, -5]
   *
   * See also:
   *
   *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x Value to not
   * @return {number | BigNumber | bigint | Array | Matrix} NOT of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitNotNumber"],
        BigNumber: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitNotBigNumber"],
        bigint: (x)=>~x,
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/clone.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClone": (()=>createClone)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'clone';
var dependencies = [
    'typed'
];
var createClone = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Clone an object. Will make a deep copy of the data.
   *
   * Syntax:
   *
   *     math.clone(x)
   *
   * Examples:
   *
   *    math.clone(3.5)                   // returns number 3.5
   *    math.clone(math.complex('2-4i'))  // returns Complex 2 - 4i
   *    math.clone(math.unit(45, 'deg'))  // returns Unit 45 deg
   *    math.clone([[1, 2], [3, 4]])      // returns Array [[1, 2], [3, 4]]
   *    math.clone("hello world")         // returns string "hello world"
   *
   * @param {*} x   Object to be cloned
   * @return {*} A clone of object x
   */ return typed(name, {
        any: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"]
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/combinations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCombinations": (()=>createCombinations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$combinations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/combinations.js [app-ssr] (ecmascript)");
;
;
var name = 'combinations';
var dependencies = [
    'typed'
];
var createCombinations = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities.
   *
   * Combinations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.combinations(n, k)
   *
   * Examples:
   *
   *    math.combinations(7, 5) // returns 21
   *
   * See also:
   *
   *    combinationsWithRep, permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations.
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$combinations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combinationsNumber"],
        'BigNumber, BigNumber': function BigNumber_BigNumber(n, k) {
            var BigNumber = n.constructor;
            var result, i;
            var nMinusk = n.minus(k);
            var one = new BigNumber(1);
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
                throw new TypeError('Positive integer value expected in function combinations');
            }
            if (k.gt(n)) {
                throw new TypeError('k must be less than n in function combinations');
            }
            result = one;
            if (k.lt(nMinusk)) {
                for(i = one; i.lte(nMinusk); i = i.plus(one)){
                    result = result.times(k.plus(i)).dividedBy(i);
                }
            } else {
                for(i = one; i.lte(k); i = i.plus(one)){
                    result = result.times(nMinusk.plus(i)).dividedBy(i);
                }
            }
            return result;
        }
    });
});
/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */ function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/complex/conj.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createConj": (()=>createConj)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
;
;
var name = 'conj';
var dependencies = [
    'typed'
];
var createConj = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the complex conjugate of a complex value.
   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.conj(x)
   *
   * Examples:
   *
   *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
   *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
   *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
   *
   * See also:
   *
   *    re, im, arg, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Complex | Array | Matrix | Unit}
   *            The complex conjugate of x
   */ return typed(name, {
        'number | BigNumber | Fraction': (x)=>x,
        Complex: (x)=>x.conjugate(),
        Unit: typed.referToSelf((self)=>(x)=>new x.constructor(self(x.toNumeric()), x.formatUnits())),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTrigUnit": (()=>createTrigUnit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var createTrigUnit = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])('trigUnit', [
    'typed'
], (_ref)=>{
    var { typed } = _ref;
    return {
        Unit: typed.referToSelf((self)=>(x)=>{
                if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
                    throw new TypeError('Unit in function cot is no angle');
                }
                return typed.find(self, x.valueType())(x.value);
            })
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/cos.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCos": (()=>createCos)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
var name = 'cos';
var dependencies = [
    'typed'
];
var createCos = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the cosine of a value.
   *
   * To avoid confusion with the matrix cosine, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2)                      // returns number -0.4161468365471422
   *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'))  // returns number -1
   *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
   *
   *    const angle = 0.2
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number 1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Cosine of x
   */ return typed(name, {
        number: Math.cos,
        'Complex | BigNumber': (x)=>x.cos()
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/cot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCot": (()=>createCot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
;
var name = 'cot';
var dependencies = [
    'typed',
    'BigNumber'
];
var createCot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
   *
   * To avoid confusion with the matrix cotangent, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2)      // returns number -0.45765755436028577
   *    1 / math.tan(2)  // returns number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cotangent of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cotNumber"],
        Complex: (x)=>x.cot(),
        BigNumber: (x)=>new _BigNumber(1).div(x.tan())
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/csc.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCsc": (()=>createCsc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
;
var name = 'csc';
var dependencies = [
    'typed',
    'BigNumber'
];
var createCsc = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * To avoid confusion with the matrix cosecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2)      // returns number 1.099750170294617
   *    1 / math.sin(2)  // returns number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Cosecant of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cscNumber"],
        Complex: (x)=>x.csc(),
        BigNumber: (x)=>new _BigNumber(1).div(x.sin())
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/cube.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCube": (()=>createCube)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'cube';
var dependencies = [
    'typed'
];
var createCube = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the cube of a value, `x * x * x`.
   * To avoid confusion with `pow(M,3)`, this function does not apply to matrices.
   * If you wish to cube every entry of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2)            // returns number 8
   *    math.pow(2, 3)          // returns number 8
   *    math.cube(4)            // returns number 64
   *    4 * 4 * 4               // returns number 64
   *
   *    math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit} Cube of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubeNumber"],
        Complex: function Complex(x) {
            return x.mul(x).mul(x); // Is faster than pow(x, 3)
        },
        BigNumber: function BigNumber(x) {
            return x.times(x).times(x);
        },
        bigint: function bigint(x) {
            return x * x * x;
        },
        Fraction: function Fraction(x) {
            return x.pow(3); // Is faster than mul()mul()mul()
        },
        Unit: function Unit(x) {
            return x.pow(3);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCompareUnits": (()=>createCompareUnits)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var createCompareUnits = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])('compareUnits', [
    'typed'
], (_ref)=>{
    var { typed } = _ref;
    return {
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>{
                if (!x.equalBase(y)) {
                    throw new Error('Cannot compare units with different base');
                }
                return typed.find(self, [
                    x.valueType(),
                    y.valueType()
                ])(x.value, y.value);
            })
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/equalScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEqualScalar": (()=>createEqualScalar),
    "createEqualScalarNumber": (()=>createEqualScalarNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$complex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/complex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'equalScalar';
var dependencies = [
    'typed',
    'config'
];
var createEqualScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config } = _ref;
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Test whether two scalar values are nearly equal.
   *
   * @param  {number | BigNumber | bigint | Fraction | boolean | Complex | Unit} x   First value to compare
   * @param  {number | BigNumber | bigint | Fraction | boolean | Complex} y          Second value to compare
   * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
   * @private
   */ return typed(name, {
        'boolean, boolean': function boolean_boolean(x, y) {
            return x === y;
        },
        'number, number': function number_number(x, y) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.eq(y) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x === y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.equals(y);
        },
        'Complex, Complex': function Complex_Complex(x, y) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$complex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["complexEquals"])(x, y, config.relTol, config.absTol);
        }
    }, compareUnits);
});
var createEqualScalarNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/special/erf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable no-loss-of-precision */ __turbopack_context__.s({
    "createErf": (()=>createErf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'erf';
var dependencies = [
    'typed'
];
var createErf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the erf function of a value using a rational Chebyshev
   * approximations for different intervals of x.
   *
   * This is a translation of W. J. Cody's Fortran implementation from 1987
   * ( https://www.netlib.org/specfun/erf ). See the AMS publication
   * "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
   * for an explanation of this process.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.erf(x)
   *
   * Examples:
   *
   *    math.erf(0.2)    // returns 0.22270258921047847
   *    math.erf(-0.5)   // returns -0.5204998778130465
   *    math.erf(4)      // returns 0.9999999845827421
   *
   * See also:
   *    zeta
   *
   * @param {number | Array | Matrix} x   A real number
   * @return {number | Array | Matrix}    The erf of `x`
   */ return typed('name', {
        number: function number(x) {
            var y = Math.abs(x);
            if (y >= MAX_NUM) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sign"])(x);
            }
            if (y <= THRESH) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sign"])(x) * erf1(y);
            }
            if (y <= 4.0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sign"])(x) * (1 - erfc2(y));
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sign"])(x) * (1 - erfc3(y));
        },
        'Array | Matrix': typed.referToSelf((self)=>(n)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(n, self))
    });
    "TURBOPACK unreachable";
    /**
   * Approximates the error function erf() for x <= 0.46875 using this function:
   *               n
   * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))
   *              j=0
   */ function erf1(y) {
        var ysq = y * y;
        var xnum = P[0][4] * ysq;
        var xden = ysq;
        var i;
        for(i = 0; i < 3; i += 1){
            xnum = (xnum + P[0][i]) * ysq;
            xden = (xden + Q[0][i]) * ysq;
        }
        return y * (xnum + P[0][3]) / (xden + Q[0][3]);
    }
    /**
   * Approximates the complement of the error function erfc() for
   * 0.46875 <= x <= 4.0 using this function:
   *                       n
   * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)
   *                      j=0
   */ function erfc2(y) {
        var xnum = P[1][8] * y;
        var xden = y;
        var i;
        for(i = 0; i < 7; i += 1){
            xnum = (xnum + P[1][i]) * y;
            xden = (xden + Q[1][i]) * y;
        }
        var result = (xnum + P[1][7]) / (xden + Q[1][7]);
        var ysq = parseInt(y * 16) / 16;
        var del = (y - ysq) * (y + ysq);
        return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    /**
   * Approximates the complement of the error function erfc() for x > 4.0 using
   * this function:
   *
   * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +
   *               n
   *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]
   *              j=0
   */ function erfc3(y) {
        var ysq = 1 / (y * y);
        var xnum = P[2][5] * ysq;
        var xden = ysq;
        var i;
        for(i = 0; i < 4; i += 1){
            xnum = (xnum + P[2][i]) * ysq;
            xden = (xden + Q[2][i]) * ysq;
        }
        var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
        result = (SQRPI - result) / y;
        ysq = parseInt(y * 16) / 16;
        var del = (y - ysq) * (y + ysq);
        return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
});
/**
 * Upper bound for the first approximation interval, 0 <= x <= THRESH
 * @constant
 */ var THRESH = 0.46875;
/**
 * Constant used by W. J. Cody's Fortran77 implementation to denote sqrt(pi)
 * @constant
 */ var SQRPI = 5.6418958354775628695e-1;
/**
 * Coefficients for each term of the numerator sum (p_j) for each approximation
 * interval (see W. J. Cody's paper for more details)
 * @constant
 */ var P = [
    [
        3.16112374387056560e00,
        1.13864154151050156e02,
        3.77485237685302021e02,
        3.20937758913846947e03,
        1.85777706184603153e-1
    ],
    [
        5.64188496988670089e-1,
        8.88314979438837594e00,
        6.61191906371416295e01,
        2.98635138197400131e02,
        8.81952221241769090e02,
        1.71204761263407058e03,
        2.05107837782607147e03,
        1.23033935479799725e03,
        2.15311535474403846e-8
    ],
    [
        3.05326634961232344e-1,
        3.60344899949804439e-1,
        1.25781726111229246e-1,
        1.60837851487422766e-2,
        6.58749161529837803e-4,
        1.63153871373020978e-2
    ]
];
/**
 * Coefficients for each term of the denominator sum (q_j) for each approximation
 * interval (see W. J. Cody's paper for more details)
 * @constant
 */ var Q = [
    [
        2.36012909523441209e01,
        2.44024637934444173e02,
        1.28261652607737228e03,
        2.84423683343917062e03
    ],
    [
        1.57449261107098347e01,
        1.17693950891312499e02,
        5.37181101862009858e02,
        1.62138957456669019e03,
        3.29079923573345963e03,
        4.36261909014324716e03,
        3.43936767414372164e03,
        1.23033935480374942e03
    ],
    [
        2.56852019228982242e00,
        1.87295284992346047e00,
        5.27905102951428412e-1,
        6.05183413124413191e-2,
        2.33520497626869185e-3
    ]
];
/**
 * Maximum/minimum safe numbers to input to erf() (in ES6+, this number is
 * Number.[MAX|MIN]_SAFE_INTEGER). erf() for all numbers beyond this limit will
 * return 1
 */ var MAX_NUM = Math.pow(2, 53);
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/exp.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createExp": (()=>createExp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'exp';
var dependencies = [
    'typed'
];
var createExp = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the exponential of a value.
   * For matrices, if you want the matrix exponential of square matrix, use
   * the `expm` function; if you want to take the exponential of each element,
   * see the examples.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2)                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2)          // returns number 7.3890560989306495
   *    math.log(math.exp(2))        // returns number 2
   *
   *    math.map([1, 2, 3], math.exp)
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    expm1, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  A number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["expNumber"],
        Complex: function Complex(x) {
            return x.exp();
        },
        BigNumber: function BigNumber(x) {
            return x.exp();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/expm1.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createExpm1": (()=>createExpm1)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'expm1';
var dependencies = [
    'typed',
    'Complex'
];
var createExpm1 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Complex: _Complex } = _ref;
    /**
   * Calculate the value of subtracting 1 from the exponential value.
   * This function is more accurate than `math.exp(x)-1` when `x` is near 0
   * To avoid ambiguity with the matrix exponential `expm`, this function
   * does not operate on matrices; if you wish to apply it elementwise, see
   * the examples.
   *
   * Syntax:
   *
   *    math.expm1(x)
   *
   * Examples:
   *
   *    math.expm1(2)                      // returns number 6.38905609893065
   *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
   *    math.expm1(1e-8)                   // returns number 1.0000000050000001e-8
   *    math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9
   *    math.log(math.expm1(2) + 1)        // returns number 2
   *
   *    math.map([1, 2, 3], math.expm1)
   *    // returns Array [
   *    //   1.718281828459045,
   *    //   6.3890560989306495,
   *    //   19.085536923187668
   *    // ]
   *
   * See also:
   *
   *    exp, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  The number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`, minus one
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["expm1Number"],
        Complex: function Complex(x) {
            var r = Math.exp(x.re);
            return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
        },
        BigNumber: function BigNumber(x) {
            return x.exp().minus(1);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/filter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFilter": (()=>createFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'filter';
var dependencies = [
    'typed'
];
var createFilter = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Filter the items in an array or one dimensional matrix.
   *
   * The callback is invoked with three arguments: the current value,
   * the current index, and the matrix operated upon.
   * Note that because the matrix/array might be
   * multidimensional, the "index" argument is always an array of numbers giving
   * the index in each dimension. This is true even for vectors: the "index"
   * argument is an array of length 1, rather than simply a number.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x > 0
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/) // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        All entries for which `test` returns true are returned.
   *        When `test` is a function, it is invoked with three parameters:
   *        the value of the element, the index of the element, and the
   *        matrix/array being traversed. The function must return a boolean.
   * @return {Matrix | Array} Returns the filtered matrix.
   */ return typed('filter', {
        'Array, function': _filterCallback,
        'Matrix, function': function Matrix_function(x, test) {
            return x.create(_filterCallback(x.valueOf(), test), x.datatype());
        },
        'Array, RegExp': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterRegExp"],
        'Matrix, RegExp': function Matrix_RegExp(x, test) {
            return x.create((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterRegExp"])(x.valueOf(), test), x.datatype());
        }
    });
});
/**
 * Filter values in a callback given a callback function
 * @param {Array} x
 * @param {Function} callback
 * @return {Array} Returns the filtered array
 * @private
 */ function _filterCallback(x, callback) {
    var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, x, 'filter');
    if (fastCallback.isUnary) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filter"])(x, fastCallback.fn);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filter"])(x, function(value, index, array) {
        // invoke the callback function with the right number of arguments
        return fastCallback.fn(value, [
            index
        ], array);
    });
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/flatten.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFlatten": (()=>createFlatten)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'flatten';
var dependencies = [
    'typed'
];
var createFlatten = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Flatten a multidimensional matrix into a single dimensional matrix.
   * A new matrix is returned, the original matrix is left untouched.
   *
   * Syntax:
   *
   *    math.flatten(x)
   *
   * Examples:
   *
   *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
   *
   * See also:
   *
   *    concat, resize, size, squeeze
   *
   * @param {Matrix | Array} x   Matrix to be flattened
   * @return {Matrix | Array} Returns the flattened matrix
   */ return typed(name, {
        Array: function Array(x) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(x);
        },
        Matrix: function Matrix(x) {
            // Return the same matrix type as x (Dense or Sparse Matrix)
            // Return the same data type as x
            return x.create((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(x.valueOf(), true), x.datatype());
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/forEach.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createForEach": (()=>createForEach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
;
;
;
var name = 'forEach';
var dependencies = [
    'typed'
];
var createForEach = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * The callback is invoked with three arguments: the current value,
   * the current index, and the matrix operated upon.
   * Note that because the matrix/array might be
   * multidimensional, the "index" argument is always an array of numbers giving
   * the index in each dimension. This is true even for vectors: the "index"
   * argument is an array of length 1, rather than simply a number.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value)
   *    })
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */ return typed(name, {
        'Array, function': _forEach,
        'Matrix, function': function Matrix_function(x, callback) {
            x.forEach(callback);
        }
    });
});
/**
 * forEach for a multidimensional array
 * @param {Array} array
 * @param {Function} callback
 * @private
 */ function _forEach(array, callback) {
    var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, array, name);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, fastCallback.fn, fastCallback.isUnary);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/string/format.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFormat": (()=>createFormat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'format';
var dependencies = [
    'typed'
];
var createFormat = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, callback)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: string`
   *      Number notation. Choose from:
   *      - `'fixed'`
   *        Always use regular number notation.
   *        For example `'123.40'` and `'14000000'`
   *      - `'exponential'`
   *        Always use exponential notation.
   *        For example `'1.234e+2'` and `'1.4e+7'`
   *      - `'engineering'`
   *        Always use engineering notation: always have exponential notation,
   *        and select the exponent to be a multiple of `3`.
   *        For example `'123.4e+0'` and `'14.0e+6'`
   *      - `'auto'` (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example `'123.4'` and `'1.4e7'`.
   *      - `'bin'`, `'oct'`, or `'hex'`
   *        Format the number using binary, octal, or hexadecimal notation.
   *        For example `'0b1101'` and `'0x10fe'`.
   *    - `wordSize: number | BigNumber`
   *      The word size in bits to use for formatting in binary, octal, or
   *      hexadecimal notation. To be used only with `'bin'`, `'oct'`, or `'hex'`
   *      values for `notation` option. When this option is defined the value
   *      is formatted as a signed twos complement integer of the given word
   *      size and the size suffix is appended to the output.
   *      For example `format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'`.
   *      Default value is undefined.
   *    - `precision: number | BigNumber`
   *      Limit the number of digits of the formatted value.
   *      For regular numbers, must be a number between `0` and `16`.
   *      For bignumbers, the maximum depends on the configured precision,
   *      see function `config()`.
   *      In case of notations `'exponential'`, `'engineering'`, and `'auto'`,
   *      `precision` defines the total number of significant digits returned.
   *      In case of notation `'fixed'`, `precision` defines the number of
   *      significant digits after the decimal point.
   *      `precision` is undefined by default.
   *    - `lowerExp: number`
   *      Exponent determining the lower boundary for formatting a value with
   *      an exponent when `notation='auto'`. Default value is `-3`.
   *    - `upperExp: number`
   *      Exponent determining the upper boundary for formatting a value with
   *      an exponent when `notation='auto'`. Default value is `5`.
   *    - `fraction: string`. Available values: `'ratio'` (default) or `'decimal'`.
   *      For example `format(fraction(1, 3))` will output `'1/3'` when `'ratio'`
   *      is configured, and will output `'0.(3)'` when `'decimal'` is configured.
   *    - `truncate: number`. Specifies the maximum allowed length of the
   *      returned string. If it had been longer, the excess characters
   *      are deleted and replaced with `'...'`.
   * - `callback: function`
   *   A custom formatting function, invoked for all numeric elements in `value`,
   *   for example all elements of a matrix, or the real and imaginary
   *   parts of a complex number. This callback can be used to override the
   *   built-in numeric notation with any type of formatting. Function `callback`
   *   is called with `value` as parameter and must return a string.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this function
   *   is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * Examples:
   *
   *    math.format(6.4)                                        // returns '6.4'
   *    math.format(1240000)                                    // returns '1.24e+6'
   *    math.format(1/3)                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3)                                     // returns '0.333'
   *    math.format(21385, 2)                                   // returns '21000'
   *    math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'
   *    math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'
   *    math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'
   *    math.format(12400, {notation: 'engineering'})           // returns '12.4e+3'
   *    math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'
   *
   *    function formatCurrency(value) {
   *      // return currency notation with two digits:
   *      return '$' + value.toFixed(2)
   *
   *      // you could also use math.format inside the callback:
   *      // return '$' + math.format(value, {notation: 'fixed', precision: 2})
   *    }
   *    math.format([2.1, 3, 0.016], formatCurrency)            // returns '[$2.10, $3.00, $0.02]'
   *
   * See also:
   *
   *    print
   *
   * @param {*} value                               Value to be stringified
   * @param {Object | Function | number} [options]  Formatting options
   * @return {string} The formatted value
   */ return typed(name, {
        any: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"],
        'any, Object | function | number | BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"]
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createGetMatrixDataType": (()=>createGetMatrixDataType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
var name = 'getMatrixDataType';
var dependencies = [
    'typed'
];
var createGetMatrixDataType = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Find the data type of all elements in a matrix or array,
   * for example 'number' if all items are a number and 'Complex' if all values
   * are complex numbers.
   * If a matrix contains more than one data type, it will return 'mixed'.
   *
   * Syntax:
   *
   *    math.getMatrixDataType(x)
   *
   * Examples:
   *
   *    const x = [ [1, 2, 3], [4, 5, 6] ]
   *    const mixedX = [ [1, true], [2, 3] ]
   *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3)] ]
   *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]
   *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]
   *    const sparse = math.sparse(x)
   *    const dense = math.matrix(x)
   *    math.getMatrixDataType(x)   // returns 'number'
   *    math.getMatrixDataType(sparse)   // returns 'number'
   *    math.getMatrixDataType(dense)   // returns 'number'
   *    math.getMatrixDataType(mixedX) // returns 'mixed'
   *    math.getMatrixDataType(fractionX) // returns 'Fraction'
   *    math.getMatrixDataType(unitX) // returns 'Unit'
   *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'
   *
   * See also:
   *  SparseMatrix, DenseMatrix
   *
   * @param {...Matrix | Array} x   The Matrix with values.
   *
   * @return {string} A string representation of the matrix type
   */ return typed(name, {
        Array: function Array(x) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getArrayDataType"])(x, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"]);
        },
        Matrix: function Matrix(x) {
            return x.getDataType();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/string/hex.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createHex": (()=>createHex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'hex';
var dependencies = [
    'typed',
    'format'
];
var createHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, format } = _ref;
    return typed(name, {
        'number | BigNumber': function number__BigNumber(n) {
            return format(n, {
                notation: 'hex'
            });
        },
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(n, wordSize) {
            return format(n, {
                notation: 'hex',
                wordSize
            });
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/complex/im.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIm": (()=>createIm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
;
;
var name = 'im';
var dependencies = [
    'typed'
];
var createIm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Get the imaginary part of a complex number.
   * For a complex number `a + bi`, the function returns `b`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.im(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 3)
   *    math.re(a)                     // returns number 2
   *    math.im(a)                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')) // returns number -5.2
   *    math.re(math.complex(2.4))     // returns number 0
   *
   * See also:
   *
   *    re, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The imaginary part of x
   */ return typed(name, {
        number: ()=>0,
        'BigNumber | Fraction': (x)=>x.mul(0),
        Complex: (x)=>x.im,
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isInteger.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsInteger": (()=>createIsInteger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'isInteger';
var dependencies = [
    'typed'
];
var createIsInteger = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Test whether a value is an integer number.
   * The function supports `number`, `BigNumber`, and `Fraction`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isInteger(x)
   *
   * Examples:
   *
   *    math.isInteger(2)                     // returns true
   *    math.isInteger(0)                     // returns true
   *    math.isInteger(0.5)                   // returns false
   *    math.isInteger(math.bignumber(500))   // returns true
   *    math.isInteger(math.fraction(4))      // returns true
   *    math.isInteger('3')                   // returns true
   *    math.isInteger([3, 0.5, -2])          // returns [true, false, true]
   *    math.isInteger(math.complex('2-4i'))  // throws TypeError
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isZero
   *
   * @param {number | BigNumber | bigint | Fraction | Array | Matrix} x   Value to be tested
   * @return {boolean}  Returns true when `x` contains a numeric, integer value.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"],
        // TODO: what to do with isInteger(add(0.1, 0.2))  ?
        BigNumber: function BigNumber(x) {
            return x.isInt();
        },
        bigint: function bigint(x) {
            return true;
        },
        Fraction: function Fraction(x) {
            return x.d === 1n;
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isNegative.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsNegative": (()=>createIsNegative)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'isNegative';
var dependencies = [
    'typed',
    'config'
];
var createIsNegative = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config } = _ref;
    /**
   * Test whether a value is negative: smaller than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNegative(x)
   *
   * Examples:
   *
   *    math.isNegative(3)                     // returns false
   *    math.isNegative(-2)                    // returns true
   *    math.isNegative(0)                     // returns false
   *    math.isNegative(-0)                    // returns false
   *    math.isNegative(math.bignumber(2))     // returns false
   *    math.isNegative(math.fraction(-2, 5))  // returns true
   *    math.isNegative('-2')                  // returns true
   *    math.isNegative([2, 0, -3])            // returns [false, false, true]
   *
   * See also:
   *
   *    isNumeric, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | bigint | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        number: (x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, 0, config.relTol, config.absTol) ? false : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNegativeNumber"])(x),
        BigNumber: (x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, new x.constructor(0), config.relTol, config.absTol) ? false : x.isNeg() && !x.isZero() && !x.isNaN(),
        bigint: (x)=>x < 0n,
        Fraction: (x)=>x.s < 0n,
        // It's enough to decide on the sign
        Unit: typed.referToSelf((self)=>(x)=>typed.find(self, x.valueType())(x.value)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isPositive.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsPositive": (()=>createIsPositive)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'isPositive';
var dependencies = [
    'typed',
    'config'
];
var createIsPositive = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config } = _ref;
    /**
   * Test whether a value is positive: larger than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPositive(x)
   *
   * Examples:
   *
   *    math.isPositive(3)                     // returns true
   *    math.isPositive(-2)                    // returns false
   *    math.isPositive(0)                     // returns false
   *    math.isPositive(-0)                    // returns false
   *    math.isPositive(0.5)                   // returns true
   *    math.isPositive(math.bignumber(2))     // returns true
   *    math.isPositive(math.fraction(-2, 5))  // returns false
   *    math.isPositive(math.fraction(1, 3))   // returns true
   *    math.isPositive('2')                   // returns true
   *    math.isPositive([2, 0, -3])            // returns [true, false, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | bigint | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        number: (x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, 0, config.relTol, config.absTol) ? false : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPositiveNumber"])(x),
        BigNumber: (x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, new x.constructor(0), config.relTol, config.absTol) ? false : !x.isNeg() && !x.isZero() && !x.isNaN(),
        bigint: (x)=>x > 0n,
        Fraction: (x)=>x.s > 0n && x.n > 0n,
        Unit: typed.referToSelf((self)=>(x)=>typed.find(self, x.valueType())(x.value)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isZero.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsZero": (()=>createIsZero)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'isZero';
var dependencies = [
    'typed',
    'equalScalar'
];
var createIsZero = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Test whether a value is zero.
   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
   * `Complex`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isZero(x)
   *
   * Examples:
   *
   *    math.isZero(0)                      // returns true
   *    math.isZero(2)                      // returns false
   *    math.isZero(0.5)                    // returns false
   *    math.isZero(math.bignumber(0))      // returns true
   *    math.isZero(math.fraction(0))       // returns true
   *    math.isZero(math.fraction(1,3))     // returns false
   *    math.isZero(math.complex('2 - 4i')) // returns false
   *    math.isZero(math.complex('0i'))     // returns true
   *    math.isZero('0')                    // returns true
   *    math.isZero('2')                    // returns false
   *    math.isZero([2, 0, -3])             // returns [false, true, false]
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isInteger
   *
   * @param {number | BigNumber | bigint | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
   * @return {boolean}  Returns true when `x` is zero.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        'number | BigNumber | Complex | Fraction': (x)=>equalScalar(x, 0),
        bigint: (x)=>x === 0n,
        Unit: typed.referToSelf((self)=>(x)=>typed.find(self, x.valueType())(x.value)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/lgamma.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable no-loss-of-precision */ // References
// ----------
// [1] Hare, "Computing the Principal Branch of log-Gamma", Journal of Algorithms, 1997.
// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments
__turbopack_context__.s({
    "createLgamma": (()=>createLgamma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/probability.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
;
var name = 'lgamma';
var dependencies = [
    'Complex',
    'typed'
];
var createLgamma = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { Complex, typed } = _ref;
    // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get
    // sufficient accuracy.
    //
    // These two values are copied from Scipy implementation:
    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37
    var SMALL_RE = 7;
    var SMALL_IM = 7;
    /**
   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].
   *
   * If you cannot access the paper, can also get these values from the formula in [2].
   *
   *    1 /     12 = 0.00833333333333333333333333333333
   *    1 /    360 = 0.00277777777777777777777777777778
   * ...
   * 3617 / 133400 = 0.02955065359477124183006535947712
   */ var coeffs = [
        -2.955065359477124183e-2,
        6.4102564102564102564e-3,
        -1.9175269175269175269e-3,
        8.4175084175084175084e-4,
        -5.952380952380952381e-4,
        7.9365079365079365079e-4,
        -2.7777777777777777778e-3,
        8.3333333333333333333e-2
    ];
    /**
   * Logarithm of the gamma function for real, positive numbers and complex numbers,
   * using Lanczos approximation for numbers and Stirling series for complex numbers.
   *
   * Syntax:
   *
   *    math.lgamma(n)
   *
   * Examples:
   *
   *    math.lgamma(5)       // returns 3.178053830347945
   *    math.lgamma(0)       // returns Infinity
   *    math.lgamma(-0.5)    // returns NaN
   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i
   *
   * See also:
   *
   *    gamma
   *
   * @param {number | Complex} n   A real or complex number
   * @return {number | Complex}    The log gamma of `n`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lgammaNumber"],
        Complex: lgammaComplex,
        BigNumber: function BigNumber() {
            throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
        }
    });
    "TURBOPACK unreachable";
    function lgammaComplex(n) {
        var TWOPI = 6.2831853071795864769252842; // 2*pi
        var LOGPI = 1.1447298858494001741434262; // log(pi)
        var REFLECTION = 0.1;
        if (n.isNaN()) {
            return new Complex(NaN, NaN);
        } else if (n.im === 0) {
            return new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lgammaNumber"])(n.re), 0);
        } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
            return lgammaStirling(n);
        } else if (n.re <= REFLECTION) {
            // Reflection formula. see Proposition 3.1 in [1]
            var tmp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copysign"])(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
            var a = n.mul(Math.PI).sin().log();
            var b = lgammaComplex(new Complex(1 - n.re, -n.im));
            return new Complex(LOGPI, tmp).sub(a).sub(b);
        } else if (n.im >= 0) {
            return lgammaRecurrence(n);
        } else {
            return lgammaRecurrence(n.conjugate()).conjugate();
        }
    }
    function lgammaStirling(z) {
        // formula ref in [2]
        // computation ref:
        // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101
        // left part
        // x (log(x) - 1) + 1/2 (log(2PI) - log(x))
        // => (x - 0.5) * log(x) - x + log(2PI) / 2
        var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lnSqrt2PI"]);
        // right part
        var rz = new Complex(1, 0).div(z);
        var rzz = rz.div(z);
        var a = coeffs[0];
        var b = coeffs[1];
        var r = 2 * rzz.re;
        var s = rzz.re * rzz.re + rzz.im * rzz.im;
        for(var i = 2; i < 8; i++){
            var tmp = b;
            b = -s * a + coeffs[i];
            a = r * a + tmp;
        }
        var rightPart = rz.mul(rzz.mul(a).add(b));
        // plus left and right
        return leftPart.add(rightPart);
    }
    function lgammaRecurrence(z) {
        // computation ref:
        // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78
        var signflips = 0;
        var sb = 0;
        var shiftprod = z;
        z = z.add(1);
        while(z.re <= SMALL_RE){
            shiftprod = shiftprod.mul(z);
            var nsb = shiftprod.im < 0 ? 1 : 0;
            if (nsb !== 0 && sb === 0) signflips++;
            sb = nsb;
            z = z.add(1);
        }
        return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log10.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog10": (()=>createLog10)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'log10';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var log16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log10Number"])(16);
var createLog10 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001)            // returns -5
   *    math.log10(10000)              // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *    math.pow(10, 4)                // returns 10000
   *
   * See also:
   *
   *    exp, log, log1p, log2
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */ function complexLog(c) {
        return c.log().div(Math.LN10);
    }
    function complexLogNumber(x) {
        return complexLog(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log10Number"])(x);
            } else {
                // negative value -> complex value computation
                return complexLogNumber(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["promoteLogarithm"])(log16, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log10Number"], config, complexLogNumber),
        Complex: complexLog,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.log();
            } else {
                // downgrade to number, return Complex valued result
                return complexLogNumber(x.toNumber());
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log2.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog2": (()=>createLog2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'log2';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createLog2 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log2(x)
   *
   * Examples:
   *
   *    math.log2(0.03125)           // returns -5
   *    math.log2(16)                // returns 4
   *    math.log2(16) / math.log2(2) // returns 4
   *    math.pow(2, 4)               // returns 16
   *
   * See also:
   *
   *    exp, log, log1p, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 2-base logarithm of `x`
   */ function complexLog2Number(x) {
        return _log2Complex(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log2Number"])(x);
            } else {
                // negative value -> complex value computation
                return complexLog2Number(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["promoteLogarithm"])(4, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log2Number"], config, complexLog2Number),
        Complex: _log2Complex,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.log(2);
            } else {
                // downgrade to number, return Complex valued result
                return complexLog2Number(x.toNumber());
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
    "TURBOPACK unreachable";
    /**
   * Calculate log2 for a complex value
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */ function _log2Complex(x) {
        var newX = Math.sqrt(x.re * x.re + x.im * x.im);
        return new Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/map.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMap": (()=>createMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'map';
var dependencies = [
    'typed'
];
var createMap = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Create a new matrix or array with the results of a callback function executed on
   * each entry of a given matrix/array.
   *
   * For each entry of the input,
   *
   * the callback is invoked with 2N + 1 arguments:
   * the N values of the entry, the index at which that entry occurs, and the N full
   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.
   * Note that because the matrix/array might be
   * multidimensional, the "index" argument is always an array of numbers giving
   * the index in each dimension. This is true even for vectors: the "index"
   * argument is an array of length 1, rather than simply a number.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *    math.map(x, y, ..., callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value
   *    })  // returns [1, 4, 9]
   *    math.map([1, 2], [3, 4], function(a, b) {
   *     return a + b
   *    })  // returns [4, 6]
   *
   *    // The callback is normally called with three arguments:
   *    //    callback(value, index, Array)
   *    // If you want to call with only one argument, use:
   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']
   *    // It can also be called with 2N + 1 arguments: for N arrays
   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The input to iterate on.
   * @param {Function} callback
   *     The function to call (as described above) on each entry of the input
   * @return {Matrix | array}
   *     Transformed map of x; always has the same type and shape as x
   */ return typed(name, {
        'Array, function': _mapArray,
        'Matrix, function': function Matrix_function(x, callback) {
            return x.map(callback);
        },
        'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest)=>_mapMultiple([
                A,
                B,
                ...rest.slice(0, rest.length - 1)
            ], rest[rest.length - 1])
    });
    "TURBOPACK unreachable";
    /**
  * Maps over multiple arrays or matrices.
  *
  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.
  * @param {function} multiCallback - The callback function to apply to each element.
  * @throws {Error} If the last argument is not a callback function.
  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.
  *
  * @example
  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]
  */ function _mapMultiple(Arrays, multiCallback) {
        if (typeof multiCallback !== 'function') {
            throw new Error('Last argument must be a callback function');
        }
        var firstArrayIsMatrix = Arrays[0].isMatrix;
        var newSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["broadcastSizes"])(...Arrays.map((M)=>M.isMatrix ? M.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(M)));
        var _get = firstArrayIsMatrix ? (matrix, idx)=>matrix.get(idx) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"];
        var broadcastedArrays = firstArrayIsMatrix ? Arrays.map((M)=>M.isMatrix ? M.create((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["broadcastTo"])(M.toArray(), newSize), M.datatype()) : Arrays[0].create((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["broadcastTo"])(M.valueOf(), newSize))) : Arrays.map((M)=>M.isMatrix ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["broadcastTo"])(M.toArray(), newSize) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["broadcastTo"])(M, newSize));
        var callback;
        if (typed.isTypedFunction(multiCallback)) {
            var firstIndex = newSize.map(()=>0);
            var firstValues = broadcastedArrays.map((array)=>_get(array, firstIndex));
            var callbackCase = _getTypedCallbackCase(multiCallback, firstValues, firstIndex, broadcastedArrays);
            callback = _getLimitedCallback(callbackCase);
        } else {
            var numberOfArrays = Arrays.length;
            var _callbackCase = _getCallbackCase(multiCallback, numberOfArrays);
            callback = _getLimitedCallback(_callbackCase);
        }
        var broadcastedArraysCallback = (x, idx)=>callback([
                x,
                ...broadcastedArrays.slice(1).map((Array)=>_get(Array, idx))
            ], idx);
        if (firstArrayIsMatrix) {
            return broadcastedArrays[0].map(broadcastedArraysCallback);
        } else {
            return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);
        }
        "TURBOPACK unreachable";
        function _getLimitedCallback(callbackCase) {
            switch(callbackCase){
                case 0:
                    return (x)=>multiCallback(...x);
                case 1:
                    return (x, idx)=>multiCallback(...x, idx);
                case 2:
                    return (x, idx)=>multiCallback(...x, idx, ...broadcastedArrays);
            }
        }
        function _getCallbackCase(callback, numberOfArrays) {
            if (callback.length > numberOfArrays + 1) {
                return 2;
            }
            if (callback.length === numberOfArrays + 1) {
                return 1;
            }
            return 0;
        }
        function _getTypedCallbackCase(callback, values, idx, arrays) {
            if (typed.resolve(callback, [
                ...values,
                idx,
                ...arrays
            ]) !== null) {
                return 2;
            }
            if (typed.resolve(callback, [
                ...values,
                idx
            ]) !== null) {
                return 1;
            }
            if (typed.resolve(callback, values) !== null) {
                return 0;
            }
            // this should never happen
            return 0;
        }
    }
    /**
  * Map for a multi dimensional array
  * @param {Array} array
  * @param {Function} callback
  * @return {Array}
  * @private
  */ function _mapArray(array, callback) {
        var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, array, name);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(array, fastCallback.fn, fastCallback.isUnary);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMultiplyScalar": (()=>createMultiplyScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'multiplyScalar';
var dependencies = [
    'typed'
];
var createMultiplyScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Multiplication of `x` and `y`
   * @private
   */ return typed('multiplyScalar', {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.mul(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.times(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x * y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.mul(y);
        },
        'number | Fraction | BigNumber | Complex, Unit': (x, y)=>y.multiply(x),
        'Unit, number | Fraction | BigNumber | Complex | Unit': (x, y)=>x.multiply(y)
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/logical/not.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNot": (()=>createNot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/logical.js [app-ssr] (ecmascript)");
;
;
;
var name = 'not';
var dependencies = [
    'typed'
];
var createNot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Logical `not`. Flips boolean value of a given parameter.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.not(x)
   *
   * Examples:
   *
   *    math.not(2)      // returns false
   *    math.not(0)      // returns true
   *    math.not(true)   // returns false
   *
   *    a = [2, -7, 0]
   *    math.not(a)      // returns [false, false, true]
   *
   * See also:
   *
   *    and, or, xor
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x First value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when input is a zero or empty value.
   */ return typed(name, {
        'null | undefined': ()=>true,
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["notNumber"],
        Complex: function Complex(x) {
            return x.re === 0 && x.im === 0;
        },
        BigNumber: function BigNumber(x) {
            return x.isZero() || x.isNaN();
        },
        bigint: (x)=>!x,
        Unit: typed.referToSelf((self)=>(x)=>typed.find(self, x.valueType())(x.value)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/string/oct.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createOct": (()=>createOct)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'oct';
var dependencies = [
    'typed',
    'format'
];
var createOct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, format } = _ref;
    return typed(name, {
        'number | BigNumber': function number__BigNumber(n) {
            return format(n, {
                notation: 'oct'
            });
        },
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(n, wordSize) {
            return format(n, {
                notation: 'oct',
                wordSize
            });
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRng": (()=>createRng)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$seedrandom$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/seedrandom/index.js [app-ssr] (ecmascript)");
;
var singletonRandom = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$seedrandom$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(Date.now());
function createRng(randomSeed) {
    var random;
    // create a new random generator with given seed
    function setSeed(seed) {
        random = seed === null ? singletonRandom : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$seedrandom$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(String(seed));
    }
    // initialize a seeded pseudo random number generator with config's random seed
    setSeed(randomSeed);
    // wrapper function so the rng can be updated via generator
    function rng() {
        return random();
    }
    return rng;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/pickRandom.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPickRandom": (()=>createPickRandom)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'pickRandom';
var dependencies = [
    'typed',
    'config',
    '?on'
];
var createPickRandom = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, on } = _ref;
    // seeded pseudo random number generator
    var rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(config.randomSeed);
    if (on) {
        on('config', function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
                rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(curr.randomSeed);
            }
        });
    }
    /**
   * Random pick one or more values from a one dimensional array.
   * Array elements are picked using a random function with uniform or weighted distribution.
   *
   * Syntax:
   *
   *     math.pickRandom(array)
   *     math.pickRandom(array, number)
   *     math.pickRandom(array, weights)
   *     math.pickRandom(array, number, weights)
   *     math.pickRandom(array, weights, number)
   *     math.pickRandom(array, { weights, number, elementWise })
   *
   * Examples:
   *
   *     math.pickRandom([3, 6, 12, 2])                  // returns one of the values in the array
   *     math.pickRandom([3, 6, 12, 2], 2)               // returns an array of two of the values in the array
   *     math.pickRandom([3, 6, 12, 2], { number: 2 })   // returns an array of two of the values in the array
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1])    // returns one of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], 2, [1, 3, 2, 1]) // returns an array of two of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1], 2) // returns an array of two of the values in the array with weighted distribution
   *
   *     math.pickRandom([{x: 1.0, y: 2.0}, {x: 1.1, y: 2.0}], { elementWise: false })
   *         // returns one of the items in the array
   *
   * See also:
   *
   *     random, randomInt
   *
   * @param {Array | Matrix} array     A one dimensional array
   * @param {Int} number               An int or float
   * @param {Array | Matrix} weights   An array of ints or floats
   * @return {number | Array}          Returns a single random value from array when number is undefined.
   *                                   Returns an array with the configured number of elements when number is defined.
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(possibles) {
            return _pickRandom(possibles, {});
        },
        'Array | Matrix, Object': function Array__Matrix_Object(possibles, options) {
            return _pickRandom(possibles, options);
        },
        'Array | Matrix, number': function Array__Matrix_number(possibles, number) {
            return _pickRandom(possibles, {
                number
            });
        },
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(possibles, weights) {
            return _pickRandom(possibles, {
                weights
            });
        },
        'Array | Matrix, Array | Matrix, number': function Array__Matrix_Array__Matrix_number(possibles, weights, number) {
            return _pickRandom(possibles, {
                number,
                weights
            });
        },
        'Array | Matrix, number, Array | Matrix': function Array__Matrix_number_Array__Matrix(possibles, number, weights) {
            return _pickRandom(possibles, {
                number,
                weights
            });
        }
    });
    "TURBOPACK unreachable";
    /**
   * @param {Array | Matrix} possibles
   * @param {{
   *   number?: number,
   *   weights?: Array | Matrix,
   *   elementWise: boolean
   * }} options
   * @returns {number | Array}
   * @private
   */ function _pickRandom(possibles, _ref2) {
        var { number, weights, elementWise = true } = _ref2;
        var single = typeof number === 'undefined';
        if (single) {
            number = 1;
        }
        var createMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(possibles) ? possibles.create : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(weights) ? weights.create : null;
        possibles = possibles.valueOf(); // get Array
        if (weights) {
            weights = weights.valueOf(); // get Array
        }
        if (elementWise === true) {
            possibles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(possibles);
            weights = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(weights);
        }
        var totalWeights = 0;
        if (typeof weights !== 'undefined') {
            if (weights.length !== possibles.length) {
                throw new Error('Weights must have the same length as possibles');
            }
            for(var i = 0, len = weights.length; i < len; i++){
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(weights[i]) || weights[i] < 0) {
                    throw new Error('Weights must be an array of positive numbers');
                }
                totalWeights += weights[i];
            }
        }
        var length = possibles.length;
        var result = [];
        var pick;
        while(result.length < number){
            if (typeof weights === 'undefined') {
                pick = possibles[Math.floor(rng() * length)];
            } else {
                var randKey = rng() * totalWeights;
                for(var _i = 0, _len = possibles.length; _i < _len; _i++){
                    randKey -= weights[_i];
                    if (randKey < 0) {
                        pick = possibles[_i];
                        break;
                    }
                }
            }
            result.push(pick);
        }
        return single ? result[0] : createMatrix ? createMatrix(result) : result;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/string/print.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPrint": (()=>createPrint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$print$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/print.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'print';
var dependencies = [
    'typed'
];
var createPrint = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Interpolate values into a string template.
   *
   * Syntax:
   *
   *     math.print(template, values)
   *     math.print(template, values, precision)
   *     math.print(template, values, options)
   *
   * Example usage:
   *
   *     // the following outputs: 'Lucy is 5 years old'
   *     math.print('Lucy is $age years old', {age: 5})
   *
   *     // the following outputs: 'The value of pi is 3.141592654'
   *     math.print('The value of pi is $pi', {pi: math.pi}, 10)
   *
   *     // the following outputs: 'Hello Mary! The date is 2013-03-23'
   *     math.print('Hello $user.name! The date is $date', {
   *       user: {
   *         name: 'Mary',
   *       },
   *       date: '2013-03-23'
   *     })
   *
   *     // the following outputs: 'My favorite fruits are apples and bananas !'
   *     math.print('My favorite fruits are $0 and $1 !', [
   *       'apples',
   *       'bananas'
   *     ])
   *
   * See also:
   *
   *     format
   *
   * @param {string} template           A string containing variable placeholders.
   * @param {Object | Array | Matrix}   values An object or array containing variables
   *                                    which will be filled in in the template.
   * @param {number | Object} [options] Formatting options,
   *                                    or the number of digits to format numbers.
   *                                    See function math.format for a description
   *                                    of all options.
   * @return {string} Interpolated string
   */ return typed(name, {
        // note: Matrix will be converted automatically to an Array
        'string, Object | Array': _print,
        'string, Object | Array, number | Object': _print
    });
});
/**
 * Interpolate values into a string template.
 * @param {string} template
 * @param {Object} values
 * @param {number | Object} [options]
 * @returns {string} Interpolated string
 * @private
 */ function _print(template, values, options) {
    return template.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$print$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["printTemplate"], function(original, key) {
        var keys = key.split('.');
        var value = values[keys.shift()];
        if (value !== undefined && value.isMatrix) {
            value = value.toArray();
        }
        while(keys.length && value !== undefined){
            var k = keys.shift();
            value = k ? value[k] : value + '.';
        }
        if (value !== undefined) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(value)) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(value, options);
            } else {
                return value;
            }
        }
        return original;
    });
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * This is a util function for generating a random matrix recursively.
 * @param {number[]} size
 * @param {function} random
 * @returns {Array}
 */ __turbopack_context__.s({
    "randomMatrix": (()=>randomMatrix)
});
function randomMatrix(size, random) {
    var data = [];
    size = size.slice(0);
    if (size.length > 1) {
        for(var i = 0, length = size.shift(); i < length; i++){
            data.push(randomMatrix(size, random));
        }
    } else {
        for(var _i = 0, _length = size.shift(); _i < _length; _i++){
            data.push(random());
        }
    }
    return data;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/random.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRandom": (()=>createRandom),
    "createRandomNumber": (()=>createRandomNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$randomMatrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'random';
var dependencies = [
    'typed',
    'config',
    '?on'
];
var createRandom = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, on } = _ref;
    // seeded pseudo random number generator
    var rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(config.randomSeed);
    if (on) {
        on('config', function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
                rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(curr.randomSeed);
            }
        });
    }
    /**
   * Return a random number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.random()                // generate a random number between 0 and 1
   *     math.random(max)             // generate a random number between 0 and max
   *     math.random(min, max)        // generate a random number between min and max
   *     math.random(size)            // generate a matrix with random numbers between 0 and 1
   *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
   *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
   *
   * Examples:
   *
   *     math.random()       // returns a random number between 0 and 1
   *     math.random(100)    // returns a random number between 0 and 100
   *     math.random(30, 40) // returns a random number between 30 and 40
   *     math.random([2, 3]) // returns a 2x3 matrix with random numbers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random number
   */ return typed(name, {
        '': ()=>_random(0, 1),
        number: (max)=>_random(0, max),
        'number, number': (min, max)=>_random(min, max),
        'Array | Matrix': (size)=>_randomMatrix(size, 0, 1),
        'Array | Matrix, number': (size, max)=>_randomMatrix(size, 0, max),
        'Array | Matrix, number, number': (size, min, max)=>_randomMatrix(size, min, max)
    });
    "TURBOPACK unreachable";
    function _randomMatrix(size, min, max) {
        var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$randomMatrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomMatrix"])(size.valueOf(), ()=>_random(min, max));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(size) ? size.create(res, 'number') : res;
    }
    function _random(min, max) {
        return min + rng() * (max - min);
    }
});
var createRandomNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config',
    '?on'
], (_ref2)=>{
    var { typed, config, on, matrix } = _ref2;
    // seeded pseudo random number generator1
    var rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(config.randomSeed);
    if (on) {
        on('config', function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
                rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(curr.randomSeed);
            }
        });
    }
    return typed(name, {
        '': ()=>_random(0, 1),
        number: (max)=>_random(0, max),
        'number, number': (min, max)=>_random(min, max)
    });
    "TURBOPACK unreachable";
    function _random(min, max) {
        return min + rng() * (max - min);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/complex/re.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRe": (()=>createRe)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
;
;
var name = 're';
var dependencies = [
    'typed'
];
var createRe = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Get the real part of a complex number.
   * For a complex number `a + bi`, the function returns `a`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.re(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 3)
   *    math.re(a)                     // returns number 2
   *    math.im(a)                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')) // returns number 0
   *    math.re(math.complex(2.4))     // returns number 2.4
   *
   * See also:
   *
   *    im, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The real part of x
   */ return typed(name, {
        'number | BigNumber | Fraction': (x)=>x,
        Complex: (x)=>x.re,
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/sec.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSec": (()=>createSec)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
;
var name = 'sec';
var dependencies = [
    'typed',
    'BigNumber'
];
var createSec = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * To avoid confusion with the matrix secant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2)      // returns number -2.4029979617223822
   *    1 / math.cos(2)  // returns number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Secant of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secNumber"],
        Complex: (x)=>x.sec(),
        BigNumber: (x)=>new _BigNumber(1).div(x.cos())
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/sign.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSign": (()=>createSign)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
var name = 'sign';
var dependencies = [
    'typed',
    'BigNumber',
    'Fraction',
    'complex'
];
var createSign = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber, complex, Fraction: _Fraction } = _ref;
    /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 0
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5)               // returns 1
   *    math.sign(-4.2)              // returns -1
   *    math.sign(0)                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}
   *            The sign of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signNumber"],
        Complex: function Complex(x) {
            return x.im === 0 ? complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signNumber"])(x.re)) : x.sign();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(x.cmp(0));
        },
        bigint: function bigint(x) {
            return x > 0n ? 1n : x < 0n ? -1n : 0n;
        },
        Fraction: function Fraction(x) {
            return x.n === 0n ? new _Fraction(0) : new _Fraction(x.s);
        },
        // deep map collection, skip zeros since sign(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true)),
        Unit: typed.referToSelf((self)=>(x)=>{
                if (!x._isDerived() && x.units[0].unit.offset !== 0) {
                    throw new TypeError('sign is ambiguous for units with offset');
                }
                return typed.find(self, x.valueType())(x.value);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/sin.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSin": (()=>createSin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
var name = 'sin';
var dependencies = [
    'typed'
];
var createSin = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the sine of a value.
   *
   * To avoid confusion with the matrix sine, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2)                      // returns number 0.9092974268256813
   *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'))   // returns number 1
   *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
   *
   *    const angle = 0.2
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number 1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Sine of x
   */ return typed(name, {
        number: Math.sin,
        'Complex | BigNumber': (x)=>x.sin()
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/square.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSquare": (()=>createSquare)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'square';
var dependencies = [
    'typed'
];
var createSquare = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the square of a value, `x * x`.
   * To avoid confusion with multiplying a square matrix by itself,
   * this function does not apply to matrices. If you wish to square
   * every element of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2)           // returns number 4
   *    math.square(3)           // returns number 9
   *    math.pow(3, 2)           // returns number 9
   *    math.multiply(3, 3)      // returns number 9
   *
   *    math.map([1, 2, 3, 4], math.square)  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}
   *            Squared value
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squareNumber"],
        Complex: function Complex(x) {
            return x.mul(x);
        },
        BigNumber: function BigNumber(x) {
            return x.times(x);
        },
        bigint: function bigint(x) {
            return x * x;
        },
        Fraction: function Fraction(x) {
            return x.mul(x);
        },
        Unit: function Unit(x) {
            return x.pow(2);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSubtractScalar": (()=>createSubtractScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'subtractScalar';
var dependencies = [
    'typed'
];
var createSubtractScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Subtract two scalar values, `x - y`.
   * This function is meant for internal use: it is used by the public function
   * `subtract`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to be subtracted from `x`
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Difference of `x` and `y`
   * @private
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["subtractNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.sub(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.minus(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x - y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.sub(y);
        },
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>{
                if (x.value === null || x.value === undefined) {
                    throw new Error('Parameter x contains a unit with undefined value');
                }
                if (y.value === null || y.value === undefined) {
                    throw new Error('Parameter y contains a unit with undefined value');
                }
                if (!x.equalBase(y)) throw new Error('Units do not match');
                var res = x.clone();
                res.value = typed.find(self, [
                    res.valueType(),
                    y.valueType()
                ])(res.value, y.value);
                res.fixPrefix = false;
                return res;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/tan.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTan": (()=>createTan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js [app-ssr] (ecmascript)");
;
;
var name = 'tan';
var dependencies = [
    'typed'
];
var createTan = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    var trigUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$trigonometry$2f$trigUnit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createTrigUnit"])({
        typed
    });
    /**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * To avoid confusion with the matrix tangent, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5)                    // returns number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5)    // returns number 0.5463024898437905
   *    math.tan(math.pi / 4)            // returns number 1
   *    math.tan(math.unit(45, 'deg'))   // returns number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Tangent of x
   */ return typed(name, {
        number: Math.tan,
        'Complex | BigNumber': (x)=>x.tan()
    }, trigUnit);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/unit/toBest.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createToBest": (()=>createToBest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'toBest';
var dependencies = [
    'typed'
];
var createToBest = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Converts a unit to the most appropriate display unit.
   * When no preferred units are provided, the function automatically find the best prefix.
   * When preferred units are provided, it converts to
   * the unit that gives a value closest to 1.
   *
   * Syntax:
   *
   *    math.toBest(unit)
   *    math.toBest(unit, unitList)
   *    math.toBest(unit, unitList, options)
   *
   * Where:
   * - `unitList` is an optional array of preferred target units as string or Unit.
   * - `options` is an optional object with options, formed as follows:
   * - `offset`: number | BigNumber
   *
   * Examples:
   *
   *   math.unit(0.05, 'm').toBest(['cm', 'mm'])                 // returns Unit 5 cm
   *   math.unit(2 / 3, 'cm').toBest()                           // returns Unit 0.6666666666666666 cm
   *   math.unit(10, 'm').toBest(['mm', 'km'], { offset: 1.5 })  // returns Unit 10000 mm
   *
   * See also:
   *
   *    unit, to, format
   *
   * @param {Unit} x                          The unit to be converted
   * @param {Array<string>} [unitList=[]]     Optional array of preferred target units
   * @param {Object} [options]                Optional options object
   * @return {Unit}                           Value converted to the best matching unit
   */ return typed(name, {
        Unit: (x)=>x.toBest(),
        'Unit, string': (x, unitList)=>x.toBest(unitList.split(',')),
        'Unit, string, Object': (x, unitList, options)=>x.toBest(unitList.split(','), options),
        'Unit, Array': (x, unitList)=>x.toBest(unitList),
        'Unit, Array, Object': (x, unitList, options)=>x.toBest(unitList, options)
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/typeOf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTypeOf": (()=>createTypeOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
var name = 'typeOf';
var dependencies = [
    'typed'
];
var createTypeOf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Determine the type of an entity.
   *
   * Syntax:
   *
   *    math.typeOf(x)
   *
   * Examples:
   *
   *    // This list is intended to include all relevant types, for testing
   *    // purposes:
   *    math.typeOf(3.5)                      // returns 'number'
   *    math.typeOf(42n)                      // returns 'bigint'
   *    math.typeOf(math.complex('2-4i'))     // returns 'Complex'
   *    math.typeOf(math.unit('45 deg'))      // returns 'Unit'
   *    math.typeOf('hello world')            // returns 'string'
   *    math.typeOf(null)                     // returns 'null'
   *    math.typeOf(true)                     // returns 'boolean'
   *    math.typeOf([1, 2, 3])                // returns 'Array'
   *    math.typeOf(new Date())               // returns 'Date'
   *    math.typeOf(function () {})           // returns 'function'
   *    math.typeOf({a: 2, b: 3})             // returns 'Object'
   *    math.typeOf(/a regexp/)               // returns 'RegExp'
   *    math.typeOf(undefined)                // returns 'undefined'
   *    math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'
   *    math.typeOf(math.chain(2))            // returns 'Chain'
   *    math.typeOf(math.fraction(1, 3))      // returns 'Fraction'
   *    math.typeOf(math.help('sqrt'))        // returns 'Help'
   *    math.typeOf(math.index(1, 3))         // returns 'Index'
   *    math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'
   *    math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'
   *    math.typeOf(new math.Range(0, 10))    // returns 'Range'
   *    math.typeOf(math.evaluate('a=2\na'))  // returns 'ResultSet'
   *    math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'
   *    math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'
   *    math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'
   *    math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'
   *    math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'
   *    math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'
   *    math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'
   *    math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'
   *    math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'
   *    math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'
   *    math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'
   *    math.typeOf(math.parse('1:10'))       // returns 'RangeNode'
   *    math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'
   *    math.typeOf(math.parse('x'))          // returns 'SymbolNode'
   *
   * @param {*} x     The variable for which to test the type.
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */ return typed(name, {
        any: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"]
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acosh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcosh": (()=>createAcosh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'acosh';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createAcosh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the hyperbolic arccos of a value,
   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acosh(x)
   *
   * Examples:
   *
   *    math.acosh(1.5)       // returns 0.9624236501192069
   *
   * See also:
   *
   *    cosh, asinh, atanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccosine of x
   */ return typed(name, {
        number: function number(x) {
            if (x >= 1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["acoshNumber"])(x);
            }
            if (x <= -1) {
                return new Complex(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
            }
            return new Complex(x, 0).acosh();
        },
        Complex: function Complex(x) {
            return x.acosh();
        },
        BigNumber: function BigNumber(x) {
            return x.acosh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acsch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcsch": (()=>createAcsch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'acsch';
var dependencies = [
    'typed',
    'BigNumber'
];
var createAcsch = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the inverse hyperbolic cosecant of a value,
   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
   *
   * To avoid confusion with the matrix inverse hyperbolic cosecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.acsch(x)
   *
   * Examples:
   *
   *    math.acsch(0.5)       // returns 1.4436354751788103
   *
   * See also:
   *
   *    asech, acoth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccosecant of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["acschNumber"],
        Complex: function Complex(x) {
            return x.acsch();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).asinh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/asec.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAsec": (()=>createAsec)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'asec';
var dependencies = [
    'typed',
    'config',
    'Complex',
    'BigNumber'
];
var createAsec = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
   *
   * To avoid confusion with the matrix arcsecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.asec(x)
   *
   * Examples:
   *
   *    math.asec(2)             // returns 1.0471975511965979
   *    math.asec(math.sec(1.5)) // returns 1.5
   *
   *    math.asec(0.5)           // returns Complex 0 + 1.3169578969248166i
   *
   * See also:
   *
   *    acos, acot, acsc
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} The arc secant of x
   */ return typed(name, {
        number: function number(x) {
            if (x <= -1 || x >= 1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asecNumber"])(x);
            }
            return new Complex(x, 0).asec();
        },
        Complex: function Complex(x) {
            return x.asec();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).acos();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCombinationsWithRep": (()=>createCombinationsWithRep)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/product.js [app-ssr] (ecmascript)");
;
;
;
var name = 'combinationsWithRep';
var dependencies = [
    'typed'
];
var createCombinationsWithRep = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities, allowing individual outcomes to be repeated more than once.
   *
   * CombinationsWithRep only takes integer arguments.
   * The following condition must be enforced: k <= n + k -1.
   *
   * Syntax:
   *
   *     math.combinationsWithRep(n, k)
   *
   * Examples:
   *
   *    math.combinationsWithRep(7, 5) // returns 462
   *
   * See also:
   *
   *    combinations, permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations with replacement.
   */ return typed(name, {
        'number, number': function number_number(n, k) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(n) || n < 0) {
                throw new TypeError('Positive integer value expected in function combinationsWithRep');
            }
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(k) || k < 0) {
                throw new TypeError('Positive integer value expected in function combinationsWithRep');
            }
            if (n < 1) {
                throw new TypeError('k must be less than or equal to n + k - 1');
            }
            if (k < n - 1) {
                var _prodrange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["product"])(n, n + k - 1);
                return _prodrange / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["product"])(1, k);
            }
            var prodrange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["product"])(k + 1, n + k - 1);
            return prodrange / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["product"])(1, n - 1);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(n, k) {
            var BigNumber = n.constructor;
            var result, i;
            var one = new BigNumber(1);
            var nMinusOne = n.minus(one);
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
                throw new TypeError('Positive integer value expected in function combinationsWithRep');
            }
            if (n.lt(one)) {
                throw new TypeError('k must be less than or equal to n + k - 1 in function combinationsWithRep');
            }
            result = one;
            if (k.lt(nMinusOne)) {
                for(i = one; i.lte(nMinusOne); i = i.plus(one)){
                    result = result.times(k.plus(i)).dividedBy(i);
                }
            } else {
                for(i = one; i.lte(k); i = i.plus(one)){
                    result = result.times(nMinusOne.plus(i)).dividedBy(i);
                }
            }
            return result;
        }
    });
});
/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */ function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/cosh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCosh": (()=>createCosh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
var name = 'cosh';
var dependencies = [
    'typed'
];
var createCosh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * To avoid confusion with the matrix hyperbolic cosine, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5)       // returns number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cosine of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cosh"],
        'Complex | BigNumber': (x)=>x.cosh()
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/csch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCsch": (()=>createCsch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'csch';
var dependencies = [
    'typed',
    'BigNumber'
];
var createCsch = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic cosecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5)       // returns 1.9190347513349437
   *    1 / math.sinh(0.5)   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cosecant of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cschNumber"],
        Complex: (x)=>x.csch(),
        BigNumber: (x)=>new _BigNumber(1).div(x.sinh())
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isNaN.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsNaN": (()=>createIsNaN)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/utils.js [app-ssr] (ecmascript)");
;
;
;
var name = 'isNaN';
var dependencies = [
    'typed'
];
var createIsNaN = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Test whether a value is NaN (not a number).
   * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNaN(x)
   *
   * Examples:
   *
   *    math.isNaN(3)                     // returns false
   *    math.isNaN(NaN)                   // returns true
   *    math.isNaN(0)                     // returns false
   *    math.isNaN(math.bignumber(NaN))   // returns true
   *    math.isNaN(math.bignumber(0))     // returns false
   *    math.isNaN(math.fraction(-2, 5))  // returns false
   *    math.isNaN('-2')                  // returns false
   *    math.isNaN([2, 0, -3, NaN])       // returns [false, false, false, true]
   *
   * See also:
   *
   *    isNumeric, isNegative, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | bigint | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is NaN.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNaNNumber"],
        BigNumber: function BigNumber(x) {
            return x.isNaN();
        },
        bigint: function bigint(x) {
            return false;
        },
        Fraction: function Fraction(x) {
            return false;
        },
        Complex: function Complex(x) {
            return x.isNaN();
        },
        Unit: function Unit(x) {
            return Number.isNaN(x.value);
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isPrime.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsPrime": (()=>createIsPrime)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'isPrime';
var dependencies = [
    'typed'
];
var createIsPrime = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Test whether a value is prime: has no divisors other than itself and one.
   * The function supports type `number`, `bignumber`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPrime(x)
   *
   * Examples:
   *
   *    math.isPrime(3)                     // returns true
   *    math.isPrime(-2)                    // returns false
   *    math.isPrime(0)                     // returns false
   *    math.isPrime(-0)                    // returns false
   *    math.isPrime(0.5)                   // returns false
   *    math.isPrime('2')                   // returns true
   *    math.isPrime([2, 17, 100])           // returns [true, true, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | bigint | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */ return typed(name, {
        number: function number(x) {
            if (x <= 3) {
                return x > 1;
            }
            if (x % 2 === 0 || x % 3 === 0) {
                return false;
            }
            for(var i = 5; i * i <= x; i += 6){
                if (x % i === 0 || x % (i + 2) === 0) {
                    return false;
                }
            }
            return true;
        },
        bigint: function bigint(x) {
            if (x <= 3n) {
                return x > 1n;
            }
            if (x % 2n === 0n || x % 3n === 0n) {
                return false;
            }
            for(var i = 5n; i * i <= x; i += 6n){
                if (x % i === 0n || x % (i + 2n) === 0n) {
                    return false;
                }
            }
            return true;
        },
        BigNumber: function BigNumber(n) {
            if (n.lte(3)) return n.gt(1);
            if (n.mod(2).eq(0) || n.mod(3).eq(0)) return false;
            if (n.lt(Math.pow(2, 32))) {
                var x = n.toNumber();
                for(var i = 5; i * i <= x; i += 6){
                    if (x % i === 0 || x % (i + 2) === 0) {
                        return false;
                    }
                }
                return true;
            }
            function modPow(base, exponent, modulus) {
                // exponent can be huge, use non-recursive variant
                var accumulator = 1;
                while(!exponent.eq(0)){
                    if (exponent.mod(2).eq(0)) {
                        exponent = exponent.div(2);
                        base = base.mul(base).mod(modulus);
                    } else {
                        exponent = exponent.sub(1);
                        accumulator = base.mul(accumulator).mod(modulus);
                    }
                }
                return accumulator;
            }
            // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants
            var Decimal = n.constructor.clone({
                precision: n.toFixed(0).length * 2
            });
            n = new Decimal(n);
            var r = 0;
            var d = n.sub(1);
            while(d.mod(2).eq(0)){
                d = d.div(2);
                r += 1;
            }
            var bases = null;
            // https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases
            if (n.lt('3317044064679887385961981')) {
                bases = [
                    2,
                    3,
                    5,
                    7,
                    11,
                    13,
                    17,
                    19,
                    23,
                    29,
                    31,
                    37,
                    41
                ].filter((x)=>x < n);
            } else {
                var max = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
                bases = [];
                for(var _i = 2; _i <= max; _i += 1){
                    bases.push(max);
                }
            }
            for(var _i2 = 0; _i2 < bases.length; _i2 += 1){
                var a = bases[_i2];
                var adn = modPow(n.sub(n).add(a), d, n);
                if (!adn.eq(1)) {
                    for(var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)){
                        if (_i3 === r - 1) {
                            return false;
                        }
                    }
                }
            }
            return true;
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/mapSlices.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMapSlices": (()=>createMapSlices)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/IndexError.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'mapSlices';
var dependencies = [
    'typed',
    'isInteger'
];
var createMapSlices = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isInteger } = _ref;
    /**
   * Apply a function that maps an array to a scalar
   * along a given axis of a matrix or array.
   * Returns a new matrix or array with one less dimension than the input.
   *
   * Syntax:
   *
   *     math.mapSlices(A, dim, callback)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *
   * Examples:
   *
   *    const A = [[1, 2], [3, 4]]
   *    const sum = math.sum
   *
   *    math.mapSlices(A, 0, sum)             // returns [4, 6]
   *    math.mapSlices(A, 1, sum)             // returns [3, 7]
   *
   * See also:
   *
   *    map, filter, forEach
   *
   * Note:
   *
   *    `mapSlices()` is also currently available via its deprecated
   *    synonym `apply()`.
   *
   * @param {Array | Matrix} array   The input Matrix
   * @param {number} dim             The dimension along which the callback is applied
   * @param {Function} callback      The callback function that is applied. This Function
   *                                 should take an array or 1-d matrix as an input and
   *                                 return a number.
   * @return {Array | Matrix} res    The residual matrix with the function mapped on the slices over some dimension.
   */ return typed(name, {
        'Array | Matrix, number | BigNumber, function': function Array__Matrix_number__BigNumber_function(mat, dim, callback) {
            if (!isInteger(dim)) {
                throw new TypeError('Integer number expected for dimension');
            }
            var size = Array.isArray(mat) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(mat) : mat.size();
            if (dim < 0 || dim >= size.length) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IndexError"](dim, size.length);
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(mat)) {
                return mat.create(_mapSlices(mat.valueOf(), dim, callback), mat.datatype());
            } else {
                return _mapSlices(mat, dim, callback);
            }
        }
    });
}, {
    formerly: 'apply'
});
/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */ function _mapSlices(mat, dim, callback) {
    var i, ret, tran;
    if (dim <= 0) {
        if (!Array.isArray(mat[0])) {
            return callback(mat);
        } else {
            tran = _switch(mat);
            ret = [];
            for(i = 0; i < tran.length; i++){
                ret[i] = _mapSlices(tran[i], dim - 1, callback);
            }
            return ret;
        }
    } else {
        ret = [];
        for(i = 0; i < mat.length; i++){
            ret[i] = _mapSlices(mat[i], dim - 1, callback);
        }
        return ret;
    }
}
/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */ function _switch(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for(j = 0; j < J; j++){
        var tmp = [];
        for(i = 0; i < I; i++){
            tmp.push(mat[i][j]);
        }
        ret.push(tmp);
    }
    return ret;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrixFromFunction": (()=>createMatrixFromFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'matrixFromFunction';
var dependencies = [
    'typed',
    'matrix',
    'isZero'
];
var createMatrixFromFunction = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, isZero } = _ref;
    /**
   * Create a matrix by evaluating a generating function at each index.
   * The simplest overload returns a multi-dimensional array as long as `size`
   * is an array.
   * Passing `size` as a Matrix or specifying a `format` will result in
   * returning a Matrix.
   *
   * Syntax:
   *
   *    math.matrixFromFunction(size, fn)
   *    math.matrixFromFunction(size, fn, format)
   *    math.matrixFromFunction(size, fn, format, datatype)
   *    math.matrixFromFunction(size, format, fn)
   *    math.matrixFromFunction(size, format, datatype, fn)
   *
   * Where:
   *
   *    - `size: (number[] | Matrix)`
   *      A vector giving the extent of the array to be created in each
   *      dimension. If size has one entry, a vector is created; if it
   *      has two, a rectangular array/Matrix is created; if three, a
   *      three-dimensional array/Matrix is created; and so on.
   *    - `fn: (index: number[]) => MathType`
   *      The callback function that will generate the entries of the
   *      matrix. It is called in turn with the index of each entry of
   *      the matrix. The index is always an ordinary array of numbers
   *      with the same length as _size_. So for vectors, you will get
   *      indices like `[0]` or `[1]`, whereas for matrices, you will
   *      get indices like `[2, 0]` or `[1,3]`. The return value may
   *      be any type that can go in an array or Matrix entry, although
   *      if you supply the _datatype_ argument, you must yourself ensure
   *      the type of the return value matches. Note that currently,
   *      your callback _fn_ will receive 0-based indices for the matrix
   *      entries, regardless of whether matrixFromFunction is invoked
   *      directly from JavaScript or via the mathjs expression language.
   *    - `format: 'dense'|'sparse'`
   *      Specifies the storage format for the resulting Matrix. Note that
   *      if this argument is given, the return value will always be a
   *      Matrix (rather than possibly an Array).
   *    - `datatype: string`
   *      Specifies the data type of entries of the new matrix. If given,
   *      it should be the name of a data type that mathjs supports, as
   *      returned by the math.typeOf function. It is up to the caller
   *      to make certain that all values returned by _fn_ are consistent
   *      with this datatype if specified.
   *
   * Examples:
   *
   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix
   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix
   *    math.matrixFromFunction([5], i => math.random()) // a random vector
   *
   * See also:
   *
   *    matrix, typeOf, zeros
   *
   * @param {Array | Matrix} size   The size of the matrix to be created
   * @param {function} fn           Callback function invoked for every entry in the matrix
   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`
   * @param {string} [datatype]     Type of the values
   * @return {Array | Matrix} Returns the created matrix
   */ return typed(name, {
        'Array | Matrix, function, string, string': function Array__Matrix_function_string_string(size, fn, format, datatype) {
            return _create(size, fn, format, datatype);
        },
        'Array | Matrix, function, string': function Array__Matrix_function_string(size, fn, format) {
            return _create(size, fn, format);
        },
        'Matrix, function': function Matrix_function(size, fn) {
            return _create(size, fn, 'dense');
        },
        'Array, function': function Array_function(size, fn) {
            return _create(size, fn, 'dense').toArray();
        },
        'Array | Matrix, string, function': function Array__Matrix_string_function(size, format, fn) {
            return _create(size, fn, format);
        },
        'Array | Matrix, string, string, function': function Array__Matrix_string_string_function(size, format, datatype, fn) {
            return _create(size, fn, format, datatype);
        }
    });
    "TURBOPACK unreachable";
    function _create(size, fn, format, datatype) {
        var m;
        if (datatype !== undefined) {
            m = matrix(format, datatype);
        } else {
            m = matrix(format);
        }
        m.resize(size);
        m.forEach(function(_, index) {
            var val = fn(index);
            if (isZero(val)) return;
            m.set(index, val);
        });
        return m;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/ones.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createOnes": (()=>createOnes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'ones';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'BigNumber'
];
var createOnes = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, BigNumber } = _ref;
    /**
   * Create a matrix filled with ones. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.ones(m)
   *    math.ones(m, format)
   *    math.ones(m, n)
   *    math.ones(m, n, format)
   *    math.ones([m, n])
   *    math.ones([m, n], format)
   *    math.ones([m, n, p, ...])
   *    math.ones([m, n, p, ...], format)
   *
   * Examples:
   *
   *    math.ones()                    // returns []
   *    math.ones(3)                   // returns [1, 1, 1]
   *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
   *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.ones(math.size(A))       // returns [[1, 1, 1], [1, 1, 1]]
   *
   * See also:
   *
   *    zeros, identity, size, range
   *
   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix | number}  A matrix filled with ones
   */ return typed('ones', {
        '': function _() {
            return config.matrix === 'Array' ? _ones([]) : _ones([], 'default');
        },
        // math.ones(m, n, p, ..., format)
        // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
        '...number | BigNumber | string': function number__BigNumber__string(size) {
            var last = size[size.length - 1];
            if (typeof last === 'string') {
                var format = size.pop();
                return _ones(size, format);
            } else if (config.matrix === 'Array') {
                return _ones(size);
            } else {
                return _ones(size, 'default');
            }
        },
        Array: _ones,
        Matrix: function Matrix(size) {
            var format = size.storage();
            return _ones(size.valueOf(), format);
        },
        'Array | Matrix, string': function Array__Matrix_string(size, format) {
            return _ones(size.valueOf(), format);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Create an Array or Matrix with ones
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */ function _ones(size, format) {
        var hasBigNumbers = _normalize(size);
        var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
        _validate(size);
        if (format) {
            // return a matrix
            var m = matrix(format);
            if (size.length > 0) {
                return m.resize(size, defaultValue);
            }
            return m;
        } else {
            // return an Array
            var arr = [];
            if (size.length > 0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resize"])(arr, size, defaultValue);
            }
            return arr;
        }
    }
    // replace BigNumbers with numbers, returns true if size contained BigNumbers
    function _normalize(size) {
        var hasBigNumbers = false;
        size.forEach(function(value, index, arr) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
                hasBigNumbers = true;
                arr[index] = value.toNumber();
            }
        });
        return hasBigNumbers;
    }
    // validate arguments
    function _validate(size) {
        size.forEach(function(value) {
            if (typeof value !== 'number' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(value) || value < 0) {
                throw new Error('Parameters in function ones must be positive integers');
            }
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/randomInt.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRandomInt": (()=>createRandomInt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$randomMatrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'randomInt';
var dependencies = [
    'typed',
    'config',
    'log2',
    '?on'
];
var createRandomInt = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, log2, on } = _ref;
    // seeded pseudo random number generator
    var rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(config.randomSeed);
    if (on) {
        on('config', function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
                rng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$seededRNG$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRng"])(curr.randomSeed);
            }
        });
    }
    /**
   * Return a random integer number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.randomInt()                // generate either 0 or 1, randomly
   *     math.randomInt(max)             // generate a random integer between 0 and max
   *     math.randomInt(min, max)        // generate a random integer between min and max
   *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
   *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
   *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
   *
   * Examples:
   *
   *     math.randomInt(100)    // returns a random integer between 0 and 100
   *     math.randomInt(30, 40) // returns a random integer between 30 and 40
   *     math.randomInt([2, 3]) // returns a 2x3 matrix with random integers between 0 and 1
   *
   * See also:
   *
   *     random, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random integer value
   */ return typed(name, {
        '': ()=>_randomInt(0, 2),
        number: (max)=>_randomInt(0, max),
        'number, number': (min, max)=>_randomInt(min, max),
        bigint: (max)=>_randomBigint(0n, max),
        'bigint, bigint': _randomBigint,
        'Array | Matrix': (size)=>_randomIntMatrix(size, 0, 1),
        'Array | Matrix, number': (size, max)=>_randomIntMatrix(size, 0, max),
        'Array | Matrix, number, number': (size, min, max)=>_randomIntMatrix(size, min, max)
    });
    "TURBOPACK unreachable";
    function _randomIntMatrix(size, min, max) {
        var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$probability$2f$util$2f$randomMatrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomMatrix"])(size.valueOf(), ()=>_randomInt(min, max));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(size) ? size.create(res, 'number') : res;
    }
    function _randomInt(min, max) {
        return Math.floor(min + rng() * (max - min));
    }
    function _randomBigint(min, max) {
        var simpleCutoff = 2n ** 30n;
        var width = max - min; // number of choices
        if (width <= simpleCutoff) {
            // do it with number type
            return min + BigInt(_randomInt(0, Number(width)));
        }
        // Too big to choose accurately that way. Instead, choose the correct
        // number of random bits to cover the width, and repeat until the
        // resulting number falls within the width
        var bits = log2(width);
        var picked = width;
        while(picked >= width){
            picked = 0n;
            for(var i = 0; i < bits; ++i){
                picked = 2n * picked + (rng() < 0.5 ? 0n : 1n);
            }
        }
        return min + picked;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/reshape.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createReshape": (()=>createReshape)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'reshape';
var dependencies = [
    'typed',
    'isInteger',
    'matrix'
];
var createReshape = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isInteger } = _ref;
    /**
   * Reshape a multi dimensional array to fit the specified dimensions
   *
   * Syntax:
   *
   *     math.reshape(x, sizes)
   *
   * Examples:
   *
   *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])
   *     // returns Array  [[1, 2, 3], [4, 5, 6]]
   *
   *     math.reshape([[1, 2], [3, 4]], [1, 4])
   *     // returns Array  [[1, 2, 3, 4]]
   *
   *     math.reshape([[1, 2], [3, 4]], [4])
   *     // returns Array [1, 2, 3, 4]
   *
   *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])
   *     math.reshape(x, [2, 2, 2])
   *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
   *
   *    math.reshape([1, 2, 3, 4], [-1, 2])
   *    // returns Matrix [[1, 2], [3, 4]]
   *
   * See also:
   *
   *     size, squeeze, resize
   *
   * @param {Array | Matrix | *} x  Matrix to be reshaped
   * @param {number[]} sizes        One dimensional array with integral sizes for
   *                                each dimension. One -1 is allowed as wildcard,
   *                                which calculates this dimension automatically.
   *
   * @return {* | Array | Matrix}   A reshaped clone of matrix `x`
   *
   * @throws {TypeError}            If `sizes` does not contain solely integers
   * @throws {DimensionError}       If the product of the new dimension sizes does
   *                                not equal that of the old ones
   */ return typed(name, {
        'Matrix, Array': function Matrix_Array(x, sizes) {
            return x.reshape(sizes, true);
        },
        'Array, Array': function Array_Array(x, sizes) {
            sizes.forEach(function(size) {
                if (!isInteger(size)) {
                    throw new TypeError('Invalid size for dimension: ' + size);
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reshape"])(x, sizes);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/sech.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSech": (()=>createSech)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'sech';
var dependencies = [
    'typed',
    'BigNumber'
];
var createSech = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic secant, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5)       // returns 0.886818883970074
   *    1 / math.cosh(0.5)   // returns 0.886818883970074
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic secant of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sechNumber"],
        Complex: (x)=>x.sech(),
        BigNumber: (x)=>new _BigNumber(1).div(x.cosh())
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/sinh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSinh": (()=>createSinh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'sinh';
var dependencies = [
    'typed'
];
var createSinh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * To avoid confusion with the matrix hyperbolic sine, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5)       // returns number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic sine of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sinhNumber"],
        'Complex | BigNumber': (x)=>x.sinh()
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSqrt": (()=>createSqrt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'sqrt';
var dependencies = [
    'config',
    'typed',
    'Complex'
];
var createSqrt = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, Complex } = _ref;
    /**
   * Calculate the square root of a value.
   *
   * For matrices, if you want the matrix square root of a square matrix,
   * use the `sqrtm` function. If you wish to apply `sqrt` elementwise to
   * a matrix M, use `math.map(M, math.sqrt)`.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25)                // returns 5
   *    math.square(5)               // returns 25
   *    math.sqrt(-4)                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt, sqrtm
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the square root of `x`
   */ return typed('sqrt', {
        number: _sqrtNumber,
        Complex: function Complex(x) {
            return x.sqrt();
        },
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.sqrt();
            } else {
                // negative value -> downgrade to number to do complex value computation
                return _sqrtNumber(x.toNumber());
            }
        },
        Unit: function Unit(x) {
            // Someday will work for complex units when they are implemented
            return x.pow(0.5);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */ function _sqrtNumber(x) {
        if (isNaN(x)) {
            return NaN;
        } else if (x >= 0 || config.predictable) {
            return Math.sqrt(x);
        } else {
            return new Complex(x, 0).sqrt();
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/squeeze.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSqueeze": (()=>createSqueeze)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'squeeze';
var dependencies = [
    'typed'
];
var createSqueeze = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
   *
   * Syntax:
   *
   *     math.squeeze(x)
   *
   * Examples:
   *
   *     math.squeeze([3])           // returns 3
   *     math.squeeze([[3]])         // returns 3
   *
   *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)
   *     math.squeeze(A)             // returns [0, 0, 0] (size 3)
   *
   *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)
   *     math.squeeze(B)             // returns [0, 0, 0] (size 3)
   *
   *     // only inner and outer dimensions are removed
   *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *
   * See also:
   *
   *     subset
   *
   * @param {Matrix | Array} x      Matrix to be squeezed
   * @return {Matrix | Array} Squeezed matrix
   */ return typed(name, {
        Array: function Array1(x) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squeeze"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x));
        },
        Matrix: function Matrix(x) {
            var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squeeze"])(x.toArray());
            // FIXME: return the same type of matrix as the input
            return Array.isArray(res) ? x.create(res, x.datatype()) : res;
        },
        any: function any(x) {
            // scalar
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/tanh.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTanh": (()=>createTanh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
var name = 'tanh';
var dependencies = [
    'typed'
];
var createTanh = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * To avoid confusion with matrix hyperbolic tangent, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5)                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5)  // returns 0.46211715726000974
   *    1 / math.coth(0.5)               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic tangent of x
   */ return typed('tanh', {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tanh"],
        'Complex | BigNumber': (x)=>x.tanh()
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/transpose.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTranspose": (()=>createTranspose)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'transpose';
var dependencies = [
    'typed',
    'matrix'
];
var createTranspose = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix } = _ref;
    /**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only applicable to two dimensional matrices containing
   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
   * vectors and scalars return the input unchanged.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */ return typed(name, {
        Array: (x)=>transposeMatrix(matrix(x)).valueOf(),
        Matrix: transposeMatrix,
        any: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ // scalars
        ["clone"]
    });
    "TURBOPACK unreachable";
    function transposeMatrix(x) {
        // matrix size
        var size = x.size();
        // result
        var c;
        // process dimensions
        switch(size.length){
            case 1:
                // vector
                c = x.clone();
                break;
            case 2:
                {
                    // rows and columns
                    var rows = size[0];
                    var columns = size[1];
                    // check columns
                    if (columns === 0) {
                        // throw exception
                        throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                    }
                    // process storage format
                    switch(x.storage()){
                        case 'dense':
                            c = _denseTranspose(x, rows, columns);
                            break;
                        case 'sparse':
                            c = _sparseTranspose(x, rows, columns);
                            break;
                    }
                }
                break;
            default:
                // multi dimensional
                throw new RangeError('Matrix must be a vector or two dimensional (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
        }
        return c;
    }
    function _denseTranspose(m, rows, columns) {
        // matrix array
        var data = m._data;
        // transposed matrix data
        var transposed = [];
        var transposedRow;
        // loop columns
        for(var j = 0; j < columns; j++){
            // initialize row
            transposedRow = transposed[j] = [];
            // loop rows
            for(var i = 0; i < rows; i++){
                // set data
                transposedRow[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(data[i][j]);
            }
        }
        // return matrix
        return m.createDenseMatrix({
            data: transposed,
            size: [
                columns,
                rows
            ],
            datatype: m._datatype
        });
    }
    function _sparseTranspose(m, rows, columns) {
        // matrix arrays
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // result matrices
        var cvalues = values ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // row counts
        var w = [];
        for(var x = 0; x < rows; x++){
            w[x] = 0;
        }
        // vars
        var p, l, j;
        // loop values in matrix
        for(p = 0, l = index.length; p < l; p++){
            // number of values in row
            w[index[p]]++;
        }
        // cumulative sum
        var sum = 0;
        // initialize cptr with the cummulative sum of row counts
        for(var i = 0; i < rows; i++){
            // update cptr
            cptr.push(sum);
            // update sum
            sum += w[i];
            // update w
            w[i] = cptr[i];
        }
        // update cptr
        cptr.push(sum);
        // loop columns
        for(j = 0; j < columns; j++){
            // values & index in column
            for(var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++){
                // C values & index
                var q = w[index[k]]++;
                // C[j, i] = A[i, j]
                cindex[q] = j;
                // check we need to process values (pattern matrix)
                if (values) {
                    cvalues[q] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(values[k]);
                }
            }
        }
        // return matrix
        return m.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                columns,
                rows
            ],
            datatype: m._datatype
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createXgcd": (()=>createXgcd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
var name = 'xgcd';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'BigNumber'
];
var createXgcd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, BigNumber } = _ref;
    /**
   * Calculate the extended greatest common divisor for two values.
   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12)             // returns [4, -1, 1]
   *    math.gcd(8, 12)              // returns 4
   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */ return typed(name, {
        'number, number': function number_number(a, b) {
            var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["xgcdNumber"])(a, b);
            return config.matrix === 'Array' ? res : matrix(res);
        },
        'BigNumber, BigNumber': _xgcdBigNumber
    });
    "TURBOPACK unreachable";
    /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */ function _xgcdBigNumber(a, b) {
        // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
        var // used to swap two variables
        t;
        var // quotient
        q;
        var // remainder
        r;
        var zero = new BigNumber(0);
        var one = new BigNumber(1);
        var x = zero;
        var lastx = one;
        var y = one;
        var lasty = zero;
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function xgcd must be integer numbers');
        }
        while(!b.isZero()){
            q = a.div(b).floor();
            r = a.mod(b);
            t = x;
            x = lastx.minus(q.times(x));
            lastx = t;
            t = y;
            y = lasty.minus(q.times(y));
            lasty = t;
            a = b;
            b = r;
        }
        var res;
        if (a.lt(zero)) {
            res = [
                a.neg(),
                lastx.neg(),
                lasty.neg()
            ];
        } else {
            res = [
                a,
                !a.isZero() ? lastx : 0,
                lasty
            ];
        }
        return config.matrix === 'Array' ? res : matrix(res);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/zeros.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createZeros": (()=>createZeros)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'zeros';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'BigNumber'
];
var createZeros = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, BigNumber } = _ref;
    /**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, format)
   *    math.zeros(m, n)
   *    math.zeros(m, n, format)
   *    math.zeros([m, n])
   *    math.zeros([m, n], format)
   *
   * Examples:
   *
   *    math.zeros()                   // returns []
   *    math.zeros(3)                  // returns [0, 0, 0]
   *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
   *    math.zeros(3, 'dense')         // returns [0, 0, 0]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, identity, size, range
   *
   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix}           A matrix filled with zeros
   */ return typed(name, {
        '': function _() {
            return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
        },
        // math.zeros(m, n, p, ..., format)
        // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
        '...number | BigNumber | string': function number__BigNumber__string(size) {
            var last = size[size.length - 1];
            if (typeof last === 'string') {
                var format = size.pop();
                return _zeros(size, format);
            } else if (config.matrix === 'Array') {
                return _zeros(size);
            } else {
                return _zeros(size, 'default');
            }
        },
        Array: _zeros,
        Matrix: function Matrix(size) {
            var format = size.storage();
            return _zeros(size.valueOf(), format);
        },
        'Array | Matrix, string': function Array__Matrix_string(size, format) {
            return _zeros(size.valueOf(), format);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Create an Array or Matrix with zeros
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */ function _zeros(size, format) {
        var hasBigNumbers = _normalize(size);
        var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
        _validate(size);
        if (format) {
            // return a matrix
            var m = matrix(format);
            if (size.length > 0) {
                return m.resize(size, defaultValue);
            }
            return m;
        } else {
            // return an Array
            var arr = [];
            if (size.length > 0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resize"])(arr, size, defaultValue);
            }
            return arr;
        }
    }
    // replace BigNumbers with numbers, returns true if size contained BigNumbers
    function _normalize(size) {
        var hasBigNumbers = false;
        size.forEach(function(value, index, arr) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value)) {
                hasBigNumbers = true;
                arr[index] = value.toNumber();
            }
        });
        return hasBigNumbers;
    }
    // validate arguments
    function _validate(size) {
        size.forEach(function(value) {
            if (typeof value !== 'number' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(value) || value < 0) {
                throw new Error('Parameters in function zeros must be positive integers');
            }
        });
    }
}); // TODO: zeros contains almost the same code as ones. Reuse this?
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/acoth.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAcoth": (()=>createAcoth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'acoth';
var dependencies = [
    'typed',
    'config',
    'Complex',
    'BigNumber'
];
var createAcoth = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the inverse hyperbolic tangent of a value,
   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
   *
   * To avoid confusion with the matrix inverse hyperbolic tangent, this
   * function does not apply to matrices.
   *
   * Syntax:
   *
   *    math.acoth(x)
   *
   * Examples:
   *
   *    math.acoth(0.5)     // returns 0.5493061443340548 - 1.5707963267948966i
   *
   * See also:
   *
   *    acsch, asech
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccotangent of x
   */ return typed(name, {
        number: function number(x) {
            if (x >= 1 || x <= -1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["acothNumber"])(x);
            }
            return new Complex(x, 0).acoth();
        },
        Complex: function Complex(x) {
            return x.acoth();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(1).div(x).atanh();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/asin.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAsin": (()=>createAsin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'asin';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createAsin = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the inverse sine of a value.
   *
   * To avoid confusion with the matric arcsine, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5)           // returns number 0.5235987755982989
   *    math.asin(math.sin(1.5)) // returns number 1.5
   *
   *    math.asin(2)             // returns Complex 1.5707963267948966 -1.3169578969248166i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc sine of x
   */ return typed(name, {
        number: function number(x) {
            if (x >= -1 && x <= 1 || config.predictable) {
                return Math.asin(x);
            } else {
                return new Complex(x, 0).asin();
            }
        },
        Complex: function Complex(x) {
            return x.asin();
        },
        BigNumber: function BigNumber(x) {
            return x.asin();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/string/bin.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBin": (()=>createBin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'bin';
var dependencies = [
    'typed',
    'format'
];
var createBin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, format } = _ref;
    return typed(name, {
        'number | BigNumber': function number__BigNumber(n) {
            return format(n, {
                notation: 'bin'
            });
        },
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(n, wordSize) {
            return format(n, {
                notation: 'bin',
                wordSize
            });
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/concat.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createConcat": (()=>createConcat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/IndexError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'concat';
var dependencies = [
    'typed',
    'matrix',
    'isInteger'
];
var createConcat = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, isInteger } = _ref;
    /**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    const A = [[1, 2], [5, 6]]
   *    const B = [[3, 4], [7, 8]]
   *
   *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *    math.concat('hello', ' ', 'world') // returns 'hello world'
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */ return typed(name, {
        // TODO: change signature to '...Array | Matrix, dim?' when supported
        '...Array | Matrix | number | BigNumber': function Array__Matrix__number__BigNumber(args) {
            var i;
            var len = args.length;
            var dim = -1; // zero-based dimension
            var prevDim;
            var asMatrix = false;
            var matrices = []; // contains multi dimensional arrays
            for(i = 0; i < len; i++){
                var arg = args[i];
                // test whether we need to return a Matrix (if not we return an Array)
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(arg)) {
                    asMatrix = true;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(arg) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(arg)) {
                    if (i !== len - 1) {
                        throw new Error('Dimension must be specified as last argument');
                    }
                    // last argument contains the dimension on which to concatenate
                    prevDim = dim;
                    dim = arg.valueOf(); // change BigNumber to number
                    if (!isInteger(dim)) {
                        throw new TypeError('Integer number expected for dimension');
                    }
                    if (dim < 0 || i > 0 && dim > prevDim) {
                        // TODO: would be more clear when throwing a DimensionError here
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IndexError"](dim, prevDim + 1);
                    }
                } else {
                    // this is a matrix or array
                    var m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(arg).valueOf();
                    var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(m);
                    matrices[i] = m;
                    prevDim = dim;
                    dim = size.length - 1;
                    // verify whether each of the matrices has the same number of dimensions
                    if (i > 0 && dim !== prevDim) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](prevDim + 1, dim + 1);
                    }
                }
            }
            if (matrices.length === 0) {
                throw new SyntaxError('At least one matrix expected');
            }
            var res = matrices.shift();
            while(matrices.length){
                res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(res, matrices.shift(), dim);
            }
            return asMatrix ? matrix(res) : res;
        },
        '...string': function string(args) {
            return args.join('');
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/coth.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCoth": (()=>createCoth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/trigonometry.js [app-ssr] (ecmascript)");
;
;
var name = 'coth';
var dependencies = [
    'typed',
    'BigNumber'
];
var createCoth = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber } = _ref;
    /**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic cotangent, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2)         // returns 1.0373147207275482
   *    1 / math.tanh(2)     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cotangent of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cothNumber"],
        Complex: (x)=>x.coth(),
        BigNumber: (x)=>new _BigNumber(1).div(x.tanh())
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/ctranspose.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCtranspose": (()=>createCtranspose)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'ctranspose';
var dependencies = [
    'typed',
    'transpose',
    'conj'
];
var createCtranspose = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, transpose, conj } = _ref;
    /**
   * Transpose and complex conjugate a matrix. All values of the matrix are
   * reflected over its main diagonal and then the complex conjugate is
   * taken. This is equivalent to complex conjugation for scalars and
   * vectors.
   *
   * Syntax:
   *
   *     math.ctranspose(x)
   *
   * Examples:
   *
   *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
   *     math.ctranspose(A)      // returns [[1, 4], [2, 5], [3, {re:6,im:-7}]]
   *
   * See also:
   *
   *     transpose, diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be ctransposed
   * @return {Array | Matrix}   The ctransposed matrix
   */ return typed(name, {
        any: function any(x) {
            return conj(transpose(x));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/diag.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDiag": (()=>createDiag)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'diag';
var dependencies = [
    'typed',
    'matrix',
    'DenseMatrix',
    'SparseMatrix'
];
var createDiag = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, DenseMatrix, SparseMatrix } = _ref;
    /**
   * Create a diagonal matrix or retrieve the diagonal of a matrix
   *
   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
   * When k is positive, the values are placed on the super diagonal.
   * When k is negative, the values are placed on the sub diagonal.
   *
   * Syntax:
   *
   *     math.diag(X)
   *     math.diag(X, format)
   *     math.diag(X, k)
   *     math.diag(X, k, format)
   *
   * Examples:
   *
   *     // create a diagonal matrix
   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *
   *    // retrieve the diagonal from a matrix
   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
   *    math.diag(a)   // returns [1, 5, 9]
   *
   * See also:
   *
   *     ones, zeros, identity
   *
   * @param {Matrix | Array} x          A two dimensional matrix or a vector
   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
   *                                    in or retrieved.
   * @param {string} [format='dense']   The matrix storage format.
   *
   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
   */ return typed(name, {
        // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
        Array: function Array(x) {
            return _diag(x, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), null);
        },
        'Array, number': function Array_number(x, k) {
            return _diag(x, k, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), null);
        },
        'Array, BigNumber': function Array_BigNumber(x, k) {
            return _diag(x, k.toNumber(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), null);
        },
        'Array, string': function Array_string(x, format) {
            return _diag(x, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), format);
        },
        'Array, number, string': function Array_number_string(x, k, format) {
            return _diag(x, k, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), format);
        },
        'Array, BigNumber, string': function Array_BigNumber_string(x, k, format) {
            return _diag(x, k.toNumber(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), format);
        },
        Matrix: function Matrix(x) {
            return _diag(x, 0, x.size(), x.storage());
        },
        'Matrix, number': function Matrix_number(x, k) {
            return _diag(x, k, x.size(), x.storage());
        },
        'Matrix, BigNumber': function Matrix_BigNumber(x, k) {
            return _diag(x, k.toNumber(), x.size(), x.storage());
        },
        'Matrix, string': function Matrix_string(x, format) {
            return _diag(x, 0, x.size(), format);
        },
        'Matrix, number, string': function Matrix_number_string(x, k, format) {
            return _diag(x, k, x.size(), format);
        },
        'Matrix, BigNumber, string': function Matrix_BigNumber_string(x, k, format) {
            return _diag(x, k.toNumber(), x.size(), format);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Creeate diagonal matrix from a vector or vice versa
   * @param {Array | Matrix} x
   * @param {number} k
   * @param {string} format Storage format for matrix. If null,
   *                          an Array is returned
   * @returns {Array | Matrix}
   * @private
   */ function _diag(x, k, size, format) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(k)) {
            throw new TypeError('Second parameter in function diag must be an integer');
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        // check dimensions
        switch(size.length){
            case 1:
                return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
            case 2:
                return _getDiagonal(x, k, format, size, kSub, kSuper);
        }
        throw new RangeError('Matrix for function diag must be 2 dimensional');
    }
    function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
        // matrix size
        var ms = [
            l + kSub,
            l + kSuper
        ];
        if (format && format !== 'sparse' && format !== 'dense') {
            throw new TypeError("Unknown matrix type ".concat(format, "\""));
        }
        // create diagonal matrix
        var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
        // check we need to return a matrix
        return format !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format, s, kSub, kSuper) {
        // check x is a Matrix
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
            // get diagonal matrix
            var dm = x.diagonal(k);
            // check we need to return a matrix
            if (format !== null) {
                // check we need to change matrix format
                if (format !== dm.storage()) {
                    return matrix(dm, format);
                }
                return dm;
            }
            return dm.valueOf();
        }
        // vector size
        var n = Math.min(s[0] - kSub, s[1] - kSuper);
        // diagonal values
        var vector = [];
        // loop diagonal
        for(var i = 0; i < n; i++){
            vector[i] = x[i + kSub][i + kSuper];
        }
        // check we need to return a matrix
        return format !== null ? matrix(vector) : vector;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotMultiply": (()=>createDotMultiply)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'dotMultiply';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'multiplyScalar',
    'concat'
];
var createDotMultiply = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, multiplyScalar, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo09xS0Sf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo09xS0Sf"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4) // returns 8
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: multiplyScalar,
        SS: matAlgo09xS0Sf,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/equal.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEqual": (()=>createEqual),
    "createEqualNumber": (()=>createEqualNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'equal';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createEqual = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured relTol and absTol. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else. Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3)         // returns false
   *    math.equal(2 + 2, 4)         // returns true
   *
   *    const a = math.unit('50 cm')
   *    const b = math.unit('5 m')
   *    math.equal(a, b)             // returns true
   *
   *    const c = [2, 5, 1]
   *    const d = [2, 7, 1]
   *
   *    math.equal(c, d)             // returns [true, false, true]
   *    math.deepEqual(c, d)         // returns false
   *
   *    math.equal("1000", "1e3")    // returns true
   *    math.equal(0, null)          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
   *
   * @param  {number | BigNumber | bigint | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */ return typed(name, createEqualNumber({
        typed,
        equalScalar
    }), matrixAlgorithmSuite({
        elop: equalScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createEqualNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'equalScalar'
], (_ref2)=>{
    var { typed, equalScalar } = _ref2;
    return typed(name, {
        'any, any': function any_any(x, y) {
            // strict equality for null and undefined?
            if (x === null) {
                return y === null;
            }
            if (y === null) {
                return x === null;
            }
            if (x === undefined) {
                return y === undefined;
            }
            if (y === undefined) {
                return x === undefined;
            }
            return equalScalar(x, y);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/identity.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIdentity": (()=>createIdentity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'identity';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'BigNumber',
    'DenseMatrix',
    'SparseMatrix'
];
var createIdentity = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, BigNumber, DenseMatrix, SparseMatrix } = _ref;
    /**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.identity(n)
   *    math.identity(n, format)
   *    math.identity(m, n)
   *    math.identity(m, n, format)
   *    math.identity([m, n])
   *    math.identity([m, n], format)
   *
   * Examples:
   *
   *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...number | Matrix | Array} size   The size for the matrix
   * @param {string} [format]                   The Matrix storage format
   *
   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
   */ return typed(name, {
        '': function _() {
            return config.matrix === 'Matrix' ? matrix([]) : [];
        },
        string: function string(format) {
            return matrix(format);
        },
        'number | BigNumber': function number__BigNumber(rows) {
            return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
        },
        'number | BigNumber, string': function number__BigNumber_string(rows, format) {
            return _identity(rows, rows, format);
        },
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(rows, cols) {
            return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
        },
        'number | BigNumber, number | BigNumber, string': function number__BigNumber_number__BigNumber_string(rows, cols, format) {
            return _identity(rows, cols, format);
        },
        Array: function Array(size) {
            return _identityVector(size);
        },
        'Array, string': function Array_string(size, format) {
            return _identityVector(size, format);
        },
        Matrix: function Matrix(size) {
            return _identityVector(size.valueOf(), size.storage());
        },
        'Matrix, string': function Matrix_string(size, format) {
            return _identityVector(size.valueOf(), format);
        }
    });
    "TURBOPACK unreachable";
    function _identityVector(size, format) {
        switch(size.length){
            case 0:
                return format ? matrix(format) : [];
            case 1:
                return _identity(size[0], size[0], format);
            case 2:
                return _identity(size[0], size[1], format);
            default:
                throw new Error('Vector containing two values expected');
        }
    }
    /**
   * Create an identity matrix
   * @param {number | BigNumber} rows
   * @param {number | BigNumber} cols
   * @param {string} [format]
   * @returns {Matrix}
   * @private
   */ function _identity(rows, cols, format) {
        // BigNumber constructor with the right precision
        var Big = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(rows) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(cols) ? BigNumber : null;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(rows)) rows = rows.toNumber();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(cols)) cols = cols.toNumber();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(rows) || rows < 1) {
            throw new Error('Parameters in function identity must be positive integers');
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(cols) || cols < 1) {
            throw new Error('Parameters in function identity must be positive integers');
        }
        var one = Big ? new BigNumber(1) : 1;
        var defaultValue = Big ? new Big(0) : 0;
        var size = [
            rows,
            cols
        ];
        // check we need to return a matrix
        if (format) {
            // create diagonal matrix (use optimized implementation for storage format)
            if (format === 'sparse') {
                return SparseMatrix.diagonal(size, one, 0, defaultValue);
            }
            if (format === 'dense') {
                return DenseMatrix.diagonal(size, one, 0, defaultValue);
            }
            throw new TypeError("Unknown matrix type \"".concat(format, "\""));
        }
        // create and resize array
        var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resize"])([], size, defaultValue);
        // fill in ones on the diagonal
        var minimum = rows < cols ? rows : cols;
        // fill diagonal
        for(var d = 0; d < minimum; d++){
            res[d][d] = one;
        }
        return res;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/isNumeric.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIsNumeric": (()=>createIsNumeric)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'isNumeric';
var dependencies = [
    'typed'
];
var createIsNumeric = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Test whether a value is an numeric value.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNumeric(x)
   *
   * Examples:
   *
   *    math.isNumeric(2)                     // returns true
   *    math.isNumeric('2')                   // returns false
   *    math.hasNumericValue('2')             // returns true
   *    math.isNumeric(0)                     // returns true
   *    math.isNumeric(math.bignumber('42'))  // returns true
   *    math.isNumeric(math.bigint('42'))     // returns true
   *    math.isNumeric(math.fraction(4))      // returns true
   *    math.isNumeric(math.complex('2-4i'))  // returns false
   *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger, hasNumericValue
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, or `boolean`. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */ return typed(name, {
        'number | BigNumber | bigint | Fraction | boolean': ()=>true,
        'Complex | Unit | string | null | undefined | Node': ()=>false,
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/kron.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createKron": (()=>createKron)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'kron';
var dependencies = [
    'typed',
    'matrix',
    'multiplyScalar'
];
var createKron = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, multiplyScalar } = _ref;
    /**
     * Calculates the Kronecker product of 2 matrices or vectors.
     *
     * NOTE: If a one dimensional vector / matrix is given, it will be
     * wrapped so its two dimensions.
     * See the examples.
     *
     * Syntax:
     *
     *    math.kron(x, y)
     *
     * Examples:
     *
     *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])
     *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
     *
     *    math.kron([1,1], [2,3,4])
     *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]
     *
     * See also:
     *
     *    multiply, dot, cross
     *
     * @param  {Array | Matrix} x     First vector
     * @param  {Array | Matrix} y     Second vector
     * @return {Array | Matrix}       Returns the Kronecker product of `x` and `y`
     */ return typed(name, {
        'Matrix, Matrix': function Matrix_Matrix(x, y) {
            return matrix(_kron(x.toArray(), y.toArray()));
        },
        'Matrix, Array': function Matrix_Array(x, y) {
            return matrix(_kron(x.toArray(), y));
        },
        'Array, Matrix': function Array_Matrix(x, y) {
            return matrix(_kron(x, y.toArray()));
        },
        'Array, Array': _kron
    });
    "TURBOPACK unreachable";
    /**
     * Calculate the Kronecker product of two matrices / vectors
     * @param {Array} a  First vector
     * @param {Array} b  Second vector
     * @returns {Array} Returns the Kronecker product of x and y
     * @private
     */ function _kron(a, b) {
        // Deal with the dimensions of the matricies.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(a).length === 1) {
            // Wrap it in a 2D Matrix
            a = [
                a
            ];
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(b).length === 1) {
            // Wrap it in a 2D Matrix
            b = [
                b
            ];
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(a).length > 2 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(b).length > 2) {
            throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' + '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');
        }
        var t = [];
        var r = [];
        return a.map(function(a) {
            return b.map(function(b) {
                r = [];
                t.push(r);
                return a.map(function(y) {
                    return b.map(function(x) {
                        return r.push(multiplyScalar(y, x));
                    });
                });
            });
        }) && t;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/largerEq.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLargerEq": (()=>createLargerEq),
    "createLargerEqNumber": (()=>createLargerEqNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'largerEq';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createLargerEq = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Test whether value x is larger or equal to y.
   *
   * The function returns true when x is larger than y or the relative
   * difference between x and y is smaller than the configured relTol and absTol. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.largerEq(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 1 + 1)         // returns false
   *    math.largerEq(2, 1 + 1)       // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, compare
   *
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
   */ return typed(name, createLargerEqNumber({
        typed,
        config
    }), {
        'boolean, boolean': (x, y)=>x >= y,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.gte(y) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x >= y;
        },
        'Fraction, Fraction': (x, y)=>x.compare(y) !== -1,
        'Complex, Complex': function Complex_Complex() {
            throw new TypeError('No ordering relation is defined for complex numbers');
        }
    }, compareUnits, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createLargerEqNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return x >= y || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUseMatrixForArrayScalar": (()=>createUseMatrixForArrayScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var createUseMatrixForArrayScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])('useMatrixForArrayScalar', [
    'typed',
    'matrix'
], (_ref)=>{
    var { typed, matrix } = _ref;
    return {
        'Array, number': typed.referTo('DenseMatrix, number', (selfDn)=>(x, y)=>selfDn(matrix(x), y).valueOf()),
        'Array, BigNumber': typed.referTo('DenseMatrix, BigNumber', (selfDB)=>(x, y)=>selfDB(matrix(x), y).valueOf()),
        'number, Array': typed.referTo('number, DenseMatrix', (selfnD)=>(x, y)=>selfnD(x, matrix(y)).valueOf()),
        'BigNumber, Array': typed.referTo('BigNumber, DenseMatrix', (selfBD)=>(x, y)=>selfBD(x, matrix(y)).valueOf())
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/leftShift.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLeftShift": (()=>createLeftShift)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var name = 'leftShift';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix',
    'concat'
];
var createLeftShift = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, zeros, DenseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo08xS0Sid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo08xS0Sid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var useMatrixForArrayScalar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createUseMatrixForArrayScalar"])({
        typed,
        matrix
    });
    /**
   * Bitwise left logical shift of a value x by y number of bits, `x << y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.leftShift(x, y)
   *
   * Examples:
   *
   *    math.leftShift(1, 2)               // returns number 4
   *
   *    math.leftShift([1, 2, 4], 4)       // returns Array [16, 32, 64]
   *
   * See also:
   *
   *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber | bigint} y Amount of shifts
   * @return {number | BigNumber | bigint | Array | Matrix} `x` shifted left `y` times
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["leftShiftNumber"],
        'BigNumber, BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["leftShiftBigNumber"],
        'bigint, bigint': (x, y)=>x << y,
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | BigNumber, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo10xSids(y, x, self, true);
            }),
        'number | BigNumber, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo14xDs(y, x, self, true);
            })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/mode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMode": (()=>createMode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'mode';
var dependencies = [
    'typed',
    'isNaN',
    'isNumeric'
];
var createMode = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isNaN: mathIsNaN, isNumeric } = _ref;
    /**
  * Computes the mode of a set of numbers or a list with values(numbers or characters).
  * If there are multiple modes, it returns a list of those values.
  *
  * Syntax:
  *
  *     math.mode(a, b, c, ...)
  *     math.mode(A)
  *
  * Examples:
  *
  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]
  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]
  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
  *     math.mode('a','a','b','c')                           // returns ["a"]
  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
  *
  * See also:
  *
  *     median,
  *     mean
  *
  * @param {... *} args  A single matrix
  * @return {*} The mode of all values
  */ return typed(name, {
        'Array | Matrix': _mode,
        '...': function _(args) {
            return _mode(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculates the mode in an 1-dimensional array
   * @param {Array} values
   * @return {Array} mode
   * @private
   */ function _mode(values) {
        values = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(values.valueOf());
        var num = values.length;
        if (num === 0) {
            throw new Error('Cannot calculate mode of an empty array');
        }
        var count = {};
        var mode = [];
        var max = 0;
        for(var i = 0; i < values.length; i++){
            var value = values[i];
            if (isNumeric(value) && mathIsNaN(value)) {
                throw new Error('Cannot calculate mode of an array containing NaN values');
            }
            if (!(value in count)) {
                count[value] = 0;
            }
            count[value]++;
            if (count[value] === max) {
                mode.push(value);
            } else if (count[value] > max) {
                max = count[value];
                mode = [
                    value
                ];
            }
        }
        return mode;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNthRoot": (()=>createNthRoot),
    "createNthRootNumber": (()=>createNthRootNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'nthRoot';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'BigNumber',
    'concat'
];
var createNthRoot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, BigNumber: _BigNumber, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2)    // returns 3 (since 3^2 == 9)
   *     math.sqrt(9)          // returns 3 (since 3^2 == 9)
   *     math.nthRoot(64, 3)   // returns 4 (since 4^3 == 64)
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */ function complexErr() {
        throw new Error('Complex number not supported in function nthRoot. Use nthRoots instead.');
    }
    return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nthRootNumber"],
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nthRootNumber"],
        BigNumber: (x)=>_bigNthRoot(x, new _BigNumber(2)),
        'BigNumber, BigNumber': _bigNthRoot,
        Complex: complexErr,
        'Complex, number': complexErr,
        Array: typed.referTo('DenseMatrix,number', (selfDn)=>(x)=>selfDn(matrix(x), 2).valueOf()),
        DenseMatrix: typed.referTo('DenseMatrix,number', (selfDn)=>(x)=>selfDn(x, 2)),
        SparseMatrix: typed.referTo('SparseMatrix,number', (selfSn)=>(x)=>selfSn(x, 2)),
        'SparseMatrix, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // sparse + sparse
                    return matAlgo06xS0S0(x, y, self);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            }),
        'DenseMatrix, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // dense + sparse
                    return matAlgo01xDSid(x, y, self, false);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            }),
        'Array, SparseMatrix': typed.referTo('DenseMatrix,SparseMatrix', (selfDS)=>(x, y)=>selfDS(matrix(x), y)),
        'number | BigNumber, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // sparse - scalar
                    return matAlgo11xS0s(y, x, self, true);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            })
    }, matrixAlgorithmSuite({
        scalar: 'number | BigNumber',
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: false
    }));
    "TURBOPACK unreachable";
    /**
   * Calculate the nth root of a for BigNumbers, solve x^root == a
   * https://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {BigNumber} a
   * @param {BigNumber} root
   * @private
   */ function _bigNthRoot(a, root) {
        var precision = _BigNumber.precision;
        var Big = _BigNumber.clone({
            precision: precision + 2
        });
        var zero = new _BigNumber(0);
        var one = new Big(1);
        var inv = root.isNegative();
        if (inv) {
            root = root.neg();
        }
        if (root.isZero()) {
            throw new Error('Root must be non-zero');
        }
        if (a.isNegative() && !root.abs().mod(2).equals(1)) {
            throw new Error('Root must be odd when a is negative.');
        }
        // edge cases zero and infinity
        if (a.isZero()) {
            return inv ? new Big(Infinity) : 0;
        }
        if (!a.isFinite()) {
            return inv ? zero : a;
        }
        var x = a.abs().pow(one.div(root));
        // If a < 0, we require that root is an odd integer,
        // so (-1) ^ (1/root) = -1
        x = a.isNeg() ? x.neg() : x;
        return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
});
var createNthRootNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed'
], (_ref2)=>{
    var { typed } = _ref2;
    return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nthRootNumber"],
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nthRootNumber"]
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/numeric.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNumeric": (()=>createNumeric)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/noop.js [app-ssr] (ecmascript)");
;
;
;
var name = 'numeric';
var dependencies = [
    'number',
    '?bignumber',
    '?fraction'
];
var createNumeric = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { number: _number, bignumber, fraction } = _ref;
    var validInputTypes = {
        string: true,
        number: true,
        BigNumber: true,
        Fraction: true
    };
    // Load the conversion functions for each output type
    var validOutputTypes = {
        number: (x)=>_number(x),
        BigNumber: bignumber ? (x)=>bignumber(x) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noBignumber"],
        bigint: (x)=>BigInt(x),
        Fraction: fraction ? (x)=>fraction(x) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noFraction"]
    };
    /**
   * Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
   *
   * Syntax:
   *
   *    math.numeric(x)
   *    math.numeric(value, outputType)
   *
   * Examples:
   *
   *    math.numeric('4')                           // returns 4
   *    math.numeric('4', 'number')                 // returns 4
   *    math.numeric('4', 'bigint')                 // returns 4n
   *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
   *    math.numeric('4', 'Fraction')               // returns Fraction 4
   *    math.numeric(4, 'Fraction')                 // returns Fraction 4
   *    math.numeric(math.fraction(2, 5), 'number') // returns 0.4
   *
   * See also:
   *
   *    number, fraction, bignumber, bigint, string, format
   *
   * @param {string | number | BigNumber | bigint | Fraction } value
   *              A numeric value or a string containing a numeric value
   * @param {string} outputType
   *              Desired numeric output type.
   *              Available values: 'number', 'BigNumber', or 'Fraction'
   * @return {number | BigNumber | bigint | Fraction}
   *              Returns an instance of the numeric in the requested type
   */ return function numeric(value) {
        var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'number';
        var check = arguments.length > 2 ? arguments[2] : undefined;
        if (check !== undefined) {
            throw new SyntaxError('numeric() takes one or two arguments');
        }
        var inputType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(value);
        if (!(inputType in validInputTypes)) {
            throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
        }
        if (!(outputType in validOutputTypes)) {
            throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
        }
        if (outputType === inputType) {
            return value;
        } else {
            return validOutputTypes[outputType](value);
        }
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "improveErrorMessage": (()=>improveErrorMessage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
function improveErrorMessage(err, fnName, value) {
    // TODO: add information with the index (also needs transform in expression parser)
    var details;
    if (String(err).includes('Unexpected type')) {
        details = arguments.length > 2 ? ' (type: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(value) + ', value: ' + JSON.stringify(value) + ')' : ' (type: ' + err.data.actual + ')';
        return new TypeError('Cannot calculate ' + fnName + ', unexpected type of argument' + details);
    }
    if (String(err).includes('complex numbers')) {
        details = arguments.length > 2 ? ' (type: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(value) + ', value: ' + JSON.stringify(value) + ')' : '';
        return new TypeError('Cannot calculate ' + fnName + ', no ordering relation is defined for complex numbers' + details);
    }
    return err;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/prod.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createProd": (()=>createProd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'prod';
var dependencies = [
    'typed',
    'config',
    'multiplyScalar',
    'numeric'
];
var createProd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, multiplyScalar, numeric } = _ref;
    /**
   * Compute the product of a matrix or a list with values.
   * In case of a multidimensional array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.prod(a, b, c, ...)
   *     math.prod(A)
   *
   * Examples:
   *
   *     math.multiply(2, 3)           // returns 6
   *     math.prod(2, 3)               // returns 6
   *     math.prod(2, 3, 4)            // returns 24
   *     math.prod([2, 3, 4])          // returns 24
   *     math.prod([[2, 5], [4, 3]])   // returns 120
   *
   * See also:
   *
   *    mean, median, min, max, sum, std, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The product of all values
   */ return typed(name, {
        // prod([a, b, c, d, ...])
        'Array | Matrix': _prod,
        // prod([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': function Array__Matrix_number__BigNumber(array, dim) {
            // TODO: implement prod(A, dim)
            throw new Error('prod(A, dim) is not yet supported');
        // return reduce(arguments[0], arguments[1], math.prod)
        },
        // prod(a, b, c, d, ...)
        '...': function _(args) {
            return _prod(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Recursively calculate the product of an n-dimensional array
   * @param {Array} array
   * @return {number} prod
   * @private
   */ function _prod(array) {
        var prod;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                prod = prod === undefined ? value : multiplyScalar(prod, value);
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'prod', value);
            }
        });
        // make sure returning numeric value: parse a string into a numeric value
        if (typeof prod === 'string') {
            prod = numeric(prod, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNumberType"])(prod, config));
        }
        if (prod === undefined) {
            throw new Error('Cannot calculate prod of an empty array');
        }
        return prod;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/resize.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createResize": (()=>createResize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/ArgumentsError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'resize';
var dependencies = [
    'config',
    'matrix'
];
var createResize = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, matrix } = _ref;
    /**
   * Resize a matrix
   *
   * Syntax:
   *
   *     math.resize(x, size)
   *     math.resize(x, size, defaultValue)
   *
   * Examples:
   *
   *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]
   *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]
   *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]
   *     math.resize("hello", [8], "!")    // returns string 'hello!!!'
   *
   * See also:
   *
   *     size, squeeze, subset, reshape
   *
   * @param {Array | Matrix | *} x             Matrix to be resized
   * @param {Array | Matrix} size              One dimensional array with numbers
   * @param {number | string} [defaultValue=0] Zero by default, except in
   *                                           case of a string, in that case
   *                                           defaultValue = ' '
   * @return {* | Array | Matrix} A resized clone of matrix `x`
   */ // TODO: rework resize to a typed-function
    return function resize(x, size, defaultValue) {
        if (arguments.length !== 2 && arguments.length !== 3) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ArgumentsError"]('resize', arguments.length, 2, 3);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(size)) {
            size = size.valueOf(); // get Array
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(size[0])) {
            // convert bignumbers to numbers
            size = size.map(function(value) {
                return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(value) ? value : value.toNumber();
            });
        }
        // check x is a Matrix
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
            // use optimized matrix implementation, return copy
            return x.resize(size, defaultValue, true);
        }
        if (typeof x === 'string') {
            // resize string
            return _resizeString(x, size, defaultValue);
        }
        // check result should be a matrix
        var asMatrix = Array.isArray(x) ? false : config.matrix !== 'Array';
        if (size.length === 0) {
            // output a scalar
            while(Array.isArray(x)){
                x = x[0];
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x);
        } else {
            // output an array/matrix
            if (!Array.isArray(x)) {
                x = [
                    x
                ];
            }
            x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x);
            var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resize"])(x, size, defaultValue);
            return asMatrix ? matrix(res) : res;
        }
    };
    "TURBOPACK unreachable";
    /**
   * Resize a string
   * @param {string} str
   * @param {number[]} size
   * @param {string} [defaultChar=' ']
   * @private
   */ function _resizeString(str, size, defaultChar) {
        if (defaultChar !== undefined) {
            if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {
                throw new TypeError('Single character expected as defaultValue');
            }
        } else {
            defaultChar = ' ';
        }
        if (size.length !== 1) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](size.length, 1);
        }
        var len = size[0];
        if (typeof len !== 'number' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(len)) {
            throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
        }
        if (str.length > len) {
            return str.substring(0, len);
        } else if (str.length < len) {
            var res = str;
            for(var i = 0, ii = len - str.length; i < ii; i++){
                res += defaultChar;
            }
            return res;
        } else {
            return str;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRightArithShift": (()=>createRightArithShift)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var name = 'rightArithShift';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix',
    'concat'
];
var createRightArithShift = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, zeros, DenseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo08xS0Sid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo08xS0Sid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var useMatrixForArrayScalar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createUseMatrixForArrayScalar"])({
        typed,
        matrix
    });
    /**
   * Bitwise right arithmetic shift of a value x by y number of bits, `x >> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightArithShift(x, y)
   *
   * Examples:
   *
   *    math.rightArithShift(4, 2)               // returns number 1
   *
   *    math.rightArithShift([16, -32, 64], 4)   // returns Array [1, -2, 4]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber | bigint} y Amount of shifts
   * @return {number | BigNumber | bigint | Array | Matrix} `x` zero-filled shifted right `y` times
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rightArithShiftNumber"],
        'BigNumber, BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rightArithShiftBigNumber"],
        'bigint, bigint': (x, y)=>x >> y,
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | BigNumber, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo10xSids(y, x, self, true);
            }),
        'number | BigNumber, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo14xDs(y, x, self, true);
            })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/round.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRound": (()=>createRound)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var NO_INT = 'Number of decimals in function round must be an integer';
var name = 'round';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'equalScalar',
    'zeros',
    'BigNumber',
    'DenseMatrix'
];
var createRound = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, equalScalar, zeros, BigNumber: _BigNumber, DenseMatrix } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    function toExponent(epsilon) {
        return Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["splitNumber"])(epsilon).exponent);
    }
    /**
   * Round a value towards the nearest rounded value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *    math.round(unit, valuelessUnit)
   *    math.round(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.round(3.22)             // returns number 3
   *    math.round(3.82)             // returns number 4
   *    math.round(-4.2)             // returns number -4
   *    math.round(-4.7)             // returns number -5
   *    math.round(3.22, 1)          // returns number 3.2
   *    math.round(3.88, 1)          // returns number 3.9
   *    math.round(-4.21, 1)         // returns number -4.2
   *    math.round(-4.71, 1)         // returns number -4.7
   *    math.round(math.pi, 3)       // returns number 3.142
   *    math.round(123.45678, 2)     // returns number 123.46
   *
   *    const c = math.complex(3.2, -2.7)
   *    math.round(c)                // returns Complex 3 - 3i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.round(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.round(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed(name, {
        number: function number(x) {
            // Handle round off errors by first rounding to relTol precision
            var xEpsilon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundNumber"])(x, toExponent(config.relTol));
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundNumber"])(xSelected);
        },
        'number, number': function number_number(x, n) {
            // Same as number: unless user specifies more decimals than relTol
            var epsilonExponent = toExponent(config.relTol);
            if (n >= epsilonExponent) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundNumber"])(x, n);
            }
            var xEpsilon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundNumber"])(x, epsilonExponent);
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundNumber"])(xSelected, n);
        },
        'number, BigNumber': function number_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            return new _BigNumber(x).toDecimalPlaces(n.toNumber());
        },
        Complex: function Complex(x) {
            return x.round();
        },
        'Complex, number': function Complex_number(x, n) {
            if (n % 1) {
                throw new TypeError(NO_INT);
            }
            return x.round(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            var _n = n.toNumber();
            return x.round(_n);
        },
        BigNumber: function BigNumber(x) {
            // Handle round off errors by first rounding to relTol precision
            var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config.relTol));
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(0);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            // Same as BigNumber: unless user specifies more decimals than relTol
            var epsilonExponent = toExponent(config.relTol);
            if (n >= epsilonExponent) {
                return x.toDecimalPlaces(n.toNumber());
            }
            var xEpsilon = x.toDecimalPlaces(epsilonExponent);
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(n.toNumber());
        },
        // bigints can't be rounded
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.round();
        },
        'Fraction, number': function Fraction_number(x, n) {
            if (n % 1) {
                throw new TypeError(NO_INT);
            }
            return x.round(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            return x.round(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since round(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since round(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                return matAlgo11xS0s(x, n, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                return matAlgo14xDs(x, n, self, false);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(x), n, self, false).valueOf();
            }),
        'number | Complex | BigNumber | Fraction, SparseMatrix': typed.referToSelf((self)=>(x, n)=>{
                // check scalar is zero
                if (equalScalar(x, 0)) {
                    // do not execute algorithm, result will be a zero matrix
                    return zeros(n.size(), n.storage());
                }
                return matAlgo12xSfs(n, x, self, true);
            }),
        'number | Complex | BigNumber | Fraction, DenseMatrix': typed.referToSelf((self)=>(x, n)=>{
                // check scalar is zero
                if (equalScalar(x, 0)) {
                    // do not execute algorithm, result will be a zero matrix
                    return zeros(n.size(), n.storage());
                }
                return matAlgo14xDs(n, x, self, true);
            }),
        'number | Complex | BigNumber | Fraction, Array': typed.referToSelf((self)=>(x, n)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(n), x, self, true).valueOf();
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/size.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSize": (()=>createSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/noop.js [app-ssr] (ecmascript)");
;
;
;
var name = 'size';
var dependencies = [
    'typed',
    'config',
    '?matrix'
];
var createSize = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix } = _ref;
    /**
   * Calculate the size of a matrix or scalar.
   *
   * Syntax:
   *
   *     math.size(x)
   *
   * Examples:
   *
   *     math.size(2.3)                       // returns []
   *     math.size('hello world')             // returns [11]
   *
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.size(A)                         // returns [2, 3]
   *     math.size(math.range(1,6).toArray()) // returns [5]
   *
   * See also:
   *
   *     count, resize, squeeze, subset
   *
   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
   * @return {Array | Matrix} A vector with size of `x`.
   */ return typed(name, {
        Matrix: function Matrix(x) {
            return x.create(x.size(), 'number');
        },
        Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"],
        string: function string(x) {
            return config.matrix === 'Array' ? [
                x.length
            ] : matrix([
                x.length
            ], 'dense', 'number');
        },
        'number | Complex | BigNumber | Unit | boolean | null': function number__Complex__BigNumber__Unit__boolean__null(x) {
            // scalar
            return config.matrix === 'Array' ? [] : matrix ? matrix([], 'dense', 'number') : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noMatrix"])();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/smaller.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSmaller": (()=>createSmaller),
    "createSmallerNumber": (()=>createSmallerNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'smaller';
var dependencies = [
    'typed',
    'config',
    'bignumber',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createSmaller = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, bignumber, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is smaller than the configured relTol and absTol. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3)            // returns true
   *    math.smaller(5, 2 * 2)        // returns false
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('2 inch')
   *    math.smaller(a, b)            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, smaller, smallerEq, compare
   *
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */ function bignumSmaller(x, y) {
        return x.lt(y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
    }
    return typed(name, createSmallerNumber({
        typed,
        config
    }), {
        'boolean, boolean': (x, y)=>x < y,
        'BigNumber, BigNumber': bignumSmaller,
        'bigint, bigint': (x, y)=>x < y,
        'Fraction, Fraction': (x, y)=>x.compare(y) === -1,
        'Fraction, BigNumber': function Fraction_BigNumber(x, y) {
            return bignumSmaller(bignumber(x), y);
        },
        'BigNumber, Fraction': function BigNumber_Fraction(x, y) {
            return bignumSmaller(x, bignumber(y));
        },
        'Complex, Complex': function Complex_Complex(x, y) {
            throw new TypeError('No ordering relation is defined for complex numbers');
        }
    }, compareUnits, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createSmallerNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return x < y && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/unit/to.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTo": (()=>createTo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
var name = 'to';
var dependencies = [
    'typed',
    'matrix',
    'concat'
];
var createTo = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, concat } = _ref;
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Change the unit of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.to(x, unit)
   *
   * Examples:
   *
   *    math.to(math.unit('2 inch'), 'cm')             // returns Unit 5.08 cm
   *    math.to(math.unit('2 inch'), math.unit('cm'))  // returns Unit 5.08 cm
   *    math.to(math.unit(16, 'bytes'), 'bits')        // returns Unit 128 bits
   *
   * See also:
   *
   *    unit
   *
   * @param {Unit | Array | Matrix} x     The unit to be converted.
   * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
   *                                      or a unit without value.
   * @return {Unit | Array | Matrix} value with changed, fixed unit.
   */ return typed(name, {
        'Unit, Unit | string': (x, unit)=>x.to(unit)
    }, matrixAlgorithmSuite({
        Ds: true
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnaryMinus": (()=>createUnaryMinus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
var name = 'unaryMinus';
var dependencies = [
    'typed'
];
var createUnaryMinus = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5)      // returns -3.5
   *    math.unaryMinus(-4.2)     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unaryMinusNumber"],
        'Complex | BigNumber | Fraction': (x)=>x.neg(),
        bigint: (x)=>-x,
        Unit: typed.referToSelf((self)=>(x)=>{
                var res = x.clone();
                res.value = typed.find(self, res.valueType())(x.value);
                return res;
            }),
        // deep map collection, skip zeros since unaryMinus(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/unequal.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnequal": (()=>createUnequal),
    "createUnequalNumber": (()=>createUnequalNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'unequal';
var dependencies = [
    'typed',
    'config',
    'equalScalar',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createUnequal = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, equalScalar, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Test whether two values are unequal.
   *
   * The function tests whether the relative difference between x and y is
   * larger than the configured relTol and absTol. The function cannot be used to compare
   * values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
   * Strings are compared by their numerical value.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is unequal
   * with everything except `null`, and `undefined` is unequal with everything
   * except `undefined`.
   *
   * Syntax:
   *
   *    math.unequal(x, y)
   *
   * Examples:
   *
   *    math.unequal(2 + 2, 3)       // returns true
   *    math.unequal(2 + 2, 4)       // returns false
   *
   *    const a = math.unit('50 cm')
   *    const b = math.unit('5 m')
   *    math.unequal(a, b)           // returns false
   *
   *    const c = [2, 5, 1]
   *    const d = [2, 7, 1]
   *
   *    math.unequal(c, d)           // returns [false, true, false]
   *    math.deepEqual(c, d)         // returns false
   *
   *    math.unequal(0, null)        // returns true
   * See also:
   *
   *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
   */ return typed(name, createUnequalNumber({
        typed,
        equalScalar
    }), matrixAlgorithmSuite({
        elop: _unequal,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
    "TURBOPACK unreachable";
    function _unequal(x, y) {
        return !equalScalar(x, y);
    }
});
var createUnequalNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'equalScalar'
], (_ref2)=>{
    var { typed, equalScalar } = _ref2;
    return typed(name, {
        'any, any': function any_any(x, y) {
            // strict equality for null and undefined?
            if (x === null) {
                return y !== null;
            }
            if (y === null) {
                return x !== null;
            }
            if (x === undefined) {
                return y !== undefined;
            }
            if (y === undefined) {
                return x !== undefined;
            }
            return !equalScalar(x, y);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/logical/xor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createXor": (()=>createXor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/logical.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'xor';
var dependencies = [
    'typed',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createXor = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.xor(x, y)
   *
   * Examples:
   *
   *    math.xor(2, 4)   // returns false
   *
   *    a = [2, 0, 0]
   *    b = [2, 7, 0]
   *    c = 0
   *
   *    math.xor(a, b)   // returns [false, true, false]
   *    math.xor(a, c)   // returns [true, false, false]
   *
   * See also:
   *
   *    and, not, or
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one and only one input is defined with a nonzero/nonempty value.
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["xorNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
        },
        'bigint, bigint': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["xorNumber"],
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
        },
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>self(x.value || 0, y.value || 0))
    }, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/add.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAdd": (()=>createAdd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'add';
var dependencies = [
    'typed',
    'matrix',
    'addScalar',
    'equalScalar',
    'DenseMatrix',
    'SparseMatrix',
    'concat'
];
var createAdd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, addScalar, equalScalar, DenseMatrix, SparseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo04xSidSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo04xSidSid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Add two or more values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *    math.add(x, y, z, ...)
   *
   * Examples:
   *
   *    math.add(2, 3)               // returns number 5
   *    math.add(2, 3, 4)            // returns number 9
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(-4, 1)
   *    math.add(a, b)               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
   *
   *    const c = math.unit('5 cm')
   *    const d = math.unit('2.1 mm')
   *    math.add(c, d)               // returns Unit 52.1 mm
   *
   *    math.add("2.3", "4")         // returns number 6.3
   *
   * See also:
   *
   *    subtract, sum
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to add
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to add
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
   */ return typed(name, {
        'any, any': addScalar,
        'any, any, ...any': typed.referToSelf((self)=>(x, y, rest)=>{
                var result = self(x, y);
                for(var i = 0; i < rest.length; i++){
                    result = self(result, rest[i]);
                }
                return result;
            })
    }, matrixAlgorithmSuite({
        elop: addScalar,
        DS: matAlgo01xDSid,
        SS: matAlgo04xSidSid,
        Ss: matAlgo10xSids
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/trigonometry/atan2.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAtan2": (()=>createAtan2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'atan2';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'BigNumber',
    'DenseMatrix',
    'concat'
];
var createAtan2 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, BigNumber, DenseMatrix, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo09xS0Sf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo09xS0Sf"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi       // returns number 0.25
   *
   *    const angle = math.unit(60, 'deg')
   *    const x = math.cos(angle)
   *    const y = math.sin(angle)
   *    math.atan2(y, x) * 180 / math.pi  // returns 60
   *
   *    math.atan(2)             // returns number 1.1071487177940904
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {number | Array | Matrix} y  Second dimension
   * @param {number | Array | Matrix} x  First dimension
   * @return {number | Array | Matrix} Four-quadrant inverse tangent
   */ return typed(name, {
        'number, number': Math.atan2,
        // Complex numbers doesn't seem to have a reasonable implementation of
        // atan2(). Even Matlab removed the support, after they only calculated
        // the atan only on base of the real part of the numbers and ignored
        // the imaginary.
        'BigNumber, BigNumber': (y, x)=>BigNumber.atan2(y, x)
    }, matrixAlgorithmSuite({
        scalar: 'number | BigNumber',
        SS: matAlgo09xS0Sf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBitAnd": (()=>createBitAnd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'bitAnd';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'concat'
];
var createBitAnd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Bitwise AND two values, `x & y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitAnd(x, y)
   *
   * Examples:
   *
   *    math.bitAnd(53, 131)               // returns number 1
   *
   *    math.bitAnd([1, 12, 31], 42)       // returns Array [0, 8, 10]
   *
   * See also:
   *
   *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x First value to and
   * @param  {number | BigNumber | bigint | Array | Matrix} y Second value to and
   * @return {number | BigNumber | bigint | Array | Matrix} AND of `x` and `y`
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitAndNumber"],
        'BigNumber, BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitAndBigNumber"],
        'bigint, bigint': (x, y)=>x & y
    }, matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/bitOr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBitOr": (()=>createBitOr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'bitOr';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'DenseMatrix',
    'concat'
];
var createBitOr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, DenseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo04xSidSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo04xSidSid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Bitwise OR two values, `x | y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the lowest print base.
   *
   * Syntax:
   *
   *    math.bitOr(x, y)
   *
   * Examples:
   *
   *    math.bitOr(1, 2)               // returns number 3
   *
   *    math.bitOr([1, 2, 3], 4)       // returns Array [5, 6, 7]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x First value to or
   * @param  {number | BigNumber | bigint | Array | Matrix} y Second value to or
   * @return {number | BigNumber | bigint | Array | Matrix} OR of `x` and `y`
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitOrNumber"],
        'BigNumber, BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitOrBigNumber"],
        'bigint, bigint': (x, y)=>x | y
    }, matrixAlgorithmSuite({
        SS: matAlgo04xSidSid,
        DS: matAlgo01xDSid,
        Ss: matAlgo10xSids
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/bitXor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBitXor": (()=>createBitXor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'bitXor';
var dependencies = [
    'typed',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createBitXor = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Bitwise XOR two values, `x ^ y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitXor(x, y)
   *
   * Examples:
   *
   *    math.bitXor(1, 2)               // returns number 3
   *
   *    math.bitXor([2, 3, 4], 4)       // returns Array [6, 7, 0]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | bigint | Array | Matrix} x First value to xor
   * @param  {number | BigNumber | bigint | Array | Matrix} y Second value to xor
   * @return {number | BigNumber | bigint | Array | Matrix} XOR of `x` and `y`
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitXorNumber"],
        'BigNumber, BigNumber': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitXor"],
        'bigint, bigint': (x, y)=>x ^ y
    }, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCbrt": (()=>createCbrt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
var name = 'cbrt';
var dependencies = [
    'config',
    'typed',
    'isNegative',
    'unaryMinus',
    'matrix',
    'Complex',
    'BigNumber',
    'Fraction'
];
var createCbrt = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, isNegative, unaryMinus, matrix, Complex, BigNumber, Fraction } = _ref;
    /**
   * Calculate the cubic root of a value.
   *
   * To avoid confusion with the matrix cube root, this function does not
   * apply to matrices. For a matrix, to take the cube root elementwise,
   * see the examples.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27)                  // returns 3
   *    math.cube(3)                   // returns 27
   *    math.cbrt(-64)                 // returns -4
   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
   *    math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]
   *
   *    const x = math.complex('8i')
   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true)             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the cubic root of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cbrtNumber"],
        // note: signature 'number, boolean' is also supported,
        //       created by typed as it knows how to convert number to Complex
        Complex: _cbrtComplex,
        'Complex, boolean': _cbrtComplex,
        BigNumber: function BigNumber(x) {
            return x.cbrt();
        },
        Unit: _cbrtUnit
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
   * @private
   */ function _cbrtComplex(x, allRoots) {
        // https://www.wikiwand.com/en/Cube_root#/Complex_numbers
        var arg3 = x.arg() / 3;
        var abs = x.abs();
        // principal root:
        var principal = new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3).exp());
        if (allRoots) {
            var all = [
                principal,
                new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()),
                new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())
            ];
            return config.matrix === 'Array' ? all : matrix(all);
        } else {
            return principal;
        }
    }
    /**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */ function _cbrtUnit(x) {
        if (x.value && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isComplex"])(x.value)) {
            var result = x.clone();
            result.value = 1.0;
            result = result.pow(1.0 / 3); // Compute the units
            result.value = _cbrtComplex(x.value); // Compute the value
            return result;
        } else {
            var negate = isNegative(x.value);
            if (negate) {
                x.value = unaryMinus(x.value);
            }
            // TODO: create a helper function for this
            var third;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(x.value)) {
                third = new BigNumber(1).div(3);
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFraction"])(x.value)) {
                third = new Fraction(1, 3);
            } else {
                third = 1 / 3;
            }
            var _result = x.pow(third);
            if (negate) {
                _result.value = unaryMinus(_result.value);
            }
            return _result;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/compare.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCompare": (()=>createCompare),
    "createCompareNumber": (()=>createCompareNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'compare';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'equalScalar',
    'BigNumber',
    'Fraction',
    'DenseMatrix',
    'concat'
];
var createCompare = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, equalScalar, matrix, BigNumber, Fraction, DenseMatrix, concat } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * x and y are considered equal when the relative difference between x and y
   * is smaller than the configured absTol and relTol. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.compare(x, y)
   *
   * Examples:
   *
   *    math.compare(6, 1)           // returns 1
   *    math.compare(2, 3)           // returns -1
   *    math.compare(7, 7)           // returns 0
   *    math.compare('10', '2')      // returns 1
   *    math.compare('1000', '1e3')  // returns 0
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('40 mm')
   *    math.compare(a, b)           // returns 1
   *
   *    math.compare(2, [1, 2, 3])   // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, largerEq, compareNatural, compareText
   *
   * @param  {number | BigNumber | bigint | Fraction | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | Fraction | Unit | string | Array | Matrix} y Second value to compare
   * @return {number | BigNumber | bigint | Fraction | Array | Matrix} Returns the result of the comparison:
   *                                                          1 when x > y, -1 when x < y, and 0 when x == y.
   */ return typed(name, createCompareNumber({
        typed,
        config
    }), {
        'boolean, boolean': function boolean_boolean(x, y) {
            return x === y ? 0 : x > y ? 1 : -1;
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol) ? new BigNumber(0) : new BigNumber(x.cmp(y));
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x === y ? 0n : x > y ? 1n : -1n;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return new Fraction(x.compare(y));
        },
        'Complex, Complex': function Complex_Complex() {
            throw new TypeError('No ordering relation is defined for complex numbers');
        }
    }, compareUnits, matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createCompareNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol) ? 0 : x > y ? 1 : -1;
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/compareText.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCompareText": (()=>createCompareText),
    "createCompareTextNumber": (()=>createCompareTextNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
var name = 'compareText';
var dependencies = [
    'typed',
    'matrix',
    'concat'
];
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compareText"].signature = 'any, any';
var createCompareText = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, concat } = _ref;
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Compare two strings lexically. Comparison is case sensitive.
   * Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.compareText(x, y)
   *
   * Examples:
   *
   *    math.compareText('B', 'A')     // returns 1
   *    math.compareText('2', '10')    // returns 1
   *    math.compare('2', '10')        // returns -1
   *    math.compareNatural('2', '10') // returns -1
   *
   *    math.compareText('B', ['A', 'B', 'C']) // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, equalText, compare, compareNatural
   *
   * @param  {string | Array | DenseMatrix} x First string to compare
   * @param  {string | Array | DenseMatrix} y Second string to compare
   * @return {number | Array | DenseMatrix} Returns the result of the comparison:
   *                                        1 when x > y, -1 when x < y, and 0 when x == y.
   */ return typed(name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compareText"], matrixAlgorithmSuite({
        elop: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compareText"],
        Ds: true
    }));
});
var createCompareTextNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed'
], (_ref2)=>{
    var { typed } = _ref2;
    return typed(name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compareText"]);
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/count.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCount": (()=>createCount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'count';
var dependencies = [
    'typed',
    'size',
    'prod'
];
var createCount = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, prod } = _ref;
    /**
   * Count the number of elements of a matrix, array or string.
   *
   * Syntax:
   *
   *     math.count(x)
   *
   * Examples:
   *
   *     math.count('hello world')        // returns 11
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.count(A)                    // returns 6
   *     math.count(math.range(1,6))      // returns 5
   *
   * See also:
   *
   *     size
   *
   * @param {string | Array | Matrix} x  A matrix or string
   * @return {number} An integer with the elements in `x`.
   */ return typed(name, {
        string: function string(x) {
            return x.length;
        },
        'Matrix | Array': function Matrix__Array(x) {
            return prod(size(x));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/deepEqual.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDeepEqual": (()=>createDeepEqual)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'deepEqual';
var dependencies = [
    'typed',
    'equal'
];
var createDeepEqual = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equal } = _ref;
    /**
   * Test element wise whether two matrices are equal.
   * The function accepts both matrices and scalar values.
   *
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.deepEqual(x, y)
   *
   * Examples:
   *
   *    math.deepEqual(2, 4)   // returns false
   *
   *    a = [2, 5, 1]
   *    b = [2, 7, 1]
   *
   *    math.deepEqual(a, b)   // returns false
   *    math.equal(a, b)       // returns [true, false, true]
   *
   * See also:
   *
   *    equal, unequal
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns true when the input matrices have the same size and each of their elements is equal.
   */ return typed(name, {
        'any, any': function any_any(x, y) {
            return _deepEqual(x.valueOf(), y.valueOf());
        }
    });
    "TURBOPACK unreachable";
    /**
   * Test whether two arrays have the same size and all elements are equal
   * @param {Array | *} x
   * @param {Array | *} y
   * @return {boolean} Returns true if both arrays are deep equal
   */ function _deepEqual(x, y) {
        if (Array.isArray(x)) {
            if (Array.isArray(y)) {
                var len = x.length;
                if (len !== y.length) {
                    return false;
                }
                for(var i = 0; i < len; i++){
                    if (!_deepEqual(x[i], y[i])) {
                        return false;
                    }
                }
                return true;
            } else {
                return false;
            }
        } else {
            if (Array.isArray(y)) {
                return false;
            } else {
                return equal(x, y);
            }
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDivideScalar": (()=>createDivideScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'divideScalar';
var dependencies = [
    'typed',
    'numeric'
];
var createDivideScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, numeric } = _ref;
    /**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Quotient, `x / y`
   * @private
   */ return typed(name, {
        'number, number': function number_number(x, y) {
            return x / y;
        },
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.div(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.div(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x / y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.div(y);
        },
        'Unit, number | Complex | Fraction | BigNumber | Unit': (x, y)=>x.divide(y),
        'number | Fraction | Complex | BigNumber, Unit': (x, y)=>y.divideInto(x)
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotDivide": (()=>createDotDivide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'dotDivide';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'divideScalar',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createDotDivide = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, divideScalar, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4)   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: divideScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/equalText.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEqualText": (()=>createEqualText)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'equalText';
var dependencies = [
    'typed',
    'compareText',
    'isZero'
];
var createEqualText = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, compareText, isZero } = _ref;
    /**
   * Check equality of two strings. Comparison is case sensitive.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.equalText(x, y)
   *
   * Examples:
   *
   *    math.equalText('Hello', 'Hello')     // returns true
   *    math.equalText('a', 'A')             // returns false
   *    math.equal('2e3', '2000')            // returns true
   *    math.equalText('2e3', '2000')        // returns false
   *
   *    math.equalText('B', ['A', 'B', 'C']) // returns [false, true, false]
   *
   * See also:
   *
   *    equal, compareText, compare, compareNatural
   *
   * @param  {string | Array | DenseMatrix} x First string to compare
   * @param  {string | Array | DenseMatrix} y Second string to compare
   * @return {number | Array | DenseMatrix} Returns true if the values are equal, and false if not.
   */ return typed(name, {
        'any, any': function any_any(x, y) {
            return isZero(compareText(x, y));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/floor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFloor": (()=>createFloor),
    "createFloorNumber": (()=>createFloorNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decimal.js/decimal.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'floor';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var bigTen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](10);
var createFloorNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config',
    'round'
], (_ref)=>{
    var { typed, config, round } = _ref;
    function _floorNumber(x) {
        // First, if the floor and the round are identical we can be
        // quite comfortable that is the best answer:
        var f = Math.floor(x);
        var r = round(x);
        if (f === r) return f;
        // OK, they are different. If x is truly distinct from f but
        // appears indistinguishable from r, presume it really is just
        // the integer r with rounding/computation error, and return that
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, r, config.relTol, config.absTol) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, f, config.relTol, config.absTol)) {
            return r;
        }
        // Otherwise (x distinct from both r and f, or indistinguishable from
        // both r and f) may as well just return f, as that's the best
        // candidate we can discern:
        return f;
    }
    return typed(name, {
        number: _floorNumber,
        'number, number': function number_number(x, n) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(n)) {
                throw new RangeError('number of decimals in function floor must be an integer');
            }
            if (n < 0 || n > 15) {
                throw new RangeError('number of decimals in floor number must be in range 0 - 15');
            }
            var shift = 10 ** n;
            return _floorNumber(x * shift) / shift;
        }
    });
});
var createFloor = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var floorNumber = createFloorNumber({
        typed,
        config,
        round
    });
    function _bigFloor(x) {
        // see _floorNumber above for rationale
        var bne = (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(a, b, config.relTol, config.absTol);
        var f = x.floor();
        var r = round(x);
        if (f.eq(r)) return f;
        if (bne(x, r) && !bne(x, f)) return r;
        return f;
    }
    /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *    math.floor(x, n)
   *    math.floor(unit, valuelessUnit)
   *    math.floor(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.floor(3.2)              // returns number 3
   *    math.floor(3.8)              // returns number 3
   *    math.floor(-4.2)             // returns number -5
   *    math.floor(-4.7)             // returns number -5
   *
   *    math.floor(3.212, 2)          // returns number 3.21
   *    math.floor(3.288, 2)          // returns number 3.28
   *    math.floor(-4.212, 2)         // returns number -4.22
   *    math.floor(-4.782, 2)         // returns number -4.79
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.floor(c)                 // returns Complex 3 - 3i
   *    math.floor(c, 1)              // returns Complex 3.2 -2.8i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.floor(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.floor(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]
   *    math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]
   *
   *    math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]
   *
   *    // Note that floor(array, array) currently not implemented.
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('floor', {
        number: floorNumber.signatures.number,
        'number,number': floorNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return x.floor();
        },
        'Complex, number': function Complex_number(x, n) {
            return x.floor(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            return x.floor(n.toNumber());
        },
        BigNumber: _bigFloor,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            var shift = bigTen.pow(n);
            return _bigFloor(x.mul(shift)).div(shift);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.floor();
        },
        'Fraction, number': function Fraction_number(x, n) {
            return x.floor(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            return x.floor(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since floor(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since floor(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/mod.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMod": (()=>createMod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$floor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/arithmetic/floor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'mod';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix',
    'concat'
];
var createMod = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix, concat } = _ref;
    var floor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$floor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createFloor"])({
        typed,
        config,
        round,
        matrix,
        equalScalar,
        zeros,
        DenseMatrix
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See https://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3)                // returns 2
   *    math.mod(11, 2)               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0
   *    }
   *
   *    isOdd(2)                      // returns false
   *    isOdd(3)                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | bigint | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */ return typed(name, {
        'number, number': _modNumber,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return y.isZero() ? x : x.sub(y.mul(floor(x.div(y))));
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            if (y === 0n) {
                return x;
            }
            if (x < 0) {
                var m = x % y;
                return m === 0n ? m : m + y;
            }
            return x % y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return y.equals(0) ? x : x.sub(y.mul(floor(x.div(y))));
        }
    }, matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
    "TURBOPACK unreachable";
    /**
  * Calculate the modulus of two numbers
  * @param {number} x
  * @param {number} y
  * @returns {number} res
  * @private
  */ function _modNumber(x, y) {
        // We don't use JavaScript's % operator here as this doesn't work
        // correctly for x < 0 and x === 0
        // see https://en.wikipedia.org/wiki/Modulo_operation
        // We use mathjs floor to handle errors associated with
        // precision float approximation
        return y === 0 ? x : x - y * floor(x / y);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/gcd.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createGcd": (()=>createGcd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$mod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/arithmetic/mod.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/ArgumentsError.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'gcd';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'BigNumber',
    'DenseMatrix',
    'concat'
];
var gcdTypes = 'number | BigNumber | Fraction | Matrix | Array';
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
    return !array.some((element)=>Array.isArray(element));
}
var createGcd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, config, round, equalScalar, zeros, BigNumber, DenseMatrix, concat } = _ref;
    var mod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$mod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMod"])({
        typed,
        config,
        round,
        matrix,
        equalScalar,
        zeros,
        DenseMatrix,
        concat
    });
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo04xSidSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo04xSidSid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12)              // returns 4
   *    math.gcd(-4, 6)              // returns 2
   *    math.gcd(25, 15, -10)        // returns 5
   *
   *    math.gcd([8, -4], [12, 6])   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */ return typed(name, {
        'number, number': _gcdNumber,
        'BigNumber, BigNumber': _gcdBigNumber,
        'Fraction, Fraction': (x, y)=>x.gcd(y)
    }, matrixAlgorithmSuite({
        SS: matAlgo04xSidSid,
        DS: matAlgo01xDSid,
        Ss: matAlgo10xSids
    }), {
        [gcdManyTypesSignature]: typed.referToSelf((self)=>(a, b, args)=>{
                var res = self(a, b);
                for(var i = 0; i < args.length; i++){
                    res = self(res, args[i]);
                }
                return res;
            }),
        Array: typed.referToSelf((self)=>(array)=>{
                if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
                    return self(...array[0]);
                }
                if (is1d(array)) {
                    return self(...array);
                }
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ArgumentsError"]('gcd() supports only 1d matrices!');
            }),
        Matrix: typed.referToSelf((self)=>(matrix)=>{
                return self(matrix.toArray());
            })
    });
    "TURBOPACK unreachable";
    /**
  * Calculate gcd for numbers
  * @param {number} a
  * @param {number} b
  * @returns {number} Returns the greatest common denominator of a and b
  * @private
  */ function _gcdNumber(a, b) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(a) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(b)) {
            throw new Error('Parameters in function gcd must be integer numbers');
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        var r;
        while(b !== 0){
            r = mod(a, b);
            a = b;
            b = r;
        }
        return a < 0 ? -a : a;
    }
    /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */ function _gcdBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function gcd must be integer numbers');
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        var zero = new BigNumber(0);
        while(!b.isZero()){
            var r = mod(a, b);
            a = b;
            b = r;
        }
        return a.lt(zero) ? a.neg() : a;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createHasNumericValue": (()=>createHasNumericValue)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'hasNumericValue';
var dependencies = [
    'typed',
    'isNumeric'
];
var createHasNumericValue = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isNumeric } = _ref;
    /**
   * Test whether a value is an numeric value.
   *
   * In case of a string, true is returned if the string contains a numeric value.
   *
   * Syntax:
   *
   *     math.hasNumericValue(x)
   *
   * Examples:
   *
   *    math.hasNumericValue(2)                     // returns true
   *    math.hasNumericValue('2')                   // returns true
   *    math.isNumeric('2')                         // returns false
   *    math.hasNumericValue(0)                     // returns true
   *    math.hasNumericValue(math.bignumber('500')) // returns true
   *    math.hasNumericValue(math.bigint('42'))     // returns true
   *    math.hasNumericValue(42n)                   // returns true
   *    math.hasNumericValue(math.fraction(4))      // returns true
   *    math.hasNumericValue(math.complex('2-4i'))  // returns false
   *    math.hasNumericValue(false)                 // returns true
   *    math.hasNumericValue([2.3, 'foo', false])   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger, isNumeric
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, `Boolean`, or a `String` containing number. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */ return typed(name, {
        boolean: ()=>true,
        string: function string(x) {
            return x.trim().length > 0 && !isNaN(Number(x));
        },
        any: function any(x) {
            return isNumeric(x);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/hypot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createHypot": (()=>createHypot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
var name = 'hypot';
var dependencies = [
    'typed',
    'abs',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'sqrt',
    'smaller',
    'isPositive'
];
var createHypot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, addScalar, divideScalar, multiplyScalar, sqrt, smaller, isPositive } = _ref;
    /**
   * Calculate the hypotenuse of a list with values. The hypotenuse is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenuse is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4)      // 5
   *     math.hypot(3, 4, 5)   // 7.0710678118654755
   *     math.hypot([3, 4, 5]) // 7.0710678118654755
   *     math.hypot(-2)        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.
   *                                                          Matrix and Array input is flattened and returns a
   *                                                          single number for the whole matrix.
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */ return typed(name, {
        '... number | BigNumber': _hypot,
        Array: _hypot,
        Matrix: (M)=>_hypot((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(M.toArray(), true))
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the hypotenuse for an Array with values
   * @param {Array.<number | BigNumber>} args
   * @return {number | BigNumber} Returns the result
   * @private
   */ function _hypot(args) {
        // code based on `hypot` from es6-shim:
        // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
        var result = 0;
        var largest = 0;
        for(var i = 0; i < args.length; i++){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isComplex"])(args[i])) {
                throw new TypeError('Unexpected type of argument to hypot');
            }
            var value = abs(args[i]);
            if (smaller(largest, value)) {
                result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
                result = addScalar(result, 1);
                largest = value;
            } else {
                result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
            }
        }
        return multiplyScalar(largest, sqrt(result));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/larger.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLarger": (()=>createLarger),
    "createLargerNumber": (()=>createLargerNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'larger';
var dependencies = [
    'typed',
    'config',
    'bignumber',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createLarger = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, bignumber, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured relTol and absTol. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3)             // returns false
   *    math.larger(5, 2 + 2)         // returns true
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('2 inch')
   *    math.larger(a, b)             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */ function bignumLarger(x, y) {
        return x.gt(y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
    }
    return typed(name, createLargerNumber({
        typed,
        config
    }), {
        'boolean, boolean': (x, y)=>x > y,
        'BigNumber, BigNumber': bignumLarger,
        'bigint, bigint': (x, y)=>x > y,
        'Fraction, Fraction': (x, y)=>x.compare(y) === 1,
        'Fraction, BigNumber': function Fraction_BigNumber(x, y) {
            return bignumLarger(bignumber(x), y);
        },
        'BigNumber, Fraction': function BigNumber_Fraction(x, y) {
            return bignumLarger(x, bignumber(y));
        },
        'Complex, Complex': function Complex_Complex() {
            throw new TypeError('No ordering relation is defined for complex numbers');
        }
    }, compareUnits, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createLargerNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return x > y && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog": (()=>createLog)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
var name = 'log';
var dependencies = [
    'config',
    'typed',
    'typeOf',
    'divideScalar',
    'Complex'
];
var nlg16 = Math.log(16);
var createLog = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, typeOf, config, divideScalar, Complex } = _ref;
    /**
   * Calculate the logarithm of a value.
   *
   * To avoid confusion with the matrix logarithm, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5)                  // returns 1.252762968495368
   *    math.exp(math.log(2.4))        // returns 2.4
   *
   *    math.pow(10, 4)                // returns 10000
   *    math.log(10000, 10)            // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *
   *    math.log(1024, 2)              // returns 10
   *    math.pow(2, 10)                // returns 1024
   *
   * See also:
   *
   *    exp, log2, log10, log1p
   *
   * @param {number | BigNumber | Fraction | Complex} x
   *            Value for which to calculate the logarithm.
   * @param {number | BigNumber | Fraction | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {number | BigNumber | Fraction | Complex}
   *            Returns the logarithm of `x`
   */ function complexLog(c) {
        return c.log();
    }
    function complexLogNumber(x) {
        return complexLog(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logNumber"])(x);
            } else {
                // negative value -> complex value computation
                return complexLogNumber(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["promoteLogarithm"])(nlg16, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logNumber"], config, complexLogNumber),
        Complex: complexLog,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.ln();
            } else {
                // downgrade to number, return Complex valued result
                return complexLogNumber(x.toNumber());
            }
        },
        'any, any': typed.referToSelf((self)=>(x, base)=>{
                // calculate logarithm for a specified base, log(x, base)
                if (typeOf(x) === 'Fraction' && typeOf(base) === 'Fraction') {
                    var result = x.log(base);
                    if (result !== null) {
                        return result;
                    }
                }
                return divideScalar(self(x), self(base));
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSolveValidation": (()=>createSolveValidation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
;
;
;
function createSolveValidation(_ref) {
    var { DenseMatrix } = _ref;
    /**
   * Validates matrix and column vector b for backward/forward substitution algorithms.
   *
   * @param {Matrix} m            An N x N matrix
   * @param {Array | Matrix} b    A column vector
   * @param {Boolean} copy        Return a copy of vector b
   *
   * @return {DenseMatrix}        Dense column vector b
   */ return function solveValidation(m, b, copy) {
        var mSize = m.size();
        if (mSize.length !== 2) {
            throw new RangeError('Matrix must be two dimensional (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(mSize) + ')');
        }
        var rows = mSize[0];
        var columns = mSize[1];
        if (rows !== columns) {
            throw new RangeError('Matrix must be square (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(mSize) + ')');
        }
        var data = [];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(b)) {
            var bSize = b.size();
            var bdata = b._data;
            // 1-dim vector
            if (bSize.length === 1) {
                if (bSize[0] !== rows) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var i = 0; i < rows; i++){
                    data[i] = [
                        bdata[i]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ],
                    datatype: b._datatype
                });
            }
            // 2-dim column
            if (bSize.length === 2) {
                if (bSize[0] !== rows || bSize[1] !== 1) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDenseMatrix"])(b)) {
                    if (copy) {
                        data = [];
                        for(var _i = 0; _i < rows; _i++){
                            data[_i] = [
                                bdata[_i][0]
                            ];
                        }
                        return new DenseMatrix({
                            data,
                            size: [
                                rows,
                                1
                            ],
                            datatype: b._datatype
                        });
                    }
                    return b;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(b)) {
                    for(var _i2 = 0; _i2 < rows; _i2++){
                        data[_i2] = [
                            0
                        ];
                    }
                    var values = b._values;
                    var index = b._index;
                    var ptr = b._ptr;
                    for(var k1 = ptr[1], k = ptr[0]; k < k1; k++){
                        var _i3 = index[k];
                        data[_i3][0] = values[k];
                    }
                    return new DenseMatrix({
                        data,
                        size: [
                            rows,
                            1
                        ],
                        datatype: b._datatype
                    });
                }
            }
            throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isArray"])(b)) {
            var bsize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(b);
            if (bsize.length === 1) {
                if (bsize[0] !== rows) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var _i4 = 0; _i4 < rows; _i4++){
                    data[_i4] = [
                        b[_i4]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ]
                });
            }
            if (bsize.length === 2) {
                if (bsize[0] !== rows || bsize[1] !== 1) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var _i5 = 0; _i5 < rows; _i5++){
                    data[_i5] = [
                        b[_i5][0]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ]
                });
            }
            throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLsolve": (()=>createLsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)");
;
;
var name = 'lsolve';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createLsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolve(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolve(a, b)  // [[-5.5], [20]]
   *
   * See also:
   *
   *    lsolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseForwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseForwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var r = _denseForwardSubstitution(m, b);
            return r.valueOf();
        }
    });
    "TURBOPACK unreachable";
    function _denseForwardSubstitution(m, b) {
        // validate matrix and vector, return copy of column vector b
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // result
        var x = [];
        var mdata = m._data;
        // loop columns
        for(var j = 0; j < columns; j++){
            var bj = bdata[j][0] || 0;
            var xj = void 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = mdata[j][j];
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                xj = divideScalar(bj, vjj);
                // loop rows
                for(var i = j + 1; i < rows; i++){
                    bdata[i] = [
                        subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
                    ];
                }
            } else {
                // degenerate row, we can choose any value
                xj = 0;
            }
            x[j] = [
                xj
            ];
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
    function _sparseForwardSubstitution(m, b) {
        // validate matrix and vector, return copy of column vector b
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // result
        var x = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            var bj = bdata[j][0] || 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = 0;
                // matrix values & indices (column j)
                var jValues = [];
                var jIndices = [];
                // first and last index in the column
                var firstIndex = ptr[j];
                var lastIndex = ptr[j + 1];
                // values in column, find value at [j, j]
                for(var k = firstIndex; k < lastIndex; k++){
                    var i = index[k];
                    // check row (rows are not sorted!)
                    if (i === j) {
                        vjj = values[k];
                    } else if (i > j) {
                        // store lower triangular
                        jValues.push(values[k]);
                        jIndices.push(i);
                    }
                }
                // at this point we must have a value in vjj
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                var xj = divideScalar(bj, vjj);
                for(var _k = 0, l = jIndices.length; _k < l; _k++){
                    var _i = jIndices[_k];
                    bdata[_i] = [
                        subtractScalar(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))
                    ];
                }
                x[j] = [
                    xj
                ];
            } else {
                // degenerate row, we can choose any value
                x[j] = [
                    0
                ];
            }
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrixFromColumns": (()=>createMatrixFromColumns)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'matrixFromColumns';
var dependencies = [
    'typed',
    'matrix',
    'flatten',
    'size'
];
var createMatrixFromColumns = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, flatten, size } = _ref;
    /**
   * Create a dense matrix from vectors as individual columns.
   * If you pass row vectors, they will be transposed (but not conjugated!)
   *
   * Syntax:
   *
   *    math.matrixFromColumns(...arr)
   *    math.matrixFromColumns(col1, col2)
   *    math.matrixFromColumns(col1, col2, col3)
   *
   * Examples:
   *
   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
   *    math.matrixFromColumns(...vectors)
   *
   * See also:
   *
   *    matrix, matrixFromRows, matrixFromFunction, zeros
   *
   * @param {... Array | Matrix} cols Multiple columns
   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
   */ return typed(name, {
        '...Array': function Array(arr) {
            return _createArray(arr);
        },
        '...Matrix': function Matrix(arr) {
            return matrix(_createArray(arr.map((m)=>m.toArray())));
        }
    });
    "TURBOPACK unreachable";
    function _createArray(arr) {
        if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');
        var N = checkVectorTypeAndReturnLength(arr[0]);
        // create an array with empty rows
        var result = [];
        for(var i = 0; i < N; i++){
            result[i] = [];
        }
        // loop columns
        for (var col of arr){
            var colLength = checkVectorTypeAndReturnLength(col);
            if (colLength !== N) {
                throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));
            }
            var f = flatten(col);
            // push a value to each row
            for(var _i = 0; _i < N; _i++){
                result[_i].push(f[_i]);
            }
        }
        return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
        var s = size(vec);
        if (s.length === 1) {
            // 1D vector
            return s[0];
        } else if (s.length === 2) {
            // 2D vector
            if (s[0] === 1) {
                // row vector
                return s[1];
            } else if (s[1] === 1) {
                // col vector
                return s[0];
            } else {
                throw new TypeError('At least one of the arguments is not a vector.');
            }
        } else {
            throw new TypeError('Only one- or two-dimensional vectors are supported.');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/max.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMax": (()=>createMax)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'max';
var dependencies = [
    'typed',
    'config',
    'numeric',
    'larger',
    'isNaN'
];
var createMax = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, numeric, larger, isNaN: mathIsNaN } = _ref;
    /**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multidimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dimension)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3)                  // returns 4
   *     math.max([2, 1, 4, 3])                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0) // returns [4, 7]
   *     math.max([[2, 5], [4, 3], [1, 7]], 1) // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */ return typed(name, {
        // max([a, b, c, d, ...])
        'Array | Matrix': _max,
        // max([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': function Array__Matrix_number__BigNumber(array, dim) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reduce"])(array, dim.valueOf(), _largest);
        },
        // max(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('Scalar values expected in function max');
            }
            return _max(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Return the largest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is largest, or y when y is largest
   * @private
   */ function _largest(x, y) {
        try {
            return larger(x, y) ? x : y;
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'max', y);
        }
    }
    /**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {number} max
   * @private
   */ function _max(array) {
        var res;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                if (mathIsNaN(value)) {
                    res = value;
                } else if (res === undefined || larger(value, res)) {
                    res = value;
                }
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'max', value);
            }
        });
        if (res === undefined) {
            throw new Error('Cannot calculate max of an empty array');
        }
        // make sure returning numeric value: parse a string into a numeric value
        if (typeof res === 'string') {
            res = numeric(res, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNumberType"])(res, config));
        }
        return res;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/min.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMin": (()=>createMin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'min';
var dependencies = [
    'typed',
    'config',
    'numeric',
    'smaller',
    'isNaN'
];
var createMin = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, numeric, smaller, isNaN: mathIsNaN } = _ref;
    /**
   * Compute the minimum value of a matrix or a  list of values.
   * In case of a multidimensional array, the minimum of the flattened array
   * will be calculated. When `dim` is provided, the minimum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.min(a, b, c, ...)
   *     math.min(A)
   *     math.min(A, dimension)
   *
   * Examples:
   *
   *     math.min(2, 1, 4, 3)                  // returns 1
   *     math.min([2, 1, 4, 3])                // returns 1
   *
   *     // minimum over a specified dimension (zero-based)
   *     math.min([[2, 5], [4, 3], [1, 7]], 0) // returns [1, 3]
   *     math.min([[2, 5], [4, 3], [1, 7]], 1) // returns [2, 3, 1]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
   *
   * See also:
   *
   *    mean, median, max, prod, std, sum, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The minimum value
   */ return typed(name, {
        // min([a, b, c, d, ...])
        'Array | Matrix': _min,
        // min([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': function Array__Matrix_number__BigNumber(array, dim) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reduce"])(array, dim.valueOf(), _smallest);
        },
        // min(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('Scalar values expected in function min');
            }
            return _min(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Return the smallest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is smallest, or y when y is smallest
   * @private
   */ function _smallest(x, y) {
        try {
            return smaller(x, y) ? x : y;
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'min', y);
        }
    }
    /**
   * Recursively calculate the minimum value in an n-dimensional array
   * @param {Array} array
   * @return {number} min
   * @private
   */ function _min(array) {
        var min;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                if (mathIsNaN(value)) {
                    min = value;
                } else if (min === undefined || smaller(value, min)) {
                    min = value;
                }
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'min', value);
            }
        });
        if (min === undefined) {
            throw new Error('Cannot calculate min of an empty array');
        }
        // make sure returning numeric value: parse a string into a numeric value
        if (typeof min === 'string') {
            min = numeric(min, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNumberType"])(min, config));
        }
        return min;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNthRoots": (()=>createNthRoots)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'nthRoots';
var dependencies = [
    'config',
    'typed',
    'divideScalar',
    'Complex'
];
var createNthRoots = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, divideScalar, Complex } = _ref;
    /**
   * Each function here returns a real multiple of i as a Complex value.
   * @param  {number} val
   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3
   */ // This is used to fix float artifacts for zero-valued components.
    var _calculateExactResult = [
        function realPos(val) {
            return new Complex(val, 0);
        },
        function imagPos(val) {
            return new Complex(0, val);
        },
        function realNeg(val) {
            return new Complex(-val, 0);
        },
        function imagNeg(val) {
            return new Complex(0, -val);
        }
    ];
    /**
   * Calculate the nth root of a Complex Number a using De Movire's Theorem.
   * @param  {Complex} a
   * @param  {number} root
   * @return {Array} array of n Complex Roots
   */ function _nthComplexRoots(a, root) {
        if (root < 0) throw new Error('Root must be greater than zero');
        if (root === 0) throw new Error('Root must be non-zero');
        if (root % 1 !== 0) throw new Error('Root must be an integer');
        if (a === 0 || a.abs() === 0) return [
            new Complex(0, 0)
        ];
        var aIsNumeric = typeof a === 'number';
        var offset;
        // determine the offset (argument of a)/(pi/2)
        if (aIsNumeric || a.re === 0 || a.im === 0) {
            if (aIsNumeric) {
                offset = 2 * +(a < 0); // numeric value on the real axis
            } else if (a.im === 0) {
                offset = 2 * +(a.re < 0); // complex value on the real axis
            } else {
                offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis
            }
        }
        var arg = a.arg();
        var abs = a.abs();
        var roots = [];
        var r = Math.pow(abs, 1 / root);
        for(var k = 0; k < root; k++){
            var halfPiFactor = (offset + 4 * k) / root;
            /**
       * If (offset + 4*k)/root is an integral multiple of pi/2
       * then we can produce a more exact result.
       */ if (halfPiFactor === Math.round(halfPiFactor)) {
                roots.push(_calculateExactResult[halfPiFactor % 4](r));
                continue;
            }
            roots.push(new Complex({
                r,
                phi: (arg + 2 * Math.PI * k) / root
            }));
        }
        return roots;
    }
    /**
   * Calculate the nth roots of a value.
   * An nth root of a positive real number A,
   * is a positive real solution of the equation "x^root = A".
   * This function returns an array of complex values.
   *
   * Syntax:
   *
   *    math.nthRoots(x)
   *    math.nthRoots(x, root)
   *
   * Examples:
   *
   *    math.nthRoots(1)
   *    // returns [
   *    //   {re: 1, im: 0},
   *    //   {re: -1, im: 0}
   *    // ]
   *    math.nthRoots(1, 3)
   *    // returns [
   *    //   { re: 1, im: 0 },
   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },
   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }
   *    // ]
   *
   * See also:
   *
   *    nthRoot, pow, sqrt
   *
   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded
   * @param {number} [root=2] Optional root, default value is 2
   * @return {number | BigNumber | Fraction | Complex} Returns the nth roots
   */ return typed(name, {
        Complex: function Complex(x) {
            return _nthComplexRoots(x, 2);
        },
        'Complex, number': _nthComplexRoots
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/logical/nullish.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNullish": (()=>createNullish)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo13xDD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'nullish';
var dependencies = [
    'typed',
    'matrix',
    'size',
    'flatten',
    'deepEqual'
];
var createNullish = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, size, flatten, deepEqual } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var matAlgo13xDD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo13xDD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo13xDD"])({
        typed
    });
    /**
   * Nullish coalescing operator (??). Returns the right-hand side operand
   * when the left-hand side operand is null or undefined, and otherwise
   * returns the left-hand side operand.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.nullish(x, y)
   *
   * Examples:
   *
   *    math.nullish(null, 42)        // returns 42
   *    math.nullish(undefined, 42)   // returns 42
   *    math.nullish(0, 42)           // returns 0
   *    math.nullish(false, 42)       // returns false
   *    math.nullish('', 42)          // returns ''
   *
   *    // Object property access with fallback
   *    const obj = {foo: 7, bar: 3}
   *    math.nullish(obj.baz, 0)      // returns 0
   *
   * See also:
   *
   *    and, or, not
   *
   * @param  {*} x First value to check
   * @param  {*} y Fallback value
   * @return {*} Returns y when x is null or undefined, otherwise returns x
   */ return typed(name, {
        // Scalar and SparseMatrix-first short-circuit handlers
        'number|bigint|Complex|BigNumber|Fraction|Unit|string|boolean|SparseMatrix, any': (x, _y)=>x,
        'null, any': (_x, y)=>y,
        'undefined, any': (_x, y)=>y,
        // SparseMatrix-first with collection RHS: enforce exact shape match
        'SparseMatrix, Array | Matrix': (x, y)=>{
            var sx = flatten(size(x).valueOf()); // work around #3529/#3530
            var sy = flatten(size(y).valueOf());
            if (deepEqual(sx, sy)) return x;
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](sx, sy);
        },
        // DenseMatrix-first handlers (no broadcasting between collections)
        'DenseMatrix, DenseMatrix': typed.referToSelf((self)=>(x, y)=>matAlgo13xDD(x, y, self)),
        'DenseMatrix, SparseMatrix': typed.referToSelf((self)=>(x, y)=>matAlgo03xDSf(x, y, self, false)),
        'DenseMatrix, Array': typed.referToSelf((self)=>(x, y)=>matAlgo13xDD(x, matrix(y), self)),
        'DenseMatrix, any': typed.referToSelf((self)=>(x, y)=>matAlgo14xDs(x, y, self, false)),
        // Array-first handlers (bridge via matrix() where needed)
        'Array, Array': typed.referToSelf((self)=>(x, y)=>matAlgo13xDD(matrix(x), matrix(y), self).valueOf()),
        'Array, DenseMatrix': typed.referToSelf((self)=>(x, y)=>matAlgo13xDD(matrix(x), y, self)),
        'Array, SparseMatrix': typed.referToSelf((self)=>(x, y)=>matAlgo03xDSf(matrix(x), y, self, false)),
        'Array, any': typed.referToSelf((self)=>(x, y)=>matAlgo14xDs(matrix(x), y, self, false).valueOf())
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/logical/or.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createOr": (()=>createOr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/logical.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'or';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'DenseMatrix',
    'concat'
];
var createOr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, DenseMatrix, concat } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.or(x, y)
   *
   * Examples:
   *
   *    math.or(2, 4)   // returns true
   *
   *    a = [2, 5, 0]
   *    b = [0, 22, 0]
   *    c = 0
   *
   *    math.or(a, b)   // returns [true, true, false]
   *    math.or(b, c)   // returns [false, true, false]
   *
   * See also:
   *
   *    and, not, xor
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["orNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
        },
        'bigint, bigint': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["orNumber"],
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>self(x.value || 0, y.value || 0))
    }, matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPartitionSelect": (()=>createPartitionSelect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'partitionSelect';
var dependencies = [
    'typed',
    'isNumeric',
    'isNaN',
    'compare'
];
var createPartitionSelect = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isNumeric, isNaN: mathIsNaN, compare } = _ref;
    var asc = compare;
    var desc = (a, b)=>-compare(a, b);
    /**
   * Partition-based selection of an array or 1D matrix.
   * Will find the kth smallest value, and mutates the input array.
   * Uses Quickselect.
   *
   * Syntax:
   *
   *    math.partitionSelect(x, k)
   *    math.partitionSelect(x, k, compare)
   *
   * Examples:
   *
   *    math.partitionSelect([5, 10, 1], 2)                               // returns 10
   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1, math.compareText)   // returns 'B'
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length
   *    }
   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'
   *
   *    // the input array is mutated
   *    arr = [5, 2, 1]
   *    math.partitionSelect(arr, 0) // returns 1, arr is now: [1, 2, 5]
   *    math.partitionSelect(arr, 1, 'desc') // returns 2, arr is now: [5, 2, 1]
   *
   * See also:
   *
   *    sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Number} k            The kth smallest value to be retrieved zero-based index
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {*} Returns the kth lowest value.
   */ return typed(name, {
        'Array | Matrix, number': function Array__Matrix_number(x, k) {
            return _partitionSelect(x, k, asc);
        },
        'Array | Matrix, number, string': function Array__Matrix_number_string(x, k, compare) {
            if (compare === 'asc') {
                return _partitionSelect(x, k, asc);
            } else if (compare === 'desc') {
                return _partitionSelect(x, k, desc);
            } else {
                throw new Error('Compare string must be "asc" or "desc"');
            }
        },
        'Array | Matrix, number, function': _partitionSelect
    });
    "TURBOPACK unreachable";
    function _partitionSelect(x, k, compare) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(k) || k < 0) {
            throw new Error('k must be a non-negative integer');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
            var size = x.size();
            if (size.length > 1) {
                throw new Error('Only one dimensional matrices supported');
            }
            return quickSelect(x.valueOf(), k, compare);
        }
        if (Array.isArray(x)) {
            return quickSelect(x, k, compare);
        }
    }
    /**
   * Quickselect algorithm.
   * Code adapted from:
   * https://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
   *
   * @param {Array} arr
   * @param {Number} k
   * @param {Function} compare
   * @private
   */ function quickSelect(arr, k, compare) {
        if (k >= arr.length) {
            throw new Error('k out of bounds');
        }
        // check for NaN values since these can cause an infinite while loop
        for(var i = 0; i < arr.length; i++){
            if (isNumeric(arr[i]) && mathIsNaN(arr[i])) {
                return arr[i]; // return NaN
            }
        }
        var from = 0;
        var to = arr.length - 1;
        // if from == to we reached the kth element
        while(from < to){
            var r = from;
            var w = to;
            var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
            // stop if the reader and writer meets
            while(r < w){
                // arr[r] >= pivot
                if (compare(arr[r], pivot) >= 0) {
                    // put the large values at the end
                    var tmp = arr[w];
                    arr[w] = arr[r];
                    arr[r] = tmp;
                    --w;
                } else {
                    // the value is smaller than the pivot, skip
                    ++r;
                }
            }
            // if we stepped up (r++) we need to step one down (arr[r] > pivot)
            if (compare(arr[r], pivot) > 0) {
                --r;
            }
            // the r pointer is on the end of the first k elements
            if (k <= r) {
                to = r;
            } else {
                from = r + 1;
            }
        }
        return arr[k];
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createQr": (()=>createQr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/extends.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'qr';
var dependencies = [
    'typed',
    'matrix',
    'zeros',
    'identity',
    'isZero',
    'equal',
    'sign',
    'sqrt',
    'conj',
    'unaryMinus',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'complex'
];
var createQr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, zeros, identity, isZero, equal, sign, sqrt, conj, unaryMinus, addScalar, divideScalar, multiplyScalar, subtractScalar, complex } = _ref;
    /**
   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
   * two matrices (`Q`, `R`) where `Q` is an
   * orthogonal matrix and `R` is an upper triangular matrix.
   *
   * Syntax:
   *
   *    math.qr(A)
   *
   * Example:
   *
   *    const m = [
   *      [1, -1,  4],
   *      [1,  4, -2],
   *      [1,  4,  2],
   *      [1,  -1, 0]
   *    ]
   *    const result = math.qr(m)
   *    // r = {
   *    //   Q: [
   *    //     [0.5, -0.5,   0.5],
   *    //     [0.5,  0.5,  -0.5],
   *    //     [0.5,  0.5,   0.5],
   *    //     [0.5, -0.5,  -0.5],
   *    //   ],
   *    //   R: [
   *    //     [2, 3,  2],
   *    //     [0, 5, -2],
   *    //     [0, 0,  4],
   *    //     [0, 0,  0]
   *    //   ]
   *    // }
   *
   * See also:
   *
   *    lup, lusolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array
   * for which to get the QR decomposition.
   *
   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
   * matrix and R: the upper triangular matrix
   */ return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typed(name, {
        DenseMatrix: function DenseMatrix(m) {
            return _denseQR(m);
        },
        SparseMatrix: function SparseMatrix(m) {
            return _sparseQR(m);
        },
        Array: function Array(a) {
            // create dense matrix from array
            var m = matrix(a);
            // lup, use matrix implementation
            var r = _denseQR(m);
            // result
            return {
                Q: r.Q.valueOf(),
                R: r.R.valueOf()
            };
        }
    }), {
        _denseQRimpl
    });
    "TURBOPACK unreachable";
    function _denseQRimpl(m) {
        // rows & columns (m x n)
        var rows = m._size[0]; // m
        var cols = m._size[1]; // n
        var Q = identity([
            rows
        ], 'dense');
        var Qdata = Q._data;
        var R = m.clone();
        var Rdata = R._data;
        // vars
        var i, j, k;
        var w = zeros([
            rows
        ], '');
        for(k = 0; k < Math.min(cols, rows); ++k){
            /*
       * **k-th Household matrix**
       *
       * The matrix I - 2*v*transpose(v)
       * x     = first column of A
       * x1    = first element of x
       * alpha = x1 / |x1| * |x|
       * e1    = tranpose([1, 0, 0, ...])
       * u     = x - alpha * e1
       * v     = u / |u|
       *
       * Household matrix = I - 2 * v * tranpose(v)
       *
       *  * Initially Q = I and R = A.
       *  * Household matrix is a reflection in a plane normal to v which
       *    will zero out all but the top right element in R.
       *  * Appplying reflection to both Q and R will not change product.
       *  * Repeat this process on the (1,1) minor to get R as an upper
       *    triangular matrix.
       *  * Reflections leave the magnitude of the columns of Q unchanged
       *    so Q remains othoganal.
       *
       */ var pivot = Rdata[k][k];
            var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
            var conjSgn = conj(sgn);
            var alphaSquared = 0;
            for(i = k; i < rows; i++){
                alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
            }
            var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
            if (!isZero(alpha)) {
                // first element in vector u
                var u1 = subtractScalar(pivot, alpha);
                // w = v * u1 / |u|    (only elements k to (rows-1) are used)
                w[k] = 1;
                for(i = k + 1; i < rows; i++){
                    w[i] = divideScalar(Rdata[i][k], u1);
                }
                // tau = - conj(u1 / alpha)
                var tau = unaryMinus(conj(divideScalar(u1, alpha)));
                var s = void 0;
                /*
         * tau and w have been choosen so that
         *
         * 2 * v * tranpose(v) = tau * w * tranpose(w)
         */ /*
         * -- calculate R = R - tau * w * tranpose(w) * R --
         * Only do calculation with rows k to (rows-1)
         * Additionally columns 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */ for(j = k; j < cols; j++){
                    s = 0.0;
                    // calculate jth element of [tranpose(w) * R]
                    for(i = k; i < rows; i++){
                        s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
                    }
                    // calculate the jth element of [tau * transpose(w) * R]
                    s = multiplyScalar(s, tau);
                    for(i = k; i < rows; i++){
                        Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
                    }
                }
                /*
         * -- calculate Q = Q - tau * Q * w * transpose(w) --
         * Q is a square matrix (rows x rows)
         * Only do calculation with columns k to (rows-1)
         * Additionally rows 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */ for(i = 0; i < rows; i++){
                    s = 0.0;
                    // calculate ith element of [Q * w]
                    for(j = k; j < rows; j++){
                        s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
                    }
                    // calculate the ith element of [tau * Q * w]
                    s = multiplyScalar(s, tau);
                    for(j = k; j < rows; ++j){
                        Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
                    }
                }
            }
        }
        // return matrices
        return {
            Q,
            R,
            toString: function toString() {
                return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
            }
        };
    }
    function _denseQR(m) {
        var ret = _denseQRimpl(m);
        var Rdata = ret.R._data;
        if (m._data.length > 0) {
            var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;
            for(var i = 0; i < Rdata.length; ++i){
                for(var j = 0; j < i && j < (Rdata[0] || []).length; ++j){
                    Rdata[i][j] = zero;
                }
            }
        }
        return ret;
    }
    function _sparseQR(m) {
        throw new Error('qr not implemented for sparse matrices yet');
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRightLogShift": (()=>createRightLogShift)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/bitwise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var name = 'rightLogShift';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix',
    'concat'
];
var createRightLogShift = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, zeros, DenseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo08xS0Sid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo08xS0Sid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo08xS0Sid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var useMatrixForArrayScalar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$bitwise$2f$useMatrixForArrayScalar$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createUseMatrixForArrayScalar"])({
        typed,
        matrix
    });
    /**
   * Bitwise right logical shift of value x by y number of bits, `x >>> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightLogShift(x, y)
   *
   * Examples:
   *
   *    math.rightLogShift(4, 2)               // returns number 1
   *
   *    math.rightLogShift([16, 32, 64], 4)    // returns Array [1, 2, 4]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
   *
   * @param  {number | Array | Matrix} x Value to be shifted
   * @param  {number} y Amount of shifts
   * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$bitwise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rightLogShiftNumber"],
        // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(y, 0)) {
                    return x.clone();
                }
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | BigNumber, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo10xSids(y, x, self, true);
            }),
        'number | BigNumber, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (equalScalar(x, 0)) {
                    return zeros(y.size(), y.storage());
                }
                return matAlgo14xDs(y, x, self, true);
            })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/smallerEq.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSmallerEq": (()=>createSmallerEq),
    "createSmallerEqNumber": (()=>createSmallerEqNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/relational/compareUnits.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'smallerEq';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createSmallerEq = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var compareUnits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$relational$2f$compareUnits$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCompareUnits"])({
        typed
    });
    /**
   * Test whether value x is smaller or equal to y.
   *
   * The function returns true when x is smaller than y or the relative
   * difference between x and y is smaller than the configured relTol and absTol. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.smallerEq(x, y)
   *
   * Examples:
   *
   *    math.smaller(1 + 2, 3)        // returns false
   *    math.smallerEq(1 + 2, 3)      // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, larger, largerEq, compare
   *
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | bigint | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */ return typed(name, createSmallerEqNumber({
        typed,
        config
    }), {
        'boolean, boolean': (x, y)=>x <= y,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.lte(y) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        },
        'bigint, bigint': (x, y)=>x <= y,
        'Fraction, Fraction': (x, y)=>x.compare(y) !== 1,
        'Complex, Complex': function Complex_Complex() {
            throw new TypeError('No ordering relation is defined for complex numbers');
        }
    }, compareUnits, matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
    }));
});
var createSmallerEqNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config'
], (_ref2)=>{
    var { typed, config } = _ref2;
    return typed(name, {
        'number, number': function number_number(x, y) {
            return x <= y || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, y, config.relTol, config.absTol);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/subset.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSubset": (()=>createSubset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/customs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'subset';
var dependencies = [
    'typed',
    'matrix',
    'zeros',
    'add'
];
var createSubset = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, zeros, add } = _ref;
    /**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     const d = [[1, 2], [3, 4]]
   *     math.subset(d, math.index(1, 0))             // returns 3
   *     math.subset(d, math.index([0, 1], 1))        // returns [[2], [4]]
   *     math.subset(d, math.index([false, true], 0)) // returns [[3]]
   *
   *     // replace a subset
   *     const e = []
   *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 0, 6]]
   *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 0, 6], [0, 7, 0]]
   *     math.subset(g, math.index([false, true], 1), 8)          // returns [[5, 0, 6], [0, 8, 0]]
   *
   *     // get submatrix using ranges
   *     const M = [
   *       [1,2,3],
   *       [4,5,6],
   *       [7,8,9]
   *     ]
   *     math.subset(M, math.index(math.range(0,2), math.range(0,3))) // [[1, 2, 3], [4, 5, 6]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | string} matrix  An array, matrix, or string
   * @param {Index} index
   *    For each dimension of the target, specifies an index or a list of
   *    indices to fetch or set. `subset` uses the cartesian product of
   *    the indices specified in each dimension.
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          math.matrix elements will be left undefined.
   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
   */ return typed(name, {
        // get subset
        'Matrix, Index': function Matrix_Index(value, index) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
                return matrix();
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndexSourceSize"])(value, index);
            return value.subset(index);
        },
        'Array, Index': typed.referTo('Matrix, Index', function(subsetRef) {
            return function(value, index) {
                var subsetResult = subsetRef(matrix(value), index);
                return index.isScalar() ? subsetResult : subsetResult.valueOf();
            };
        }),
        'Object, Index': _getObjectProperty,
        'string, Index': _getSubstring,
        // set subset
        'Matrix, Index, any, any': function Matrix_Index_any_any(value, index, replacement, defaultValue) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
                return value;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndexSourceSize"])(value, index);
            return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);
        },
        'Array, Index, any, any': typed.referTo('Matrix, Index, any, any', function(subsetRef) {
            return function(value, index, replacement, defaultValue) {
                var subsetResult = subsetRef(matrix(value), index, replacement, defaultValue);
                return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
            };
        }),
        'Array, Index, any': typed.referTo('Matrix, Index, any, any', function(subsetRef) {
            return function(value, index, replacement) {
                return subsetRef(matrix(value), index, replacement, undefined).valueOf();
            };
        }),
        'Matrix, Index, any': typed.referTo('Matrix, Index, any, any', function(subsetRef) {
            return function(value, index, replacement) {
                return subsetRef(value, index, replacement, undefined);
            };
        }),
        'string, Index, string': _setSubstring,
        'string, Index, string, string': _setSubstring,
        'Object, Index, any': _setObjectProperty
    });
    "TURBOPACK unreachable";
    /**
   * Broadcasts a replacment value to be the same size as index
   * @param {number | BigNumber | Array | Matrix} replacement Replacement value to try to broadcast
   * @param {*} index Index value
   * @returns broadcasted replacement that matches the size of index
   */ function _broadcastReplacement(replacement, index) {
        if (typeof replacement === 'string') {
            throw new Error('can\'t boradcast a string');
        }
        if (index._isScalar) {
            return replacement;
        }
        var indexSize = index.size();
        if (indexSize.every((d)=>d > 0)) {
            try {
                return add(replacement, zeros(indexSize));
            } catch (error) {
                return replacement;
            }
        } else {
            return replacement;
        }
    }
});
/**
 * Retrieve a subset of a string
 * @param {string} str            string from which to get a substring
 * @param {Index} index           An index or list of indices (character positions)
 * @returns {string} substring
 * @private
 */ function _getSubstring(str, index) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isIndex"])(index)) {
        // TODO: better error message
        throw new TypeError('Index expected');
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
        return '';
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndexSourceSize"])(Array.from(str), index);
    if (index.size().length !== 1) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](index.size().length, 1);
    }
    // validate whether the range is out of range
    var strLen = str.length;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(index.min()[0], strLen);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(index.max()[0], strLen);
    var range = index.dimension(0);
    var substr = '';
    range.forEach(function(v) {
        substr += str.charAt(v);
    });
    return substr;
}
/**
 * Replace a substring in a string
 * @param {string} str            string to be replaced
 * @param {Index} index           An index or list of indices (character positions)
 * @param {string} replacement    Replacement string
 * @param {string} [defaultValue] Default value to be used when resizing
 *                                the string. is ' ' by default
 * @returns {string} result
 * @private
 */ function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
        // TODO: better error message
        throw new TypeError('Index expected');
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
        return str;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndexSourceSize"])(Array.from(str), index);
    if (index.size().length !== 1) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](index.size().length, 1);
    }
    if (defaultValue !== undefined) {
        if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {
            throw new TypeError('Single character expected as defaultValue');
        }
    } else {
        defaultValue = ' ';
    }
    var range = index.dimension(0);
    var len = range.size()[0];
    if (len !== replacement.length) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](range.size()[0], replacement.length);
    }
    // validate whether the range is out of range
    var strLen = str.length;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(index.min()[0]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(index.max()[0]);
    // copy the string into an array with characters
    var chars = [];
    for(var i = 0; i < strLen; i++){
        chars[i] = str.charAt(i);
    }
    range.forEach(function(v, i) {
        chars[v] = replacement.charAt(i[0]);
    });
    // initialize undefined characters with a space
    if (chars.length > strLen) {
        for(var _i = strLen - 1, _len = chars.length; _i < _len; _i++){
            if (!chars[_i]) {
                chars[_i] = defaultValue;
            }
        }
    }
    return chars.join('');
}
/**
 * Retrieve a property from an object
 * @param {Object} object
 * @param {Index} index
 * @return {*} Returns the value of the property
 * @private
 */ function _getObjectProperty(object, index) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
        return undefined;
    }
    if (index.size().length !== 1) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== 'string') {
        throw new TypeError('String expected as index to retrieve an object property');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSafeProperty"])(object, key);
}
/**
 * Set a property on an object
 * @param {Object} object
 * @param {Index} index
 * @param {*} replacement
 * @return {*} Returns the updated object
 * @private
 */ function _setObjectProperty(object, index, replacement) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmptyIndex"])(index)) {
        return object;
    }
    if (index.size().length !== 1) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DimensionError"](index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== 'string') {
        throw new TypeError('String expected as index to retrieve an object property');
    }
    // clone the object, and apply the property to the clone
    var updated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(object);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$customs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setSafeProperty"])(updated, key, replacement);
    return updated;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/subtract.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSubtract": (()=>createSubtract)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'subtract';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'subtractScalar',
    'unaryMinus',
    'DenseMatrix',
    'concat'
];
var createSubtract = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, subtractScalar, unaryMinus, DenseMatrix, concat } = _ref;
    // TODO: split function subtract in two: subtract and subtractScalar
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2)        // returns number 3.3
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.subtract(a, b)          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
   *
   *    const c = math.unit('2.1 km')
   *    const d = math.unit('500m')
   *    math.subtract(c, d)          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Initial value
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Value to subtract from `x`
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Subtraction of `x` and `y`
   */ return typed(name, {
        'any, any': subtractScalar
    }, matrixAlgorithmSuite({
        elop: subtractScalar,
        SS: matAlgo05xSfSf,
        DS: matAlgo01xDSid,
        SD: matAlgo03xDSf,
        Ss: matAlgo12xSfs,
        sS: matAlgo10xSids
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/trace.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTrace": (()=>createTrace)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'trace';
var dependencies = [
    'typed',
    'matrix',
    'add'
];
var createTrace = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, add } = _ref;
    /**
   * Calculate the trace of a matrix: the sum of the elements on the main
   * diagonal of a square matrix.
   *
   * Syntax:
   *
   *    math.trace(x)
   *
   * Examples:
   *
   *    math.trace([[1, 2], [3, 4]]) // returns 5
   *
   *    const A = [
   *      [1, 2, 3],
   *      [-1, 2, 3],
   *      [2, 0, 3]
   *    ]
   *    math.trace(A) // returns 6
   *
   * See also:
   *
   *    diag
   *
   * @param {Array | Matrix} x  A matrix
   *
   * @return {number} The trace of `x`
   */ return typed('trace', {
        Array: function _arrayTrace(x) {
            // use dense matrix implementation
            return _denseTrace(matrix(x));
        },
        SparseMatrix: _sparseTrace,
        DenseMatrix: _denseTrace,
        any: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"]
    });
    "TURBOPACK unreachable";
    function _denseTrace(m) {
        // matrix size & data
        var size = m._size;
        var data = m._data;
        // process dimensions
        switch(size.length){
            case 1:
                // vector
                if (size[0] === 1) {
                    // return data[0]
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(data[0]);
                }
                throw new RangeError('Matrix must be square (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            case 2:
                {
                    // two dimensional
                    var rows = size[0];
                    var cols = size[1];
                    if (rows === cols) {
                        // calulate sum
                        var sum = 0;
                        // loop diagonal
                        for(var i = 0; i < rows; i++){
                            sum = add(sum, data[i][i]);
                        }
                        // return trace
                        return sum;
                    } else {
                        throw new RangeError('Matrix must be square (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                    }
                }
            default:
                // multi dimensional
                throw new RangeError('Matrix must be two dimensional (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
        }
    }
    function _sparseTrace(m) {
        // matrix arrays
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        var size = m._size;
        // check dimensions
        var rows = size[0];
        var columns = size[1];
        // matrix must be square
        if (rows === columns) {
            // calulate sum
            var sum = 0;
            // check we have data (avoid looping columns)
            if (values.length > 0) {
                // loop columns
                for(var j = 0; j < columns; j++){
                    // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
                    var k0 = ptr[j];
                    var k1 = ptr[j + 1];
                    // loop k within [k0, k1[
                    for(var k = k0; k < k1; k++){
                        // row index
                        var i = index[k];
                        // check row
                        if (i === j) {
                            // accumulate value
                            sum = add(sum, values[k]);
                            break;
                        }
                        if (i > j) {
                            break;
                        }
                    }
                }
            }
            // return trace
            return sum;
        }
        throw new RangeError('Matrix must be square (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUsolve": (()=>createUsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)");
;
;
var name = 'usolve';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createUsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolve(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolve(a, b)  // [[8], [9]]
   *
   * See also:
   *
   *    usolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var r = _denseBackwardSubstitution(m, b);
            return r.valueOf();
        }
    });
    "TURBOPACK unreachable";
    function _denseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // result
        var x = [];
        var mdata = m._data;
        // loop columns backwards
        for(var j = columns - 1; j >= 0; j--){
            // b[j]
            var bj = bdata[j][0] || 0;
            // x[j]
            var xj = void 0;
            if (!equalScalar(bj, 0)) {
                // value at [j, j]
                var vjj = mdata[j][j];
                if (equalScalar(vjj, 0)) {
                    // system cannot be solved
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                xj = divideScalar(bj, vjj);
                // loop rows
                for(var i = j - 1; i >= 0; i--){
                    // update copy of b
                    bdata[i] = [
                        subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
                    ];
                }
            } else {
                // zero value at j
                xj = 0;
            }
            // update x
            x[j] = [
                xj
            ];
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
    function _sparseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // result
        var x = [];
        // loop columns backwards
        for(var j = columns - 1; j >= 0; j--){
            var bj = bdata[j][0] || 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = 0;
                // upper triangular matrix values & index (column j)
                var jValues = [];
                var jIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[j];
                var lastIndex = ptr[j + 1];
                // values in column, find value at [j, j], loop backwards
                for(var k = lastIndex - 1; k >= firstIndex; k--){
                    var i = index[k];
                    // check row (rows are not sorted!)
                    if (i === j) {
                        vjj = values[k];
                    } else if (i < j) {
                        // store upper triangular
                        jValues.push(values[k]);
                        jIndices.push(i);
                    }
                }
                // at this point we must have a value in vjj
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                var xj = divideScalar(bj, vjj);
                for(var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++){
                    var _i = jIndices[_k];
                    bdata[_i] = [
                        subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))
                    ];
                }
                x[j] = [
                    xj
                ];
            } else {
                // degenerate row, we can choose any value
                x[j] = [
                    0
                ];
            }
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/combinatorics/catalan.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCatalan": (()=>createCatalan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'catalan';
var dependencies = [
    'typed',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'combinations',
    'isNegative',
    'isInteger'
];
var createCatalan = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, divideScalar, multiplyScalar, combinations, isNegative, isInteger } = _ref;
    /**
   * The Catalan Numbers enumerate combinatorial structures of many different types.
   * catalan only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.catalan(n)
   *
   * Examples:
   *
   *    math.catalan(3) // returns 5
   *    math.catalan(8) // returns 1430
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    nth Catalan number
   * @return {Number | BigNumber}     Cn(n)
   */ return typed(name, {
        'number | BigNumber': function number__BigNumber(n) {
            if (!isInteger(n) || isNegative(n)) {
                throw new TypeError('Non-negative integer value expected in function catalan');
            }
            return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/relational/compareNatural.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCompareNatural": (()=>createCompareNatural)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/javascript-natural-sort/naturalSort.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'compareNatural';
var dependencies = [
    'typed',
    'compare'
];
var createCompareNatural = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, compare } = _ref;
    var compareBooleans = compare.signatures['boolean,boolean'];
    /**
   * Compare two values of any type in a deterministic, natural way.
   *
   * For numeric values, the function works the same as `math.compare`.
   * For types of values that can't be compared mathematically,
   * the function compares in a natural way.
   *
   * For numeric values, x and y are considered equal when the relative
   * difference between x and y is smaller than the configured relTol and absTol.
   * The function cannot be used to compare values smaller than
   * approximately 2.22e-16.
   *
   * For Complex numbers, first the real parts are compared. If equal,
   * the imaginary parts are compared.
   *
   * Strings are compared with a natural sorting algorithm, which
   * orders strings in a "logic" way following some heuristics.
   * This differs from the function `compare`, which converts the string
   * into a numeric value and compares that. The function `compareText`
   * on the other hand compares text lexically.
   *
   * Arrays and Matrices are compared value by value until there is an
   * unequal pair of values encountered. Objects are compared by sorted
   * keys until the keys or their values are unequal.
   *
   * Syntax:
   *
   *    math.compareNatural(x, y)
   *
   * Examples:
   *
   *    math.compareNatural(6, 1)              // returns 1
   *    math.compareNatural(2, 3)              // returns -1
   *    math.compareNatural(7, 7)              // returns 0
   *
   *    math.compareNatural('10', '2')         // returns 1
   *    math.compareText('10', '2')            // returns -1
   *    math.compare('10', '2')                // returns 1
   *
   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1
   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1
   *    math.compare('Answer: 10', 'Answer: 2')
   *        // Error: Cannot convert "Answer: 10" to a number
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('40 mm')
   *    math.compareNatural(a, b)              // returns 1
   *
   *    const c = math.complex('2 + 3i')
   *    const d = math.complex('2 + 4i')
   *    math.compareNatural(c, d)              // returns -1
   *
   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1
   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1
   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1
   *    math.compareNatural([1, 2], [1, 2])       // returns 0
   *
   *    math.compareNatural({a: 2}, {a: 4})       // returns -1
   *
   * See also:
   *
   *    compare, compareText
   *
   * @param  {*} x First value to compare
   * @param  {*} y Second value to compare
   * @return {number} Returns the result of the comparison:
   *                  1 when x > y, -1 when x < y, and 0 when x == y.
   */ return typed(name, {
        'any, any': _compareNatural
    }); // just to check # args
    "TURBOPACK unreachable";
    function _compareNatural(x, y) {
        var typeX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(x);
        var typeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(y);
        var c;
        // numeric types
        if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {
            c = compare(x, y);
            if (c.toString() !== '0') {
                // c can be number, BigNumber, or Fraction
                return c > 0 ? 1 : -1; // return a number
            } else {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeX, typeY);
            }
        }
        // matrix types
        var matTypes = [
            'Array',
            'DenseMatrix',
            'SparseMatrix'
        ];
        if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
            c = compareMatricesAndArrays(_compareNatural, x, y);
            if (c !== 0) {
                return c;
            } else {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeX, typeY);
            }
        }
        // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'
        if (typeX !== typeY) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeX, typeY);
        }
        if (typeX === 'Complex') {
            return compareComplexNumbers(x, y);
        }
        if (typeX === 'Unit') {
            if (x.equalBase(y)) {
                return _compareNatural(x.value, y.value);
            }
            // compare by units
            return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
        }
        if (typeX === 'boolean') {
            return compareBooleans(x, y);
        }
        if (typeX === 'string') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(x, y);
        }
        if (typeX === 'Object') {
            return compareObjects(_compareNatural, x, y);
        }
        if (typeX === 'null') {
            return 0;
        }
        if (typeX === 'undefined') {
            return 0;
        }
        // this should not occur...
        throw new TypeError('Unsupported type of value "' + typeX + '"');
    }
    /**
   * Compare mixed matrix/array types, by converting to same-shaped array.
   * This comparator is non-deterministic regarding input types.
   * @param {Array | SparseMatrix | DenseMatrix | *} x
   * @param {Array | SparseMatrix | DenseMatrix | *} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */ function compareMatricesAndArrays(compareNatural, x, y) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(x) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(y)) {
            return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(x)) {
            // note: convert to array is expensive
            return compareMatricesAndArrays(compareNatural, x.toArray(), y);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(y)) {
            // note: convert to array is expensive
            return compareMatricesAndArrays(compareNatural, x, y.toArray());
        }
        // convert DenseArray into Array
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDenseMatrix"])(x)) {
            return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDenseMatrix"])(y)) {
            return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
        }
        // convert scalars to array
        if (!Array.isArray(x)) {
            return compareMatricesAndArrays(compareNatural, [
                x
            ], y);
        }
        if (!Array.isArray(y)) {
            return compareMatricesAndArrays(compareNatural, x, [
                y
            ]);
        }
        return compareArrays(compareNatural, x, y);
    }
    /**
   * Compare two Arrays
   *
   * - First, compares value by value
   * - Next, if all corresponding values are equal,
   *   look at the length: longest array will be considered largest
   *
   * @param {Array} x
   * @param {Array} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */ function compareArrays(compareNatural, x, y) {
        // compare each value
        for(var i = 0, ii = Math.min(x.length, y.length); i < ii; i++){
            var v = compareNatural(x[i], y[i]);
            if (v !== 0) {
                return v;
            }
        }
        // compare the size of the arrays
        if (x.length > y.length) {
            return 1;
        }
        if (x.length < y.length) {
            return -1;
        }
        // both Arrays have equal size and content
        return 0;
    }
    /**
   * Compare two objects
   *
   * - First, compare sorted property names
   * - Next, compare the property values
   *
   * @param {Object} x
   * @param {Object} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */ function compareObjects(compareNatural, x, y) {
        var keysX = Object.keys(x);
        var keysY = Object.keys(y);
        // compare keys
        keysX.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
        keysY.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$javascript$2d$natural$2d$sort$2f$naturalSort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
        var c = compareArrays(compareNatural, keysX, keysY);
        if (c !== 0) {
            return c;
        }
        // compare values
        for(var i = 0; i < keysX.length; i++){
            var v = compareNatural(x[keysX[i]], y[keysY[i]]);
            if (v !== 0) {
                return v;
            }
        }
        return 0;
    }
});
/**
 * Compare two complex numbers, `x` and `y`:
 *
 * - First, compare the real values of `x` and `y`
 * - If equal, compare the imaginary values of `x` and `y`
 *
 * @params {Complex} x
 * @params {Complex} y
 * @returns {number} Returns the comparison result: -1, 0, or 1
 */ function compareComplexNumbers(x, y) {
    if (x.re > y.re) {
        return 1;
    }
    if (x.re < y.re) {
        return -1;
    }
    if (x.im > y.im) {
        return 1;
    }
    if (x.im < y.im) {
        return -1;
    }
    return 0;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/combinatorics/composition.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createComposition": (()=>createComposition)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'composition';
var dependencies = [
    'typed',
    'addScalar',
    'combinations',
    'isNegative',
    'isPositive',
    'isInteger',
    'larger'
];
var createComposition = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, combinations, isPositive, isNegative, isInteger, larger } = _ref;
    /**
   * The composition counts of n into k parts.
   *
   * composition only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *   math.composition(n, k)
   *
   * Examples:
   *
   *    math.composition(5, 3) // returns 6
   *
   * See also:
   *
   *    combinations
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
   */ return typed(name, {
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(n, k) {
            if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {
                throw new TypeError('Positive integer value expected in function composition');
            } else if (larger(k, n)) {
                throw new TypeError('k must be less than or equal to n in function composition');
            }
            return combinations(addScalar(n, -1), addScalar(k, -1));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/diff.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDiff": (()=>createDiff)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
var name = 'diff';
var dependencies = [
    'typed',
    'matrix',
    'subtract',
    'number'
];
var createDiff = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, subtract, number } = _ref;
    /**
   * Create a new matrix or array of the difference between elements of the given array
   * The optional dim parameter lets you specify the dimension to evaluate the difference of
   * If no dimension parameter is passed it is assumed as dimension 0
   *
   * Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber
   * Arrays must be 'rectangular' meaning arrays like [1, 2]
   * If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays
   *
   * Syntax:
   *
   *     math.diff(arr)
   *     math.diff(arr, dim)
   *
   * Examples:
   *
   *     const arr = [1, 2, 4, 7, 0]
   *     math.diff(arr) // returns [1, 2, 3, -7] (no dimension passed so 0 is assumed)
   *     math.diff(math.matrix(arr)) // returns Matrix [1, 2, 3, -7]
   *
   *     const arr = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [9, 8, 7, 6, 4]]
   *     math.diff(arr) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
   *     math.diff(arr, 0) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
   *     math.diff(arr, 1) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
   *     math.diff(arr, math.bignumber(1)) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
   *
   *     math.diff(arr, 2) // throws RangeError as arr is 2 dimensional not 3
   *     math.diff(arr, -1) // throws RangeError as negative dimensions are not allowed
   *
   *     // These will all produce the same result
   *     math.diff([[1, 2], [3, 4]])
   *     math.diff([math.matrix([1, 2]), math.matrix([3, 4])])
   *     math.diff([[1, 2], math.matrix([3, 4])])
   *     math.diff([math.matrix([1, 2]), [3, 4]])
   *     // They do not produce the same result as  math.diff(math.matrix([[1, 2], [3, 4]])) as this returns a matrix
   *
   * See Also:
   *
   *      sum
   *      subtract
   *      partitionSelect
   *
   * @param {Array | Matrix} arr      An array or matrix
   * @param {number | BigNumber} dim  Dimension
   * @return {Array | Matrix}         Difference between array elements in given dimension
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(arr) {
            // No dimension specified => assume dimension 0
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(arr)) {
                return matrix(_diff(arr.toArray()));
            } else {
                return _diff(arr);
            }
        },
        'Array | Matrix, number': function Array__Matrix_number(arr, dim) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(dim)) throw new RangeError('Dimension must be a whole number');
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(arr)) {
                return matrix(_recursive(arr.toArray(), dim));
            } else {
                return _recursive(arr, dim);
            }
        },
        'Array, BigNumber': typed.referTo('Array,number', (selfAn)=>(arr, dim)=>selfAn(arr, number(dim))),
        'Matrix, BigNumber': typed.referTo('Matrix,number', (selfMn)=>(arr, dim)=>selfMn(arr, number(dim)))
    });
    "TURBOPACK unreachable";
    /**
   * Recursively find the correct dimension in the array/matrix
   * Then Apply _diff to that dimension
   *
   * @param {Array} arr      The array
   * @param {number} dim     Dimension
   * @return {Array}         resulting array
   */ function _recursive(arr, dim) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(arr)) {
            arr = arr.toArray(); // Makes sure arrays like [ matrix([0, 1]), matrix([1, 0]) ] are processed properly
        }
        if (!Array.isArray(arr)) {
            throw RangeError('Array/Matrix does not have that many dimensions');
        }
        if (dim > 0) {
            var result = [];
            arr.forEach((element)=>{
                result.push(_recursive(element, dim - 1));
            });
            return result;
        } else if (dim === 0) {
            return _diff(arr);
        } else {
            throw RangeError('Cannot have negative dimension');
        }
    }
    /**
   * Difference between elements in the array
   *
   * @param {Array} arr      An array
   * @return {Array}         resulting array
   */ function _diff(arr) {
        var result = [];
        var size = arr.length;
        for(var i = 1; i < size; i++){
            result.push(_ElementDiff(arr[i - 1], arr[i]));
        }
        return result;
    }
    /**
   * Difference between 2 objects
   *
   * @param {Object} obj1    First object
   * @param {Object} obj2    Second object
   * @return {Array}         resulting array
   */ function _ElementDiff(obj1, obj2) {
        // Convert matrices to arrays
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(obj1)) obj1 = obj1.toArray();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(obj2)) obj2 = obj2.toArray();
        var obj1IsArray = Array.isArray(obj1);
        var obj2IsArray = Array.isArray(obj2);
        if (obj1IsArray && obj2IsArray) {
            return _ArrayDiff(obj1, obj2);
        }
        if (!obj1IsArray && !obj2IsArray) {
            return subtract(obj2, obj1); // Difference is (second - first) NOT (first - second)
        }
        throw TypeError('Cannot calculate difference between 1 array and 1 non-array');
    }
    /**
   * Difference of elements in 2 arrays
   *
   * @param {Array} arr1     Array 1
   * @param {Array} arr2     Array 2
   * @return {Array}         resulting array
   */ function _ArrayDiff(arr1, arr2) {
        if (arr1.length !== arr2.length) {
            throw RangeError('Not all sub-arrays have the same length');
        }
        var result = [];
        var size = arr1.length;
        for(var i = 0; i < size; i++){
            result.push(_ElementDiff(arr1[i], arr2[i]));
        }
        return result;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/geometry/distance.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDistance": (()=>createDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'distance';
var dependencies = [
    'typed',
    'addScalar',
    'subtractScalar',
    'divideScalar',
    'multiplyScalar',
    'deepEqual',
    'sqrt',
    'abs'
];
var createDistance = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, subtractScalar, multiplyScalar, divideScalar, deepEqual, sqrt, abs } = _ref;
    /**
    * Calculates:
    *    The eucledian distance between two points in N-dimensional spaces.
    *    Distance between point and a line in 2 and 3 dimensional spaces.
    *    Pairwise distance between a set of 2D or 3D points
    * NOTE:
    *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
    *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (x−x0, y−y0, z−z0) = t(a, b, c)
    *
    * Syntax:
    *
    *    math.distance([x1,y1], [x2,y2])
    *    math.distance({pointOneX, pointOneY}, {pointTwoX, pointTwoY})
    *    math.distance([x1,y1,z1], [x2,y2,z2])
    *    math.distance({pointOneX, pointOneY, pointOneZ}, {pointTwoX, pointTwoY, pointTwoZ})
    *    math.distance([x1,y1,z1,a1], [x2,y2,z2,a2])
    *    math.distance([[x1,y1], [x2,y2], [x3,y3]])
    *    math.distance([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])
    *    math.distance([pointX,pointY], [a,b,c])
    *    math.distance([pointX,pointY], [lineOnePtX,lineOnePtY], [lineTwoPtX,lineTwoPtY])
    *    math.distance({pointX, pointY}, {lineOnePtX, lineOnePtY}, {lineTwoPtX, lineTwoPtY})
    *    math.distance([pointX,pointY,pointZ], [x0, y0, z0, a, b, c])
    *    math.distance({pointX, pointY, pointZ}, {x0, y0, z0, a, b, c})
    *
    * Examples:
    *    math.distance([0,0], [4,4])                     // Returns 5.656854249492381
    *    math.distance(
    *     {pointOneX: 0, pointOneY: 0},
    *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
    *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.7416573867739413
    *    math.distance(
    *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
    *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
    *    math.distance([1, 0, 1, 0], [0, -1, 0, -1])     // Returns 2
    *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
    *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
    *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
    *    math.distance([0, 0], [3, 0], [0, 4])        // Returns 2.4
    *    math.distance(
    *     {pointX: 0, pointY: 0},
    *     {lineOnePtX: 3, lineOnePtY: 0},
    *     {lineTwoPtX: 0, lineTwoPtY: 4})                // Returns 2.4
    *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
    *    math.distance(
    *     {pointX: 2, pointY: 3, pointZ: 1},
    *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1})       // Returns 2.3204774044612857
    *
    * @param {Array | Matrix | Object} x    Co-ordinates of first point
    * @param {Array | Matrix | Object} y    Co-ordinates of second point
    * @return {Number | BigNumber} Returns the distance from two/three points
  */ return typed(name, {
        'Array, Array, Array': function Array_Array_Array(x, y, z) {
            // Point to Line 2D (x=Point, y=LinePoint1, z=LinePoint2)
            if (x.length === 2 && y.length === 2 && z.length === 2) {
                if (!_2d(x)) {
                    throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
                }
                if (!_2d(y)) {
                    throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
                }
                if (!_2d(z)) {
                    throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
                }
                if (deepEqual(y, z)) {
                    throw new TypeError('LinePoint1 should not be same with LinePoint2');
                }
                var xCoeff = subtractScalar(z[1], y[1]);
                var yCoeff = subtractScalar(y[0], z[0]);
                var constant = subtractScalar(multiplyScalar(z[0], y[1]), multiplyScalar(y[0], z[1]));
                return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
            } else {
                throw new TypeError('Invalid Arguments: Try again');
            }
        },
        'Object, Object, Object': function Object_Object_Object(x, y, z) {
            if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
                if (!_2d(x)) {
                    throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
                }
                if (!_2d(y)) {
                    throw new TypeError('Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers');
                }
                if (!_2d(z)) {
                    throw new TypeError('Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers');
                }
                if (deepEqual(_objectToArray(y), _objectToArray(z))) {
                    throw new TypeError('LinePoint1 should not be same with LinePoint2');
                }
                if ('pointX' in x && 'pointY' in x && 'lineOnePtX' in y && 'lineOnePtY' in y && 'lineTwoPtX' in z && 'lineTwoPtY' in z) {
                    var xCoeff = subtractScalar(z.lineTwoPtY, y.lineOnePtY);
                    var yCoeff = subtractScalar(y.lineOnePtX, z.lineTwoPtX);
                    var constant = subtractScalar(multiplyScalar(z.lineTwoPtX, y.lineOnePtY), multiplyScalar(y.lineOnePtX, z.lineTwoPtY));
                    return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
                } else {
                    throw new TypeError('Key names do not match');
                }
            } else {
                throw new TypeError('Invalid Arguments: Try again');
            }
        },
        'Array, Array': function Array_Array(x, y) {
            // Point to Line 2D (x=[pointX, pointY], y=[x-coeff, y-coeff, const])
            if (x.length === 2 && y.length === 3) {
                if (!_2d(x)) {
                    throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
                }
                if (!_3d(y)) {
                    throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
                }
                return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
            } else if (x.length === 3 && y.length === 6) {
                // Point to Line 3D
                if (!_3d(x)) {
                    throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
                }
                if (!_parametricLine(y)) {
                    throw new TypeError('Array with 6 numbers or BigNumbers expected for second argument');
                }
                return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
            } else if (x.length === y.length && x.length > 0) {
                // Point to Point N-dimensions
                if (!_containsOnlyNumbers(x)) {
                    throw new TypeError('All values of an array should be numbers or BigNumbers');
                }
                if (!_containsOnlyNumbers(y)) {
                    throw new TypeError('All values of an array should be numbers or BigNumbers');
                }
                return _euclideanDistance(x, y);
            } else {
                throw new TypeError('Invalid Arguments: Try again');
            }
        },
        'Object, Object': function Object_Object(x, y) {
            if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
                if (!_2d(x)) {
                    throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
                }
                if (!_3d(y)) {
                    throw new TypeError('Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers');
                }
                if ('pointX' in x && 'pointY' in x && 'xCoeffLine' in y && 'yCoeffLine' in y && 'constant' in y) {
                    return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
                } else {
                    throw new TypeError('Key names do not match');
                }
            } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
                // Point to Line 3D
                if (!_3d(x)) {
                    throw new TypeError('Values of pointX, pointY and pointZ should be numbers or BigNumbers');
                }
                if (!_parametricLine(y)) {
                    throw new TypeError('Values of x0, y0, z0, a, b and c should be numbers or BigNumbers');
                }
                if ('pointX' in x && 'pointY' in x && 'x0' in y && 'y0' in y && 'z0' in y && 'a' in y && 'b' in y && 'c' in y) {
                    return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
                } else {
                    throw new TypeError('Key names do not match');
                }
            } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
                // Point to Point 2D
                if (!_2d(x)) {
                    throw new TypeError('Values of pointOneX and pointOneY should be numbers or BigNumbers');
                }
                if (!_2d(y)) {
                    throw new TypeError('Values of pointTwoX and pointTwoY should be numbers or BigNumbers');
                }
                if ('pointOneX' in x && 'pointOneY' in x && 'pointTwoX' in y && 'pointTwoY' in y) {
                    return _euclideanDistance([
                        x.pointOneX,
                        x.pointOneY
                    ], [
                        y.pointTwoX,
                        y.pointTwoY
                    ]);
                } else {
                    throw new TypeError('Key names do not match');
                }
            } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
                // Point to Point 3D
                if (!_3d(x)) {
                    throw new TypeError('Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers');
                }
                if (!_3d(y)) {
                    throw new TypeError('Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers');
                }
                if ('pointOneX' in x && 'pointOneY' in x && 'pointOneZ' in x && 'pointTwoX' in y && 'pointTwoY' in y && 'pointTwoZ' in y) {
                    return _euclideanDistance([
                        x.pointOneX,
                        x.pointOneY,
                        x.pointOneZ
                    ], [
                        y.pointTwoX,
                        y.pointTwoY,
                        y.pointTwoZ
                    ]);
                } else {
                    throw new TypeError('Key names do not match');
                }
            } else {
                throw new TypeError('Invalid Arguments: Try again');
            }
        },
        Array: function Array1(arr) {
            if (!_pairwise(arr)) {
                throw new TypeError('Incorrect array format entered for pairwise distance calculation');
            }
            return _distancePairwise(arr);
        }
    });
    "TURBOPACK unreachable";
    function _isNumber(a) {
        // distance supports numbers and bignumbers
        return typeof a === 'number' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(a);
    }
    function _2d(a) {
        // checks if the number of arguments are correct in count and are valid (should be numbers)
        if (a.constructor !== Array) {
            a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]);
    }
    function _3d(a) {
        // checks if the number of arguments are correct in count and are valid (should be numbers)
        if (a.constructor !== Array) {
            a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
    }
    function _containsOnlyNumbers(a) {
        // checks if the number of arguments are correct in count and are valid (should be numbers)
        if (!Array.isArray(a)) {
            a = _objectToArray(a);
        }
        return a.every(_isNumber);
    }
    function _parametricLine(a) {
        if (a.constructor !== Array) {
            a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
    }
    function _objectToArray(o) {
        var keys = Object.keys(o);
        var a = [];
        for(var i = 0; i < keys.length; i++){
            a.push(o[keys[i]]);
        }
        return a;
    }
    function _pairwise(a) {
        // checks for valid arguments passed to _distancePairwise(Array)
        if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
            if (a.some((aI)=>aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
                return false;
            }
        } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
            if (a.some((aI)=>aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
                return false;
            }
        } else {
            return false;
        }
        return true;
    }
    function _distancePointLine2D(x, y, a, b, c) {
        var num = abs(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
        var den = sqrt(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
        return divideScalar(num, den);
    }
    function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
        var num = [
            subtractScalar(multiplyScalar(subtractScalar(y0, y), c), multiplyScalar(subtractScalar(z0, z), b)),
            subtractScalar(multiplyScalar(subtractScalar(z0, z), a), multiplyScalar(subtractScalar(x0, x), c)),
            subtractScalar(multiplyScalar(subtractScalar(x0, x), b), multiplyScalar(subtractScalar(y0, y), a))
        ];
        num = sqrt(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
        var den = sqrt(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
        return divideScalar(num, den);
    }
    function _euclideanDistance(x, y) {
        var vectorSize = x.length;
        var result = 0;
        var diff = 0;
        for(var i = 0; i < vectorSize; i++){
            diff = subtractScalar(x[i], y[i]);
            result = addScalar(multiplyScalar(diff, diff), result);
        }
        return sqrt(result);
    }
    function _distancePairwise(a) {
        var result = [];
        var pointA = [];
        var pointB = [];
        for(var i = 0; i < a.length - 1; i++){
            for(var j = i + 1; j < a.length; j++){
                if (a[0].length === 2) {
                    pointA = [
                        a[i][0],
                        a[i][1]
                    ];
                    pointB = [
                        a[j][0],
                        a[j][1]
                    ];
                } else if (a[0].length === 3) {
                    pointA = [
                        a[i][0],
                        a[i][1],
                        a[i][2]
                    ];
                    pointB = [
                        a[j][0],
                        a[j][1],
                        a[j][2]
                    ];
                }
                result.push(_euclideanDistance(pointA, pointB));
            }
        }
        return result;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/dot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDot": (()=>createDot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
var name = 'dot';
var dependencies = [
    'typed',
    'addScalar',
    'multiplyScalar',
    'conj',
    'size'
];
var createDot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, multiplyScalar, conj, size } = _ref;
    /**
   * Calculate the dot product of two vectors. The dot product of
   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
   *
   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
   *
   * Syntax:
   *
   *    math.dot(x, y)
   *
   * Examples:
   *
   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
   *
   * See also:
   *
   *    multiply, cross
   *
   * @param  {Array | Matrix} x     First vector
   * @param  {Array | Matrix} y     Second vector
   * @return {number}               Returns the dot product of `x` and `y`
   */ return typed(name, {
        'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
        'SparseMatrix, SparseMatrix': _sparseDot
    });
    "TURBOPACK unreachable";
    function _validateDim(x, y) {
        var xSize = _size(x);
        var ySize = _size(y);
        var xLen, yLen;
        if (xSize.length === 1) {
            xLen = xSize[0];
        } else if (xSize.length === 2 && xSize[1] === 1) {
            xLen = xSize[0];
        } else {
            throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
        }
        if (ySize.length === 1) {
            yLen = ySize[0];
        } else if (ySize.length === 2 && ySize[1] === 1) {
            yLen = ySize[0];
        } else {
            throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
        }
        if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
        if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
        return xLen;
    }
    function _denseDot(a, b) {
        var N = _validateDim(a, b);
        var adata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(a) ? a._data : a;
        var adt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(a) ? a._datatype || a.getDataType() : undefined;
        var bdata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(b) ? b._data : b;
        var bdt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(b) ? b._datatype || b.getDataType() : undefined;
        // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)
        var aIsColumn = _size(a).length === 2;
        var bIsColumn = _size(b).length === 2;
        var add = addScalar;
        var mul = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            var dt = adt;
            // find signatures that matches (dt, dt)
            add = typed.find(addScalar, [
                dt,
                dt
            ]);
            mul = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // both vectors 1-dimensional
        if (!aIsColumn && !bIsColumn) {
            var c = mul(conj(adata[0]), bdata[0]);
            for(var i = 1; i < N; i++){
                c = add(c, mul(conj(adata[i]), bdata[i]));
            }
            return c;
        }
        // a is 1-dim, b is column
        if (!aIsColumn && bIsColumn) {
            var _c = mul(conj(adata[0]), bdata[0][0]);
            for(var _i = 1; _i < N; _i++){
                _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
            }
            return _c;
        }
        // a is column, b is 1-dim
        if (aIsColumn && !bIsColumn) {
            var _c2 = mul(conj(adata[0][0]), bdata[0]);
            for(var _i2 = 1; _i2 < N; _i2++){
                _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
            }
            return _c2;
        }
        // both vectors are column
        if (aIsColumn && bIsColumn) {
            var _c3 = mul(conj(adata[0][0]), bdata[0][0]);
            for(var _i3 = 1; _i3 < N; _i3++){
                _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
            }
            return _c3;
        }
    }
    function _sparseDot(x, y) {
        _validateDim(x, y);
        var xindex = x._index;
        var xvalues = x._values;
        var yindex = y._index;
        var yvalues = y._values;
        // TODO optimize add & mul using datatype
        var c = 0;
        var add = addScalar;
        var mul = multiplyScalar;
        var i = 0;
        var j = 0;
        while(i < xindex.length && j < yindex.length){
            var I = xindex[i];
            var J = yindex[j];
            if (I < J) {
                i++;
                continue;
            }
            if (I > J) {
                j++;
                continue;
            }
            if (I === J) {
                c = add(c, mul(xvalues[i], yvalues[j]));
                i++;
                j++;
            }
        }
        return c;
    }
    // TODO remove this once #1771 is fixed
    function _size(x) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x) ? x.size() : size(x);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/invmod.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createInvmod": (()=>createInvmod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'invmod';
var dependencies = [
    'typed',
    'config',
    'BigNumber',
    'xgcd',
    'equal',
    'smaller',
    'mod',
    'add',
    'isInteger'
];
var createInvmod = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, BigNumber, xgcd, equal, smaller, mod, add, isInteger } = _ref;
    /**
   * Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation `ax ≣ 1 (mod b)`
   * See https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.
   *
   * Syntax:
   *
   *    math.invmod(a, b)
   *
   * Examples:
   *
   *    math.invmod(8, 12)             // returns NaN
   *    math.invmod(7, 13)             // returns 2
   *    math.invmod(15151, 15122)      // returns 10429
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {number | BigNumber }  Returns an integer number
   *                              where `invmod(a,b)*a ≣ 1 (mod b)`
   */ return typed(name, {
        'number, number': invmod,
        'BigNumber, BigNumber': invmod
    });
    "TURBOPACK unreachable";
    function invmod(a, b) {
        if (!isInteger(a) || !isInteger(b)) throw new Error('Parameters in function invmod must be integer numbers');
        a = mod(a, b);
        if (equal(b, 0)) throw new Error('Divisor must be non zero');
        var res = xgcd(a, b);
        res = res.valueOf();
        var [gcd, inv] = res;
        if (!equal(gcd, BigNumber(1))) return NaN;
        inv = mod(inv, b);
        if (smaller(inv, BigNumber(0))) inv = add(inv, b);
        return inv;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/lcm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLcm": (()=>createLcm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'lcm';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'concat'
];
var createLcm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var lcmTypes = 'number | BigNumber | Fraction | Matrix | Array';
    var lcmManySignature = {};
    lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed.referToSelf((self)=>(a, b, args)=>{
            var res = self(a, b);
            for(var i = 0; i < args.length; i++){
                res = self(res, args[i]);
            }
            return res;
        });
    /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6)               // returns 12
   *    math.lcm(6, 21)              // returns 42
   *    math.lcm(6, 21, 5)           // returns 210
   *
   *    math.lcm([4, 6], [6, 21])    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lcmNumber"],
        'BigNumber, BigNumber': _lcmBigNumber,
        'Fraction, Fraction': (x, y)=>x.lcm(y)
    }, matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
    }), lcmManySignature);
    "TURBOPACK unreachable";
    /**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns the least common multiple of a and b
   * @private
   */ function _lcmBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function lcm must be integer numbers');
        }
        if (a.isZero()) {
            return a;
        }
        if (b.isZero()) {
            return b;
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        // evaluate lcm here inline to reduce overhead
        var prod = a.times(b);
        while(!b.isZero()){
            var t = b;
            b = a.mod(t);
            a = t;
        }
        return prod.div(a).abs();
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log1p.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog1p": (()=>createLog1p)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
;
var name = 'log1p';
var dependencies = [
    'typed',
    'config',
    'divideScalar',
    'log',
    'Complex'
];
var createLog1p = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, divideScalar, log, Complex } = _ref;
    /**
   * Calculate the logarithm of a `value+1`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log1p(x)
   *    math.log1p(x, base)
   *
   * Examples:
   *
   *    math.log1p(2.5)                 // returns 1.252762968495368
   *    math.exp(math.log1p(1.4))       // returns 2.4
   *
   *    math.pow(10, 4)                 // returns 10000
   *    math.log1p(9999, 10)            // returns 4
   *    math.log1p(9999) / math.log(10) // returns 4
   *
   * See also:
   *
   *    exp, log, log2, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm of `x+1`.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x+1` is calculated.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x+1`
   */ return typed(name, {
        number: function number(x) {
            if (x >= -1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log1p"])(x);
            } else {
                // negative value -> complex value computation
                return _log1pComplex(new Complex(x, 0));
            }
        },
        Complex: _log1pComplex,
        BigNumber: function BigNumber(x) {
            var y = x.plus(1);
            if (!y.isNegative() || config.predictable) {
                return y.ln();
            } else {
                // downgrade to number, return Complex valued result
                return _log1pComplex(new Complex(x.toNumber(), 0));
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self)),
        'any, any': typed.referToSelf((self)=>(x, base)=>{
                // calculate logarithm for a specified base, log1p(x, base)
                return divideScalar(self(x), log(base));
            })
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the natural logarithm of a complex number + 1
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */ function _log1pComplex(x) {
        var xRe1p = x.re + 1;
        return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLsolveAll": (()=>createLsolveAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)");
;
;
var name = 'lsolveAll';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createLsolveAll = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolveAll(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]
   *
   * See also:
   *
   *    lsolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseForwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseForwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var R = _denseForwardSubstitution(m, b);
            return R.map((r)=>r.valueOf());
        }
    });
    "TURBOPACK unreachable";
    function _denseForwardSubstitution(m, b_) {
        // the algorithm is derived from
        // https://www.overleaf.com/read/csvgqdxggyjv
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // loop columns
        for(var i = 0; i < columns; i++){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                if (!equalScalar(M[i][i], 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], M[i][i]);
                    for(var j = i + 1; j < columns; j++){
                        // b[j] -= b[i] * M[j,i]
                        b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j = i + 1; _j < columns; _j++){
                        bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
    function _sparseForwardSubstitution(m, b_) {
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // loop columns
        for(var i = 0; i < columns; i++){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                // values & indices (column i)
                var iValues = [];
                var iIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[i];
                var lastIndex = ptr[i + 1];
                // find the value at [i, i]
                var Mii = 0;
                for(var j = firstIndex; j < lastIndex; j++){
                    var J = index[j];
                    // check row
                    if (J === i) {
                        Mii = values[j];
                    } else if (J > i) {
                        // store lower triangular
                        iValues.push(values[j]);
                        iIndices.push(J);
                    }
                }
                if (!equalScalar(Mii, 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], Mii);
                    for(var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++){
                        var _J = iIndices[_j2];
                        b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++){
                        var _J2 = iIndices[_j3];
                        bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrixFromRows": (()=>createMatrixFromRows)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'matrixFromRows';
var dependencies = [
    'typed',
    'matrix',
    'flatten',
    'size'
];
var createMatrixFromRows = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, flatten, size } = _ref;
    /**
   * Create a dense matrix from vectors as individual rows.
   * If you pass column vectors, they will be transposed (but not conjugated!)
   *
   * Syntax:
   *
   *    math.matrixFromRows(...arr)
   *    math.matrixFromRows(row1, row2)
   *    math.matrixFromRows(row1, row2, row3)
   *
   * Examples:
   *
   *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])
   *    math.matrixFromRows(...vectors)
   *
   * See also:
   *
   *    matrix, matrixFromColumns, matrixFromFunction, zeros
   *
   * @param {... Array | Matrix} rows  Multiple rows
   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
   */ return typed(name, {
        '...Array': function Array(arr) {
            return _createArray(arr);
        },
        '...Matrix': function Matrix(arr) {
            return matrix(_createArray(arr.map((m)=>m.toArray())));
        }
    });
    "TURBOPACK unreachable";
    function _createArray(arr) {
        if (arr.length === 0) throw new TypeError('At least one row is needed to construct a matrix.');
        var N = checkVectorTypeAndReturnLength(arr[0]);
        var result = [];
        for (var row of arr){
            var rowLength = checkVectorTypeAndReturnLength(row);
            if (rowLength !== N) {
                throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (rowLength | 0));
            }
            result.push(flatten(row));
        }
        return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
        var s = size(vec);
        if (s.length === 1) {
            // 1D vector
            return s[0];
        } else if (s.length === 2) {
            // 2D vector
            if (s[0] === 1) {
                // row vector
                return s[1];
            } else if (s[1] === 1) {
                // col vector
                return s[0];
            } else {
                throw new TypeError('At least one of the arguments is not a vector.');
            }
        } else {
            throw new TypeError('Only one- or two-dimensional vectors are supported.');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMultiply": (()=>createMultiply)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'multiply';
var dependencies = [
    'typed',
    'matrix',
    'addScalar',
    'multiplyScalar',
    'equalScalar',
    'dot'
];
var createMultiply = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, addScalar, multiplyScalar, equalScalar, dot } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    function _validateMatrixDimensions(size1, size2) {
        // check left operand dimensions
        switch(size1.length){
            case 1:
                // check size2
                switch(size2.length){
                    case 1:
                        // Vector x Vector
                        if (size1[0] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
                        }
                        break;
                    case 2:
                        // Vector x Matrix
                        if (size1[0] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
                        }
                        break;
                    default:
                        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
                }
                break;
            case 2:
                // check size2
                switch(size2.length){
                    case 1:
                        // Matrix x Vector
                        if (size1[1] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
                        }
                        break;
                    case 2:
                        // Matrix x Matrix
                        if (size1[1] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
                        }
                        break;
                    default:
                        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
                }
                break;
            default:
                throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
        }
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (N)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {number}             Scalar value
   */ function _multiplyVectorVector(a, b, n) {
        // check empty vector
        if (n === 0) {
            throw new Error('Cannot multiply two empty vectors');
        }
        return dot(a, b);
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Matrix         (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */ function _multiplyVectorMatrix(a, b) {
        // process storage
        if (b.storage() !== 'dense') {
            throw new Error('Support for SparseMatrix not implemented');
        }
        return _multiplyVectorDenseMatrix(a, b);
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Dense Matrix   (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */ function _multiplyVectorDenseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var alength = asize[0];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix columns
        for(var j = 0; j < bcolumns; j++){
            // sum (do not initialize it with zero)
            var sum = mf(adata[0], bdata[0][j]);
            // loop vector
            for(var i = 1; i < alength; i++){
                // multiply & accumulate
                sum = af(sum, mf(adata[i], bdata[i][j]));
            }
            c[j] = sum;
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {Matrix}             Dense Vector   (M)
   */ var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
        'DenseMatrix, any': _multiplyDenseMatrixVector,
        'SparseMatrix, any': _multiplySparseMatrixVector
    });
    /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Matrix         (NxC)
   *
   * @return {Matrix}             Matrix         (MxC)
   */ var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
        'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
        'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
        'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
        'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
    });
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix  (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             Dense Vector (M)
   */ function _multiplyDenseMatrixVector(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = asize[0];
        var acolumns = asize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix a rows
        for(var i = 0; i < arows; i++){
            // current row
            var row = adata[i];
            // sum (do not initialize it with zero)
            var sum = mf(row[0], bdata[0]);
            // loop matrix a columns
            for(var j = 1; j < acolumns; j++){
                // multiply & accumulate
                sum = af(sum, mf(row[j], bdata[j]));
            }
            c[i] = sum;
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                arows
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            DenseMatrix    (NxC)
   *
   * @return {Matrix}             DenseMatrix    (MxC)
   */ function _multiplyDenseMatrixDenseMatrix(a, b) {
        // getDataType()
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = asize[0];
        var acolumns = asize[1];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix a rows
        for(var i = 0; i < arows; i++){
            // current row
            var row = adata[i];
            // initialize row array
            c[i] = [];
            // loop matrix b columns
            for(var j = 0; j < bcolumns; j++){
                // sum (avoid initializing sum to zero)
                var sum = mf(row[0], bdata[0][j]);
                // loop matrix a columns
                for(var x = 1; x < acolumns; x++){
                    // multiply & accumulate
                    sum = af(sum, mf(row[x], bdata[x][j]));
                }
                c[i][j] = sum;
            }
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            SparseMatrix   (NxC)
   *
   * @return {Matrix}             SparseMatrix   (MxC)
   */ function _multiplyDenseMatrixSparseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b sparse
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate b matrix
        if (!bvalues) {
            throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
        }
        // rows & columns
        var arows = asize[0];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = b.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // indeces in column jb
            var kb0 = bptr[jb];
            var kb1 = bptr[jb + 1];
            // do not process column jb if no data exists
            if (kb1 > kb0) {
                // last row mark processed
                var last = 0;
                // loop a rows
                for(var i = 0; i < arows; i++){
                    // column mark
                    var mark = i + 1;
                    // C[i, jb]
                    var cij = void 0;
                    // values in b column j
                    for(var kb = kb0; kb < kb1; kb++){
                        // row
                        var ib = bindex[kb];
                        // check value has been initialized
                        if (last !== mark) {
                            // first value in column jb
                            cij = mf(adata[i][ib], bvalues[kb]);
                            // update mark
                            last = mark;
                        } else {
                            // accumulate value
                            cij = af(cij, mf(adata[i][ib], bvalues[kb]));
                        }
                    }
                    // check column has been processed and value != 0
                    if (last === mark && !eq(cij, zero)) {
                        // push row & value
                        cindex.push(i);
                        cvalues.push(cij);
                    }
                }
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix    (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             SparseMatrix    (M, 1)
   */ function _multiplySparseMatrixVector(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // validate a matrix
        if (!avalues) {
            throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        }
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var brows = b._size[0];
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // workspace
        var x = [];
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // update ptr
        cptr[0] = 0;
        // rows in b
        for(var ib = 0; ib < brows; ib++){
            // b[ib]
            var vbi = bdata[ib];
            // check b[ib] != 0, avoid loops
            if (!eq(vbi, zero)) {
                // A values & index in ib column
                for(var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                    // a row
                    var ia = aindex[ka];
                    // check value exists in current j
                    if (!w[ia]) {
                        // ia is new entry in j
                        w[ia] = true;
                        // add i to pattern of C
                        cindex.push(ia);
                        // x(ia) = A
                        x[ia] = mf(vbi, avalues[ka]);
                    } else {
                        // i exists in C already
                        x[ia] = af(x[ia], mf(vbi, avalues[ka]));
                    }
                }
            }
        }
        // copy values from x to column jb of c
        for(var p1 = cindex.length, p = 0; p < p1; p++){
            // row
            var ic = cindex[p];
            // copy value
            cvalues[p] = x[ic];
        }
        // update ptr
        cptr[1] = cindex.length;
        // matrix to return
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                1
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            DenseMatrix       (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */ function _multiplySparseMatrixDenseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // validate a matrix
        if (!avalues) {
            throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        }
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var brows = b._size[0];
        var bcolumns = b._size[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // workspace
        var x = [];
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // mark in workspace for current column
            var mark = jb + 1;
            // rows in jb
            for(var ib = 0; ib < brows; ib++){
                // b[ib, jb]
                var vbij = bdata[ib][jb];
                // check b[ib, jb] != 0, avoid loops
                if (!eq(vbij, zero)) {
                    // A values & index in ib column
                    for(var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // a row
                        var ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                            // x(ia) = A
                            x[ia] = mf(vbij, avalues[ka]);
                        } else {
                            // i exists in C already
                            x[ia] = af(x[ia], mf(vbij, avalues[ka]));
                        }
                    }
                }
            }
            // copy values from x to column jb of c
            for(var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++){
                // row
                var ic = cindex[p];
                // copy value
                cvalues[p] = x[ic];
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            SparseMatrix      (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */ function _multiplySparseMatrixSparseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // b sparse
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var bcolumns = b._size[1];
        // flag indicating both matrices (a & b) contain data
        var values = avalues && bvalues;
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var cvalues = values ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // workspace
        var x = values ? [] : undefined;
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // variables
        var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // mark in workspace for current column
            var mark = jb + 1;
            // B values & index in j
            for(kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++){
                // b row
                ib = bindex[kb];
                // check we need to process values
                if (values) {
                    // loop values in a[:,ib]
                    for(ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // row
                        ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                            // x(ia) = A
                            x[ia] = mf(bvalues[kb], avalues[ka]);
                        } else {
                            // i exists in C already
                            x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
                        }
                    }
                } else {
                    // loop values in a[:,ib]
                    for(ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // row
                        ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                        }
                    }
                }
            }
            // check we need to process matrix values (pattern matrix)
            if (values) {
                // copy values from x to column jb of c
                for(var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++){
                    // row
                    var ic = cindex[p];
                    // copy value
                    cvalues[p] = x[ic];
                }
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * Multiply two or more values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *    math.multiply(x, y, z, ...)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2)        // returns number 20.8
   *    math.multiply(2, 3, 4)       // returns number 24
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.multiply(a, b)          // returns Complex 5 + 14i
   *
   *    const c = [[1, 2], [4, 3]]
   *    const d = [[1, 2, 3], [3, -4, 7]]
   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    const e = math.unit('2.1 km')
   *    math.multiply(3, e)          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide, prod, cross, dot
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */ return typed(name, multiplyScalar, {
        // we extend the signatures of multiplyScalar with signatures dealing with matrices
        'Array, Array': typed.referTo('Matrix, Matrix', (selfMM)=>(x, y)=>{
                // check dimensions
                _validateMatrixDimensions((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(y));
                // use dense matrix implementation
                var m = selfMM(matrix(x), matrix(y));
                // return array or scalar
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(m) ? m.valueOf() : m;
            }),
        'Matrix, Matrix': function Matrix_Matrix(x, y) {
            // dimensions
            var xsize = x.size();
            var ysize = y.size();
            // check dimensions
            _validateMatrixDimensions(xsize, ysize);
            // process dimensions
            if (xsize.length === 1) {
                // process y dimensions
                if (ysize.length === 1) {
                    // Vector * Vector
                    return _multiplyVectorVector(x, y, xsize[0]);
                }
                // Vector * Matrix
                return _multiplyVectorMatrix(x, y);
            }
            // process y dimensions
            if (ysize.length === 1) {
                // Matrix * Vector
                return _multiplyMatrixVector(x, y);
            }
            // Matrix * Matrix
            return _multiplyMatrixMatrix(x, y);
        },
        'Matrix, Array': typed.referTo('Matrix,Matrix', (selfMM)=>(x, y)=>selfMM(x, matrix(y))),
        'Array, Matrix': typed.referToSelf((self)=>(x, y)=>{
                // use Matrix * Matrix implementation
                return self(matrix(x, y.storage()), y);
            }),
        'SparseMatrix, any': function SparseMatrix_any(x, y) {
            return matAlgo11xS0s(x, y, multiplyScalar, false);
        },
        'DenseMatrix, any': function DenseMatrix_any(x, y) {
            return matAlgo14xDs(x, y, multiplyScalar, false);
        },
        'any, SparseMatrix': function any_SparseMatrix(x, y) {
            return matAlgo11xS0s(y, x, multiplyScalar, true);
        },
        'any, DenseMatrix': function any_DenseMatrix(x, y) {
            return matAlgo14xDs(y, x, multiplyScalar, true);
        },
        'Array, any': function Array_any(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();
        },
        'any, Array': function any_Array(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();
        },
        'any, any': multiplyScalar,
        'any, any, ...any': typed.referToSelf((self)=>(x, y, rest)=>{
                var result = self(x, y);
                for(var i = 0; i < rest.length; i++){
                    result = self(result, rest[i]);
                }
                return result;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/range.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRange": (()=>createRange)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/noop.js [app-ssr] (ecmascript)");
;
;
var name = 'range';
var dependencies = [
    'typed',
    'config',
    '?matrix',
    '?bignumber',
    'smaller',
    'smallerEq',
    'larger',
    'largerEq',
    'add',
    'isPositive'
];
var createRange = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, bignumber, smaller, smallerEq, larger, largerEq, add, isPositive } = _ref;
    /**
   * Create a matrix or array containing a range of values.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: string`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {number | bigint | BigNumber | Fraction | Unit}`
   *   Start of the range
   * - `end: number | bigint | BigNumber | Fraction | Unit`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: number | bigint | BigNumber | Fraction | Unit`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * The function returns a `DenseMatrix` when the library is configured with
   * `config = { matrix: 'Matrix' }, and returns an Array otherwise.
   * Note that the type of the returned values is taken from the type of the
   * provided start/end value. If only one of these is a built-in `number` type,
   * it will be promoted to the type of the other endpoint. However, in the case
   * of Unit values, both endpoints must have compatible units, and the return
   * value will have compatible units as well.
   *
   * Examples:
   *
   *     math.range(2, 6)        // [2, 3, 4, 5]
   *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6')     // [2, 3, 4, 5]
   *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
   *     math.range(2, math.fraction(8,3), math.fraction(1,3)) // [fraction(2), fraction(7,3)]
   *     math.range(math.unit(2, 'm'), math.unit(-3, 'm'), math.unit(-1, 'm')) // [2 m, 1 m, 0 m , -1 m, -2 m]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the range's `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */ return typed(name, {
        // TODO: simplify signatures when typed-function supports default values and optional arguments
        string: _strRange,
        'string, boolean': _strRange,
        number: function number(oops) {
            throw new TypeError("Too few arguments to function range(): ".concat(oops));
        },
        boolean: function boolean(oops) {
            throw new TypeError("Unexpected type of argument 1 to function range(): ".concat(oops, ", number|bigint|BigNumber|Fraction"));
        },
        'number, number': function number_number(start, end) {
            return _out(_range(start, end, 1, false));
        },
        'number, number, number': function number_number_number(start, end, step) {
            return _out(_range(start, end, step, false));
        },
        'number, number, boolean': function number_number_boolean(start, end, includeEnd) {
            return _out(_range(start, end, 1, includeEnd));
        },
        'number, number, number, boolean': function number_number_number_boolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
        },
        // Handle bigints; if either limit is bigint, range should be too
        'bigint, bigint|number': function bigint_bigintNumber(start, end) {
            return _out(_range(start, end, 1n, false));
        },
        'number, bigint': function number_bigint(start, end) {
            return _out(_range(BigInt(start), end, 1n, false));
        },
        'bigint, bigint|number, bigint|number': function bigint_bigintNumber_bigintNumber(start, end, step) {
            return _out(_range(start, end, BigInt(step), false));
        },
        'number, bigint, bigint|number': function number_bigint_bigintNumber(start, end, step) {
            return _out(_range(BigInt(start), end, BigInt(step), false));
        },
        'bigint, bigint|number, boolean': function bigint_bigintNumber_boolean(start, end, includeEnd) {
            return _out(_range(start, end, 1n, includeEnd));
        },
        'number, bigint, boolean': function number_bigint_boolean(start, end, includeEnd) {
            return _out(_range(BigInt(start), end, 1n, includeEnd));
        },
        'bigint, bigint|number, bigint|number, boolean': function bigint_bigintNumber_bigintNumber_boolean(start, end, step, includeEnd) {
            return _out(_range(start, end, BigInt(step), includeEnd));
        },
        'number, bigint, bigint|number, boolean': function number_bigint_bigintNumber_boolean(start, end, step, includeEnd) {
            return _out(_range(BigInt(start), end, BigInt(step), includeEnd));
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(start, end) {
            var BigNumber = start.constructor;
            return _out(_range(start, end, new BigNumber(1), false));
        },
        'BigNumber, BigNumber, BigNumber': function BigNumber_BigNumber_BigNumber(start, end, step) {
            return _out(_range(start, end, step, false));
        },
        'BigNumber, BigNumber, boolean': function BigNumber_BigNumber_boolean(start, end, includeEnd) {
            var BigNumber = start.constructor;
            return _out(_range(start, end, new BigNumber(1), includeEnd));
        },
        'BigNumber, BigNumber, BigNumber, boolean': function BigNumber_BigNumber_BigNumber_boolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
        },
        'Fraction, Fraction': function Fraction_Fraction(start, end) {
            return _out(_range(start, end, 1, false));
        },
        'Fraction, Fraction, Fraction': function Fraction_Fraction_Fraction(start, end, step) {
            return _out(_range(start, end, step, false));
        },
        'Fraction, Fraction, boolean': function Fraction_Fraction_boolean(start, end, includeEnd) {
            return _out(_range(start, end, 1, includeEnd));
        },
        'Fraction, Fraction, Fraction, boolean': function Fraction_Fraction_Fraction_boolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
        },
        'Unit, Unit, Unit': function Unit_Unit_Unit(start, end, step) {
            return _out(_range(start, end, step, false));
        },
        'Unit, Unit, Unit, boolean': function Unit_Unit_Unit_boolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
        }
    });
    "TURBOPACK unreachable";
    function _out(arr) {
        if (config.matrix === 'Matrix') {
            return matrix ? matrix(arr) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noMatrix"])();
        }
        return arr;
    }
    function _strRange(str, includeEnd) {
        var r = _parse(str);
        if (!r) {
            throw new SyntaxError('String "' + str + '" is no valid range');
        }
        if (config.number === 'BigNumber') {
            if (bignumber === undefined) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noBignumber"])();
            }
            return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)), includeEnd);
        } else {
            return _out(_range(r.start, r.end, r.step, includeEnd));
        }
    }
    /**
   * Create a range with numbers or BigNumbers
   * @param {number | BigNumber | Unit} start
   * @param {number | BigNumber | Unit} end
   * @param {number | BigNumber | Unit} step
   * @param {boolean} includeEnd
   * @returns {Array} range
   * @private
   */ function _range(start, end, step, includeEnd) {
        var array = [];
        var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
        var x = start;
        while(ongoing(x, end)){
            array.push(x);
            x = add(x, step);
        }
        return array;
    }
    /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @param {string} str
   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
   * @private
   */ function _parse(str) {
        var args = str.split(':');
        // number
        var nums = args.map(function(arg) {
            // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
            return Number(arg);
        });
        var invalid = nums.some(function(num) {
            return isNaN(num);
        });
        if (invalid) {
            return null;
        }
        switch(nums.length){
            case 2:
                return {
                    start: nums[0],
                    end: nums[1],
                    step: 1
                };
            case 3:
                return {
                    start: nums[0],
                    end: nums[2],
                    step: nums[1]
                };
            default:
                return null;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/row.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRow": (()=>createRow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'row';
var dependencies = [
    'typed',
    'Index',
    'matrix',
    'range'
];
var createRow = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Index, matrix, range } = _ref;
    /**
   * Return a row from a Matrix.
   *
   * Syntax:
   *
   *     math.row(value, index)
   *
   * Example:
   *
   *     // get a row
   *     const d = [[1, 2], [3, 4]]
   *     math.row(d, 1) // returns [[3, 4]]
   *
   * See also:
   *
   *     column
   *
   * @param {Array | Matrix } value   An array or matrix
   * @param {number} row              The index of the row
   * @return {Array | Matrix}         The retrieved row
   */ return typed(name, {
        'Matrix, number': _row,
        'Array, number': function Array_number(value, row) {
            return _row(matrix((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(value)), row).valueOf();
        }
    });
    "TURBOPACK unreachable";
    /**
   * Retrieve a row of a matrix
   * @param {Matrix } value  A matrix
   * @param {number} row     The index of the row
   * @return {Matrix}        The retrieved row
   */ function _row(value, row) {
        // check dimensions
        if (value.size().length !== 2) {
            throw new Error('Only two dimensional matrix is supported');
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(row, value.size()[0]);
        var columnRange = range(0, value.size()[1]);
        var index = new Index(row, columnRange);
        var result = value.subset(index);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(result) ? result : matrix([
            [
                result
            ]
        ]);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setCartesian.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetCartesian": (()=>createSetCartesian)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setCartesian';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index',
    'DenseMatrix'
];
var createSetCartesian = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index, DenseMatrix } = _ref;
    /**
   * Create the cartesian product of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays
   * and the values will be sorted in ascending order before the operation.
   *
   * Syntax:
   *
   *    math.setCartesian(set1, set2)
   *
   * Examples:
   *
   *    math.setCartesian([1, 2], [3, 4])        // returns [[1, 3], [1, 4], [2, 3], [2, 4]]
   *    math.setCartesian([4, 3], [2, 1])        // returns [[3, 1], [3, 2], [4, 1], [4, 2]]
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference, setPowerset
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The cartesian product of two (multi)sets
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            var result = [];
            if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
                // if any of them is empty, return empty
                var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
                var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
                result = [];
                for(var i = 0; i < b1.length; i++){
                    for(var j = 0; j < b2.length; j++){
                        result.push([
                            b1[i],
                            b2[j]
                        ]);
                    }
                }
            }
            // return an array, if both inputs were arrays
            if (Array.isArray(a1) && Array.isArray(a2)) {
                return result;
            }
            // return a matrix otherwise
            return new DenseMatrix(result);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setDistinct.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetDistinct": (()=>createSetDistinct)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setDistinct';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index',
    'DenseMatrix'
];
var createSetDistinct = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index, DenseMatrix } = _ref;
    /**
   * Collect the distinct elements of a multiset.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setDistinct(set)
   *
   * Examples:
   *
   *    math.setDistinct([1, 1, 1, 2, 2, 3])        // returns [1, 2, 3]
   *
   * See also:
   *
   *    setMultiplicity
   *
   * @param {Array | Matrix}    a  A multiset
   * @return {Array | Matrix}    A set containing the distinc elements of the multiset
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(a) {
            var result;
            if (subset(size(a), new Index(0)) === 0) {
                // if empty, return empty
                result = [];
            } else {
                var b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
                result = [];
                result.push(b[0]);
                for(var i = 1; i < b.length; i++){
                    if (compareNatural(b[i], b[i - 1]) !== 0) {
                        result.push(b[i]);
                    }
                }
            }
            // return an array, if the input was an array
            if (Array.isArray(a)) {
                return result;
            }
            // return a matrix otherwise
            return new DenseMatrix(result);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setIsSubset.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetIsSubset": (()=>createSetIsSubset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setIsSubset';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index'
];
var createSetIsSubset = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index } = _ref;
    /**
   * Check whether a (multi)set is a subset of another (multi)set. (Every element of set1 is the element of set2.)
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setIsSubset(set1, set2)
   *
   * Examples:
   *
   *    math.setIsSubset([1, 2], [3, 4, 5, 6])        // returns false
   *    math.setIsSubset([3, 4], [3, 4, 5, 6])        // returns true
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {boolean} Returns true when a1 is a subset of a2, returns false otherwise
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            if (subset(size(a1), new Index(0)) === 0) {
                // empty is a subset of anything
                return true;
            } else if (subset(size(a2), new Index(0)) === 0) {
                // anything is not a subset of empty
                return false;
            }
            var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
            var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
            var inb2;
            for(var i = 0; i < b1.length; i++){
                inb2 = false;
                for(var j = 0; j < b2.length; j++){
                    if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                        // the identifier is always a decimal int
                        inb2 = true;
                        break;
                    }
                }
                if (inb2 === false) {
                    return false;
                }
            }
            return true;
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setPowerset.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetPowerset": (()=>createSetPowerset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setPowerset';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index'
];
var createSetPowerset = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index } = _ref;
    /**
   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setPowerset(set)
   *
   * Examples:
   *
   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
   *
   * See also:
   *
   *    setCartesian
   *
   * @param {Array | Matrix}    a  A (multi)set
   * @return {Array}    The powerset of the (multi)set
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(a) {
            if (subset(size(a), new Index(0)) === 0) {
                // if empty, return empty
                return [];
            }
            var b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
            var result = [];
            var number = 0;
            while(number.toString(2).length <= b.length){
                result.push(_subset(b, number.toString(2).split('').reverse()));
                number++;
            }
            // can not return a matrix, because of the different size of the subarrays
            return _sort(result);
        }
    });
    "TURBOPACK unreachable";
    // create subset
    function _subset(array, bitarray) {
        var result = [];
        for(var i = 0; i < bitarray.length; i++){
            if (bitarray[i] === '1') {
                result.push(array[i]);
            }
        }
        return result;
    }
    // sort subsests by length
    function _sort(array) {
        var temp = [];
        for(var i = array.length - 1; i > 0; i--){
            for(var j = 0; j < i; j++){
                if (array[j].length > array[j + 1].length) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        return array;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Permutes a sparse matrix C = P * A * Q
 *
 * @param {SparseMatrix}  a         The Matrix A
 * @param {Array}   pinv            The row permutation vector
 * @param {Array}   q               The column permutation vector
 * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
 *
 * @return {Matrix}                 C = P * A * Q, null on error
 */ __turbopack_context__.s({
    "csPermute": (()=>csPermute)
});
function csPermute(a, pinv, q, values) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // c arrays
    var cvalues = values && a._values ? [] : null;
    var cindex = []; // (aptr[n])
    var cptr = []; // (n + 1)
    // initialize vars
    var nz = 0;
    // loop columns
    for(var k = 0; k < n; k++){
        // column k of C is column q[k] of A
        cptr[k] = nz;
        // apply column permutation
        var j = q ? q[k] : k;
        // loop values in column j of A
        for(var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++){
            // row i of A is row pinv[i] of C
            var r = pinv ? pinv[aindex[t]] : aindex[t];
            // index
            cindex[nz] = r;
            // check we need to populate values
            if (cvalues) {
                cvalues[nz] = avalues[t];
            }
            // increment number of nonzero elements
            nz++;
        }
    }
    // finalize the last column of C
    cptr[n] = nz;
    // return C matrix
    return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [
            m,
            n
        ],
        datatype: adt
    });
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Depth-first search and postorder of a tree rooted at node j
 *
 * @param {Number}  j               The tree node
 * @param {Number}  k
 * @param {Array}   w               The workspace array
 * @param {Number}  head            The index offset within the workspace for the head array
 * @param {Number}  next            The index offset within the workspace for the next array
 * @param {Array}   post            The post ordering array
 * @param {Number}  stack           The index offset within the workspace for the stack array
 */ __turbopack_context__.s({
    "csTdfs": (()=>csTdfs)
});
function csTdfs(j, k, w, head, next, post, stack) {
    // variables
    var top = 0;
    // place j on the stack
    w[stack] = j;
    // while (stack is not empty)
    while(top >= 0){
        // p = top of stack
        var p = w[stack + top];
        // i = youngest child of p
        var i = w[head + p];
        if (i === -1) {
            // p has no unordered children left
            top--;
            // node p is the kth postordered node
            post[k++] = p;
        } else {
            // remove i from children of p
            w[head + p] = w[next + i];
            // increment top
            ++top;
            // start dfs on child node i
            w[stack + top] = i;
        }
    }
    return k;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csPost": (()=>csPost)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-ssr] (ecmascript)");
;
function csPost(parent, n) {
    // check inputs
    if (!parent) {
        return null;
    }
    // vars
    var k = 0;
    var j;
    // allocate result
    var post = []; // (n)
    // workspace, head: first n entries, next: next n entries, stack: last n entries
    var w = []; // (3 * n)
    var head = 0;
    var next = n;
    var stack = 2 * n;
    // initialize workspace
    for(j = 0; j < n; j++){
        // empty linked lists
        w[head + j] = -1;
    }
    // traverse nodes in reverse order
    for(j = n - 1; j >= 0; j--){
        // check j is a root
        if (parent[j] === -1) {
            continue;
        }
        // add j to list of its parent
        w[next + j] = w[head + parent[j]];
        w[head + parent[j]] = j;
    }
    // loop nodes
    for(j = 0; j < n; j++){
        // skip j if it is not a root
        if (parent[j] !== -1) {
            continue;
        }
        // depth-first search
        k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csTdfs"])(j, k, w, head, next, post, stack);
    }
    return post;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Computes the elimination tree of Matrix A (using triu(A)) or the
 * elimination tree of A'A without forming A'A.
 *
 * @param {Matrix}  a               The A Matrix
 * @param {boolean} ata             A value of true the function computes the etree of A'A
 */ __turbopack_context__.s({
    "csEtree": (()=>csEtree)
});
function csEtree(a, ata) {
    // check inputs
    if (!a) {
        return null;
    }
    // a arrays
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // allocate result
    var parent = []; // (n)
    // allocate workspace
    var w = []; // (n + (ata ? m : 0))
    var ancestor = 0; // first n entries in w
    var prev = n; // last m entries (ata = true)
    var i, inext;
    // check we are calculating A'A
    if (ata) {
        // initialize workspace
        for(i = 0; i < m; i++){
            w[prev + i] = -1;
        }
    }
    // loop columns
    for(var k = 0; k < n; k++){
        // node k has no parent yet
        parent[k] = -1;
        // nor does k have an ancestor
        w[ancestor + k] = -1;
        // values in column k
        for(var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++){
            // row
            var r = aindex[p];
            // node
            i = ata ? w[prev + r] : r;
            // traverse from i to k
            for(; i !== -1 && i < k; i = inext){
                // inext = ancestor of i
                inext = w[ancestor + i];
                // path compression
                w[ancestor + i] = k;
                // check no anc., parent is k
                if (inext === -1) {
                    parent[i] = k;
                }
            }
            if (ata) {
                w[prev + r] = k;
            }
        }
    }
    return parent;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
 *
 * @param {Matrix}   a              The sparse matrix
 * @param {function} callback       The callback function, function will be invoked with the following args:
 *                                    - The entry row
 *                                    - The entry column
 *                                    - The entry value
 *                                    - The state parameter
 * @param {any}      other          The state
 *
 * @return                          The number of nonzero elements in the matrix
 */ __turbopack_context__.s({
    "csFkeep": (()=>csFkeep)
});
function csFkeep(a, callback, other) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // columns
    var n = asize[1];
    // nonzero items
    var nz = 0;
    // loop columns
    for(var j = 0; j < n; j++){
        // get current location of col j
        var p = aptr[j];
        // record new location of col j
        aptr[j] = nz;
        for(; p < aptr[j + 1]; p++){
            // check we need to keep this item
            if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
                // keep A(i,j)
                aindex[nz] = aindex[p];
                // check we need to process values (pattern only)
                if (avalues) {
                    avalues[nz] = avalues[p];
                }
                // increment nonzero items
                nz++;
            }
        }
    }
    // finalize A
    aptr[n] = nz;
    // trim arrays
    aindex.splice(nz, aindex.length - nz);
    // check we need to process values (pattern only)
    if (avalues) {
        avalues.splice(nz, avalues.length - nz);
    }
    // return number of nonzero items
    return nz;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * This function "flips" its input about the integer -1.
 *
 * @param {Number}  i               The value to flip
 */ __turbopack_context__.s({
    "csFlip": (()=>csFlip)
});
function csFlip(i) {
    // flip the value
    return -i - 2;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsAmd": (()=>createCsAmd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFkeep$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'csAmd';
var dependencies = [
    'add',
    'multiply',
    'transpose'
];
var createCsAmd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { add, multiply, transpose } = _ref;
    /**
   * Approximate minimum degree ordering. The minimum degree algorithm is a widely used
   * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
   * than A. It is a gready method that selects the sparsest pivot row and column during the course
   * of a right looking sparse Cholesky factorization.
   *
   * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
   * @param {Matrix} m        Sparse Matrix
   */ return function csAmd(order, a) {
        // check input parameters
        if (!a || order <= 0 || order > 3) {
            return null;
        }
        // a matrix arrays
        var asize = a._size;
        // rows and columns
        var m = asize[0];
        var n = asize[1];
        // initialize vars
        var lemax = 0;
        // dense threshold
        var dense = Math.max(16, 10 * Math.sqrt(n));
        dense = Math.min(n - 2, dense);
        // create target matrix C
        var cm = _createTargetMatrix(order, a, m, n, dense);
        // drop diagonal entries
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFkeep$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFkeep"])(cm, _diag, null);
        // C matrix arrays
        var cindex = cm._index;
        var cptr = cm._ptr;
        // number of nonzero elements in C
        var cnz = cptr[n];
        // allocate result (n+1)
        var P = [];
        // create workspace (8 * (n + 1))
        var W = [];
        var len = 0; // first n + 1 entries
        var nv = n + 1; // next n + 1 entries
        var next = 2 * (n + 1); // next n + 1 entries
        var head = 3 * (n + 1); // next n + 1 entries
        var elen = 4 * (n + 1); // next n + 1 entries
        var degree = 5 * (n + 1); // next n + 1 entries
        var w = 6 * (n + 1); // next n + 1 entries
        var hhead = 7 * (n + 1); // last n + 1 entries
        // use P as workspace for last
        var last = P;
        // initialize quotient graph
        var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
        // initialize degree lists
        var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
        // minimum degree node
        var mindeg = 0;
        // vars
        var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
        // while (selecting pivots) do
        while(nel < n){
            // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
            // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
            // many nodes have been eliminated.
            for(k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++);
            if (W[next + k] !== -1) {
                last[W[next + k]] = -1;
            }
            // remove k from degree list
            W[head + mindeg] = W[next + k];
            // elenk = |Ek|
            var elenk = W[elen + k];
            // # of nodes k represents
            var nvk = W[nv + k];
            // W[nv + k] nodes of A eliminated
            nel += nvk;
            // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is
            // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
            // degree lists. All elements e in Ek are absorved into element k.
            var dk = 0;
            // flag k as in Lk
            W[nv + k] = -nvk;
            var p = cptr[k];
            // do in place if W[elen + k] === 0
            var pk1 = elenk === 0 ? p : cnz;
            var pk2 = pk1;
            for(k1 = 1; k1 <= elenk + 1; k1++){
                if (k1 > elenk) {
                    // search the nodes in k
                    e = k;
                    // list of nodes starts at cindex[pj]
                    pj = p;
                    // length of list of nodes in k
                    ln = W[len + k] - elenk;
                } else {
                    // search the nodes in e
                    e = cindex[p++];
                    pj = cptr[e];
                    // length of list of nodes in e
                    ln = W[len + e];
                }
                for(k2 = 1; k2 <= ln; k2++){
                    i = cindex[pj++];
                    // check  node i dead, or seen
                    if ((nvi = W[nv + i]) <= 0) {
                        continue;
                    }
                    // W[degree + Lk] += size of node i
                    dk += nvi;
                    // negate W[nv + i] to denote i in Lk
                    W[nv + i] = -nvi;
                    // place i in Lk
                    cindex[pk2++] = i;
                    if (W[next + i] !== -1) {
                        last[W[next + i]] = last[i];
                    }
                    // check we need to remove i from degree list
                    if (last[i] !== -1) {
                        W[next + last[i]] = W[next + i];
                    } else {
                        W[head + W[degree + i]] = W[next + i];
                    }
                }
                if (e !== k) {
                    // absorb e into k
                    cptr[e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(k);
                    // e is now a dead element
                    W[w + e] = 0;
                }
            }
            // cindex[cnz...nzmax] is free
            if (elenk !== 0) {
                cnz = pk2;
            }
            // external degree of k - |Lk\i|
            W[degree + k] = dk;
            // element k is in cindex[pk1..pk2-1]
            cptr[k] = pk1;
            W[len + k] = pk2 - pk1;
            // k is now an element
            W[elen + k] = -2;
            // Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
            // scan, no entry in the w array is greater than or equal to mark.
            // clear w if necessary
            mark = _wclear(mark, lemax, W, w, n);
            // scan 1: find |Le\Lk|
            for(pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check if W[elen + i] empty, skip it
                if ((eln = W[elen + i]) <= 0) {
                    continue;
                }
                // W[nv + i] was negated
                nvi = -W[nv + i];
                var wnvi = mark - nvi;
                // scan Ei
                for(p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++){
                    e = cindex[p];
                    if (W[w + e] >= mark) {
                        // decrement |Le\Lk|
                        W[w + e] -= nvi;
                    } else if (W[w + e] !== 0) {
                        // ensure e is a live element, 1st time e seen in scan 1
                        W[w + e] = W[degree + e] + wnvi;
                    }
                }
            }
            // degree update
            // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
            // function h(i) for all nodes in Lk.
            // scan2: degree update
            for(pk = pk1; pk < pk2; pk++){
                // consider node i in Lk
                i = cindex[pk];
                p1 = cptr[i];
                p2 = p1 + W[elen + i] - 1;
                pn = p1;
                // scan Ei
                for(h = 0, d = 0, p = p1; p <= p2; p++){
                    e = cindex[p];
                    // check e is an unabsorbed element
                    if (W[w + e] !== 0) {
                        // dext = |Le\Lk|
                        var dext = W[w + e] - mark;
                        if (dext > 0) {
                            // sum up the set differences
                            d += dext;
                            // keep e in Ei
                            cindex[pn++] = e;
                            // compute the hash of node i
                            h += e;
                        } else {
                            // aggressive absorb. e->k
                            cptr[e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(k);
                            // e is a dead element
                            W[w + e] = 0;
                        }
                    }
                }
                // W[elen + i] = |Ei|
                W[elen + i] = pn - p1 + 1;
                var p3 = pn;
                var p4 = p1 + W[len + i];
                // prune edges in Ai
                for(p = p2 + 1; p < p4; p++){
                    j = cindex[p];
                    // check node j dead or in Lk
                    var nvj = W[nv + j];
                    if (nvj <= 0) {
                        continue;
                    }
                    // degree(i) += |j|
                    d += nvj;
                    // place j in node list of i
                    cindex[pn++] = j;
                    // compute hash for node i
                    h += j;
                }
                // check for mass elimination
                if (d === 0) {
                    // absorb i into k
                    cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(k);
                    nvi = -W[nv + i];
                    // |Lk| -= |i|
                    dk -= nvi;
                    // |k| += W[nv + i]
                    nvk += nvi;
                    nel += nvi;
                    W[nv + i] = 0;
                    // node i is dead
                    W[elen + i] = -1;
                } else {
                    // update degree(i)
                    W[degree + i] = Math.min(W[degree + i], d);
                    // move first node to end
                    cindex[pn] = cindex[p3];
                    // move 1st el. to end of Ei
                    cindex[p3] = cindex[p1];
                    // add k as 1st element in of Ei
                    cindex[p1] = k;
                    // new len of adj. list of node i
                    W[len + i] = pn - p1 + 1;
                    // finalize hash of i
                    h = (h < 0 ? -h : h) % n;
                    // place i in hash bucket
                    W[next + i] = W[hhead + h];
                    W[hhead + h] = i;
                    // save hash of i in last[i]
                    last[i] = h;
                }
            }
            // finalize |Lk|
            W[degree + k] = dk;
            lemax = Math.max(lemax, dk);
            // clear w
            mark = _wclear(mark + lemax, lemax, W, w, n);
            // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
            // If two nodes have identical adjacency lists, their hash functions wil be identical.
            for(pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check i is dead, skip it
                if (W[nv + i] >= 0) {
                    continue;
                }
                // scan hash bucket of node i
                h = last[i];
                i = W[hhead + h];
                // hash bucket will be empty
                W[hhead + h] = -1;
                for(; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++){
                    ln = W[len + i];
                    eln = W[elen + i];
                    for(p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++){
                        W[w + cindex[p]] = mark;
                    }
                    var jlast = i;
                    // compare i with all j
                    for(j = W[next + i]; j !== -1;){
                        var ok = W[len + j] === ln && W[elen + j] === eln;
                        for(p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++){
                            // compare i and j
                            if (W[w + cindex[p]] !== mark) {
                                ok = 0;
                            }
                        }
                        // check i and j are identical
                        if (ok) {
                            // absorb j into i
                            cptr[j] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(i);
                            W[nv + i] += W[nv + j];
                            W[nv + j] = 0;
                            // node j is dead
                            W[elen + j] = -1;
                            // delete j from hash bucket
                            j = W[next + j];
                            W[next + jlast] = j;
                        } else {
                            // j and i are different
                            jlast = j;
                            j = W[next + j];
                        }
                    }
                }
            }
            // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
            // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.
            for(p = pk1, pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check  i is dead, skip it
                if ((nvi = -W[nv + i]) <= 0) {
                    continue;
                }
                // restore W[nv + i]
                W[nv + i] = nvi;
                // compute external degree(i)
                d = W[degree + i] + dk - nvi;
                d = Math.min(d, n - nel - nvi);
                if (W[head + d] !== -1) {
                    last[W[head + d]] = i;
                }
                // put i back in degree list
                W[next + i] = W[head + d];
                last[i] = -1;
                W[head + d] = i;
                // find new minimum degree
                mindeg = Math.min(mindeg, d);
                W[degree + i] = d;
                // place i in Lk
                cindex[p++] = i;
            }
            // # nodes absorbed into k
            W[nv + k] = nvk;
            // length of adj list of element k
            if ((W[len + k] = p - pk1) === 0) {
                // k is a root of the tree
                cptr[k] = -1;
                // k is now a dead element
                W[w + k] = 0;
            }
            if (elenk !== 0) {
                // free unused space in Lk
                cnz = p;
            }
        }
        // Postordering. The elimination is complete, but no permutation has been computed. All that is left
        // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
        // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
        // is computed. The tree is restored by unflipping all of ptr.
        // fix assembly tree
        for(i = 0; i < n; i++){
            cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(cptr[i]);
        }
        for(j = 0; j <= n; j++){
            W[head + j] = -1;
        }
        // place unordered nodes in lists
        for(j = n; j >= 0; j--){
            // skip if j is an element
            if (W[nv + j] > 0) {
                continue;
            }
            // place j in list of its parent
            W[next + j] = W[head + cptr[j]];
            W[head + cptr[j]] = j;
        }
        // place elements in lists
        for(e = n; e >= 0; e--){
            // skip unless e is an element
            if (W[nv + e] <= 0) {
                continue;
            }
            if (cptr[e] !== -1) {
                // place e in list of its parent
                W[next + e] = W[head + cptr[e]];
                W[head + cptr[e]] = e;
            }
        }
        // postorder the assembly tree
        for(k = 0, i = 0; i <= n; i++){
            if (cptr[i] === -1) {
                k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csTdfs"])(i, k, W, head, next, P, w);
            }
        }
        // remove last item in array
        P.splice(P.length - 1, 1);
        // return P
        return P;
    };
    "TURBOPACK unreachable";
    /**
   * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
   * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
   *
   * Order: 0
   *   A natural ordering P=null matrix is returned.
   *
   * Order: 1
   *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
   *   P = M + M'
   *
   * Order: 2
   *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
   *   P = M' * M
   *
   * Order: 3
   *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
   *   P = M' * M
   */ function _createTargetMatrix(order, a, m, n, dense) {
        // compute A'
        var at = transpose(a);
        // check order = 1, matrix must be square
        if (order === 1 && n === m) {
            // C = A + A'
            return add(a, at);
        }
        // check order = 2, drop dense columns from M'
        if (order === 2) {
            // transpose arrays
            var tindex = at._index;
            var tptr = at._ptr;
            // new column index
            var p2 = 0;
            // loop A' columns (rows)
            for(var j = 0; j < m; j++){
                // column j of AT starts here
                var p = tptr[j];
                // new column j starts here
                tptr[j] = p2;
                // skip dense col j
                if (tptr[j + 1] - p > dense) {
                    continue;
                }
                // map rows in column j of A
                for(var p1 = tptr[j + 1]; p < p1; p++){
                    tindex[p2++] = tindex[p];
                }
            }
            // finalize AT
            tptr[m] = p2;
            // recreate A from new transpose matrix
            a = transpose(at);
            // use A' * A
            return multiply(at, a);
        }
        // use A' * A, square or rectangular matrix
        return multiply(at, a);
    }
    /**
   * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
   *
   *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
   *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
   *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
   *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
   */ function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
        // Initialize quotient graph
        for(var k = 0; k < n; k++){
            W[len + k] = cptr[k + 1] - cptr[k];
        }
        W[len + n] = 0;
        // initialize workspace
        for(var i = 0; i <= n; i++){
            // degree list i is empty
            W[head + i] = -1;
            last[i] = -1;
            W[next + i] = -1;
            // hash list i is empty
            W[hhead + i] = -1;
            // node i is just one node
            W[nv + i] = 1;
            // node i is alive
            W[w + i] = 1;
            // Ek of node i is empty
            W[elen + i] = 0;
            // degree of node i
            W[degree + i] = W[len + i];
        }
        // clear w
        var mark = _wclear(0, 0, W, w, n);
        // n is a dead element
        W[elen + n] = -2;
        // n is a root of assembly tree
        cptr[n] = -1;
        // n is a dead element
        W[w + n] = 0;
        // return mark
        return mark;
    }
    /**
   * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with
   * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
   * output permutation p.
   */ function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
        // result
        var nel = 0;
        // loop columns
        for(var i = 0; i < n; i++){
            // degree @ i
            var d = W[degree + i];
            // check node i is empty
            if (d === 0) {
                // element i is dead
                W[elen + i] = -2;
                nel++;
                // i is a root of assembly tree
                cptr[i] = -1;
                W[w + i] = 0;
            } else if (d > dense) {
                // absorb i into element n
                W[nv + i] = 0;
                // node i is dead
                W[elen + i] = -1;
                nel++;
                cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(n);
                W[nv + n]++;
            } else {
                var h = W[head + d];
                if (h !== -1) {
                    last[h] = i;
                }
                // put node i in degree list d
                W[next + i] = W[head + d];
                W[head + d] = i;
            }
        }
        return nel;
    }
    function _wclear(mark, lemax, W, w, n) {
        if (mark < 2 || mark + lemax < 0) {
            for(var k = 0; k < n; k++){
                if (W[w + k] !== 0) {
                    W[w + k] = 1;
                }
            }
            mark = 2;
        }
        // at this point, W [0..n-1] < mark holds
        return mark;
    }
    function _diag(i, j) {
        return i !== j;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * This function determines if j is a leaf of the ith row subtree.
 * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
 *
 * @param {Number}  i               The ith row subtree
 * @param {Number}  j               The node to test
 * @param {Array}   w               The workspace array
 * @param {Number}  first           The index offset within the workspace for the first array
 * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
 * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
 * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
 *
 * @return {Object}
 */ __turbopack_context__.s({
    "csLeaf": (()=>csLeaf)
});
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
    var s, sparent;
    // our result
    var jleaf = 0;
    var q;
    // check j is a leaf
    if (i <= j || w[first + j] <= w[maxfirst + i]) {
        return -1;
    }
    // update max first[j] seen so far
    w[maxfirst + i] = w[first + j];
    // jprev = previous leaf of ith subtree
    var jprev = w[prevleaf + i];
    w[prevleaf + i] = j;
    // check j is first or subsequent leaf
    if (jprev === -1) {
        // 1st leaf, q = root of ith subtree
        jleaf = 1;
        q = i;
    } else {
        // update jleaf
        jleaf = 2;
        // q = least common ancester (jprev,j)
        for(q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]);
        for(s = jprev; s !== q; s = sparent){
            // path compression
            sparent = w[ancestor + s];
            w[ancestor + s] = q;
        }
    }
    return {
        jleaf,
        q
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsCounts": (()=>createCsCounts)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLeaf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js [app-ssr] (ecmascript)");
;
;
var name = 'csCounts';
var dependencies = [
    'transpose'
];
var createCsCounts = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { transpose } = _ref;
    /**
   * Computes the column counts using the upper triangular part of A.
   * It transposes A internally, none of the input parameters are modified.
   *
   * @param {Matrix} a           The sparse matrix A
   *
   * @param {Matrix} ata         Count the columns of A'A instead
   *
   * @return                     An array of size n of the column counts or null on error
   */ return function(a, parent, post, ata) {
        // check inputs
        if (!a || !parent || !post) {
            return null;
        }
        // a matrix arrays
        var asize = a._size;
        // rows and columns
        var m = asize[0];
        var n = asize[1];
        // variables
        var i, j, k, J, p, p0, p1;
        // workspace size
        var s = 4 * n + (ata ? n + m + 1 : 0);
        // allocate workspace
        var w = []; // (s)
        var ancestor = 0; // first n entries
        var maxfirst = n; // next n entries
        var prevleaf = 2 * n; // next n entries
        var first = 3 * n; // next n entries
        var head = 4 * n; // next n + 1 entries (used when ata is true)
        var next = 5 * n + 1; // last entries in workspace
        // clear workspace w[0..s-1]
        for(k = 0; k < s; k++){
            w[k] = -1;
        }
        // allocate result
        var colcount = []; // (n)
        // AT = A'
        var at = transpose(a);
        // at arrays
        var tindex = at._index;
        var tptr = at._ptr;
        // find w[first + j]
        for(k = 0; k < n; k++){
            j = post[k];
            // colcount[j]=1 if j is a leaf
            colcount[j] = w[first + j] === -1 ? 1 : 0;
            for(; j !== -1 && w[first + j] === -1; j = parent[j]){
                w[first + j] = k;
            }
        }
        // initialize ata if needed
        if (ata) {
            // invert post
            for(k = 0; k < n; k++){
                w[post[k]] = k;
            }
            // loop rows (columns in AT)
            for(i = 0; i < m; i++){
                // values in column i of AT
                for(k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++){
                    k = Math.min(k, w[tindex[p]]);
                }
                // place row i in linked list k
                w[next + i] = w[head + k];
                w[head + k] = i;
            }
        }
        // each node in its own set
        for(i = 0; i < n; i++){
            w[ancestor + i] = i;
        }
        for(k = 0; k < n; k++){
            // j is the kth node in postordered etree
            j = post[k];
            // check j is not a root
            if (parent[j] !== -1) {
                colcount[parent[j]]--;
            }
            // J=j for LL'=A case
            for(J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1){
                for(p = tptr[J]; p < tptr[J + 1]; p++){
                    i = tindex[p];
                    var r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLeaf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csLeaf"])(i, j, w, first, maxfirst, prevleaf, ancestor);
                    // check A(i,j) is in skeleton
                    if (r.jleaf >= 1) {
                        colcount[j]++;
                    }
                    // check account for overlap in q
                    if (r.jleaf === 2) {
                        colcount[r.q]--;
                    }
                }
            }
            if (parent[j] !== -1) {
                w[ancestor + j] = parent[j];
            }
        }
        // sum up colcount's of each child
        for(j = 0; j < n; j++){
            if (parent[j] !== -1) {
                colcount[parent[j]] += colcount[j];
            }
        }
        return colcount;
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsSqr": (()=>createCsSqr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPermute$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPost$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csEtree$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csAmd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csCounts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'csSqr';
var dependencies = [
    'add',
    'multiply',
    'transpose'
];
var createCsSqr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { add, multiply, transpose } = _ref;
    var csAmd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csAmd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCsAmd"])({
        add,
        multiply,
        transpose
    });
    var csCounts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csCounts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCsCounts"])({
        transpose
    });
    /**
   * Symbolic ordering and analysis for QR and LU decompositions.
   *
   * @param {Number}  order           The ordering strategy (see csAmd for more details)
   * @param {Matrix}  a               The A matrix
   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
   *                                  symbolic ordering and analysis for LU decomposition (false)
   *
   * @return {Object}                 The Symbolic ordering and analysis for matrix A
   */ return function csSqr(order, a, qr) {
        // a arrays
        var aptr = a._ptr;
        var asize = a._size;
        // columns
        var n = asize[1];
        // vars
        var k;
        // symbolic analysis result
        var s = {};
        // fill-reducing ordering
        s.q = csAmd(order, a);
        // validate results
        if (order && !s.q) {
            return null;
        }
        // QR symbolic analysis
        if (qr) {
            // apply permutations if needed
            var c = order ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPermute$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csPermute"])(a, null, s.q, 0) : a;
            // etree of C'*C, where C=A(:,q)
            s.parent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csEtree$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csEtree"])(c, 1);
            // post order elimination tree
            var post = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPost$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csPost"])(s.parent, n);
            // col counts chol(C'*C)
            s.cp = csCounts(c, s.parent, post, 1);
            // check we have everything needed to calculate number of nonzero elements
            if (c && s.parent && s.cp && _vcount(c, s)) {
                // calculate number of nonzero elements
                for(s.unz = 0, k = 0; k < n; k++){
                    s.unz += s.cp[k];
                }
            }
        } else {
            // for LU factorization only, guess nnz(L) and nnz(U)
            s.unz = 4 * aptr[n] + n;
            s.lnz = s.unz;
        }
        // return result S
        return s;
    };
    "TURBOPACK unreachable";
    /**
   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
   */ function _vcount(a, s) {
        // a arrays
        var aptr = a._ptr;
        var aindex = a._index;
        var asize = a._size;
        // rows & columns
        var m = asize[0];
        var n = asize[1];
        // initialize s arrays
        s.pinv = []; // (m + n)
        s.leftmost = []; // (m)
        // vars
        var parent = s.parent;
        var pinv = s.pinv;
        var leftmost = s.leftmost;
        // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries
        var w = []; // (m + 3 * n)
        var next = 0;
        var head = m;
        var tail = m + n;
        var nque = m + 2 * n;
        // vars
        var i, k, p, p0, p1;
        // initialize w
        for(k = 0; k < n; k++){
            // queue k is empty
            w[head + k] = -1;
            w[tail + k] = -1;
            w[nque + k] = 0;
        }
        // initialize row arrays
        for(i = 0; i < m; i++){
            leftmost[i] = -1;
        }
        // loop columns backwards
        for(k = n - 1; k >= 0; k--){
            // values & index for column k
            for(p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++){
                // leftmost[i] = min(find(A(i,:)))
                leftmost[aindex[p]] = k;
            }
        }
        // scan rows in reverse order
        for(i = m - 1; i >= 0; i--){
            // row i is not yet ordered
            pinv[i] = -1;
            k = leftmost[i];
            // check row i is empty
            if (k === -1) {
                continue;
            }
            // first row in queue k
            if (w[nque + k]++ === 0) {
                w[tail + k] = i;
            }
            // put i at head of queue k
            w[next + i] = w[head + k];
            w[head + k] = i;
        }
        s.lnz = 0;
        s.m2 = m;
        // find row permutation and nnz(V)
        for(k = 0; k < n; k++){
            // remove row i from queue k
            i = w[head + k];
            // count V(k,k) as nonzero
            s.lnz++;
            // add a fictitious row
            if (i < 0) {
                i = s.m2++;
            }
            // associate row i with V(:,k)
            pinv[i] = k;
            // skip if V(k+1:m,k) is empty
            if (--nque[k] <= 0) {
                continue;
            }
            // nque[k] is nnz (V(k+1:m,k))
            s.lnz += w[nque + k];
            // move all rows to parent of k
            var pa = parent[k];
            if (pa !== -1) {
                if (w[nque + pa] === 0) {
                    w[tail + pa] = w[tail + k];
                }
                w[next + w[tail + k]] = w[head + pa];
                w[head + pa] = w[next + i];
                w[nque + pa] += w[nque + k];
            }
        }
        for(i = 0; i < m; i++){
            if (pinv[i] < 0) {
                pinv[i] = k++;
            }
        }
        return true;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Checks if the node at w[j] is marked
 *
 * @param {Array}   w               The array
 * @param {Number}  j               The array index
 */ __turbopack_context__.s({
    "csMarked": (()=>csMarked)
});
function csMarked(w, j) {
    // check node is marked
    return w[j] < 0;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csMark": (()=>csMark)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-ssr] (ecmascript)");
;
function csMark(w, j) {
    // mark w[j]
    w[j] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(w[j]);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csUnflip": (()=>csUnflip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-ssr] (ecmascript)");
;
function csUnflip(i) {
    // flip the value if it is negative
    return i < 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csFlip"])(i) : i;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csDfs": (()=>csDfs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js [app-ssr] (ecmascript)");
;
;
;
function csDfs(j, g, top, xi, pinv) {
    // g arrays
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size;
    // columns
    var n = size[1];
    // vars
    var i, p, p2;
    // initialize head
    var head = 0;
    // initialize the recursion stack
    xi[0] = j;
    // loop
    while(head >= 0){
        // get j from the top of the recursion stack
        j = xi[head];
        // apply permutation vector
        var jnew = pinv ? pinv[j] : j;
        // check node j is marked
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csMarked"])(ptr, j)) {
            // mark node j as visited
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csMark"])(ptr, j);
            // update stack (last n entries in xi)
            xi[n + head] = jnew < 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csUnflip"])(ptr[jnew]);
        }
        // node j done if no unvisited neighbors
        var done = 1;
        // examine all neighbors of j, stack (last n entries in xi)
        for(p = xi[n + head], p2 = jnew < 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csUnflip"])(ptr[jnew + 1]); p < p2; p++){
            // consider neighbor node i
            i = index[p];
            // check we have visited node i, skip it
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csMarked"])(ptr, i)) {
                continue;
            }
            // pause depth-first search of node j, update stack (last n entries in xi)
            xi[n + head] = p;
            // start dfs at node i
            xi[++head] = i;
            // node j is not done
            done = 0;
            break;
        }
        // check depth-first search at node j is done
        if (done) {
            // remove j from the recursion stack
            head--;
            // and place in the output stack
            xi[--top] = j;
        }
    }
    return top;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csReach": (()=>csReach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csDfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js [app-ssr] (ecmascript)");
;
;
;
function csReach(g, b, k, xi, pinv) {
    // g arrays
    var gptr = g._ptr;
    var gsize = g._size;
    // b arrays
    var bindex = b._index;
    var bptr = b._ptr;
    // columns
    var n = gsize[1];
    // vars
    var p, p0, p1;
    // initialize top
    var top = n;
    // loop column indeces in B
    for(p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++){
        // node i
        var i = bindex[p];
        // check node i is marked
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csMarked"])(gptr, i)) {
            // start a dfs at unmarked node i
            top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csDfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csDfs"])(i, g, top, xi, pinv);
        }
    }
    // loop columns from top -> n - 1
    for(p = top; p < n; p++){
        // restore G
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csMark"])(gptr, xi[p]);
    }
    return top;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsSpsolve": (()=>createCsSpsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csReach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'csSpsolve';
var dependencies = [
    'divideScalar',
    'multiply',
    'subtract'
];
var createCsSpsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { divideScalar, multiply, subtract } = _ref;
    /**
   * The function csSpsolve() computes the solution to G * x = bk, where bk is the
   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U
   * is upper triangular with the diagonal entry as the last entry in each column.
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   x               The soluton to the linear system G * x = b
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   * @param {boolean} lo              The lower (true) upper triangular (false) flag
   *
   * @return {Number}                 The index for the nonzero pattern
   */ return function csSpsolve(g, b, k, xi, x, pinv, lo) {
        // g arrays
        var gvalues = g._values;
        var gindex = g._index;
        var gptr = g._ptr;
        var gsize = g._size;
        // columns
        var n = gsize[1];
        // b arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        // vars
        var p, p0, p1, q;
        // xi[top..n-1] = csReach(B(:,k))
        var top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csReach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csReach"])(g, b, k, xi, pinv);
        // clear x
        for(p = top; p < n; p++){
            x[xi[p]] = 0;
        }
        // scatter b
        for(p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++){
            x[bindex[p]] = bvalues[p];
        }
        // loop columns
        for(var px = top; px < n; px++){
            // x array index for px
            var j = xi[px];
            // apply permutation vector (U x = b), j maps to column J of G
            var J = pinv ? pinv[j] : j;
            // check column J is empty
            if (J < 0) {
                continue;
            }
            // column value indeces in G, p0 <= p < p1
            p0 = gptr[J];
            p1 = gptr[J + 1];
            // x(j) /= G(j,j)
            x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
            // first entry L(j,j)
            p = lo ? p0 + 1 : p0;
            q = lo ? p1 : p1 - 1;
            // loop
            for(; p < q; p++){
                // row
                var i = gindex[p];
                // x(i) -= G(i,j) * x(j)
                x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
            }
        }
        // return top of stack
        return top;
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsLu": (()=>createCsLu)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSpsolve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js [app-ssr] (ecmascript)");
;
;
var name = 'csLu';
var dependencies = [
    'abs',
    'divideScalar',
    'multiply',
    'subtract',
    'larger',
    'largerEq',
    'SparseMatrix'
];
var createCsLu = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { abs, divideScalar, multiply, subtract, larger, largerEq, SparseMatrix } = _ref;
    var csSpsolve = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSpsolve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCsSpsolve"])({
        divideScalar,
        multiply,
        subtract
    });
    /**
   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L
   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
   * L * U = A(p, q), where p is the inverse of pinv.
   *
   * @param {Matrix}  m               The A Matrix to factorize
   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing
   *                                  column ordering q
   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Number}                 The numeric LU factorization of A or null
   */ return function csLu(m, s, tol) {
        // validate input
        if (!m) {
            return null;
        }
        // m arrays
        var size = m._size;
        // columns
        var n = size[1];
        // symbolic analysis result
        var q;
        var lnz = 100;
        var unz = 100;
        // update symbolic analysis parameters
        if (s) {
            q = s.q;
            lnz = s.lnz || lnz;
            unz = s.unz || unz;
        }
        // L arrays
        var lvalues = []; // (lnz)
        var lindex = []; // (lnz)
        var lptr = []; // (n + 1)
        // L
        var L = new SparseMatrix({
            values: lvalues,
            index: lindex,
            ptr: lptr,
            size: [
                n,
                n
            ]
        });
        // U arrays
        var uvalues = []; // (unz)
        var uindex = []; // (unz)
        var uptr = []; // (n + 1)
        // U
        var U = new SparseMatrix({
            values: uvalues,
            index: uindex,
            ptr: uptr,
            size: [
                n,
                n
            ]
        });
        // inverse of permutation vector
        var pinv = []; // (n)
        // vars
        var i, p;
        // allocate arrays
        var x = []; // (n)
        var xi = []; // (2 * n)
        // initialize variables
        for(i = 0; i < n; i++){
            // clear workspace
            x[i] = 0;
            // no rows pivotal yet
            pinv[i] = -1;
            // no cols of L yet
            lptr[i + 1] = 0;
        }
        // reset number of nonzero elements in L and U
        lnz = 0;
        unz = 0;
        // compute L(:,k) and U(:,k)
        for(var k = 0; k < n; k++){
            // update ptr
            lptr[k] = lnz;
            uptr[k] = unz;
            // apply column permutations if needed
            var col = q ? q[k] : k;
            // solve triangular system, x = L\A(:,col)
            var top = csSpsolve(L, m, col, xi, x, pinv, 1);
            // find pivot
            var ipiv = -1;
            var a = -1;
            // loop xi[] from top -> n
            for(p = top; p < n; p++){
                // x[i] is nonzero
                i = xi[p];
                // check row i is not yet pivotal
                if (pinv[i] < 0) {
                    // absolute value of x[i]
                    var xabs = abs(x[i]);
                    // check absoulte value is greater than pivot value
                    if (larger(xabs, a)) {
                        // largest pivot candidate so far
                        a = xabs;
                        ipiv = i;
                    }
                } else {
                    // x(i) is the entry U(pinv[i],k)
                    uindex[unz] = pinv[i];
                    uvalues[unz++] = x[i];
                }
            }
            // validate we found a valid pivot
            if (ipiv === -1 || a <= 0) {
                return null;
            }
            // update actual pivot column, give preference to diagonal value
            if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
                ipiv = col;
            }
            // the chosen pivot
            var pivot = x[ipiv];
            // last entry in U(:,k) is U(k,k)
            uindex[unz] = k;
            uvalues[unz++] = pivot;
            // ipiv is the kth pivot row
            pinv[ipiv] = k;
            // first entry in L(:,k) is L(k,k) = 1
            lindex[lnz] = ipiv;
            lvalues[lnz++] = 1;
            // L(k+1:n,k) = x / pivot
            for(p = top; p < n; p++){
                // row
                i = xi[p];
                // check x(i) is an entry in L(:,k)
                if (pinv[i] < 0) {
                    // save unpermuted row in L
                    lindex[lnz] = i;
                    // scale pivot column
                    lvalues[lnz++] = divideScalar(x[i], pivot);
                }
                // x[0..n-1] = 0 for next k
                x[i] = 0;
            }
        }
        // update ptr
        lptr[n] = lnz;
        uptr[n] = unz;
        // fix row indices of L for final pinv
        for(p = 0; p < lnz; p++){
            lindex[p] = pinv[lindex[p]];
        }
        // trim arrays
        lvalues.splice(lnz, lvalues.length - lnz);
        lindex.splice(lnz, lindex.length - lnz);
        uvalues.splice(unz, uvalues.length - unz);
        uindex.splice(unz, uindex.length - unz);
        // return LU factor
        return {
            L,
            U,
            pinv
        };
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSlu": (()=>createSlu)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSqr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'slu';
var dependencies = [
    'typed',
    'abs',
    'add',
    'multiply',
    'transpose',
    'divideScalar',
    'subtract',
    'larger',
    'largerEq',
    'SparseMatrix'
];
var createSlu = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, multiply, transpose, divideScalar, subtract, larger, largerEq, SparseMatrix } = _ref;
    var csSqr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSqr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCsSqr"])({
        add,
        multiply,
        transpose
    });
    var csLu = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCsLu"])({
        abs,
        divideScalar,
        multiply,
        subtract,
        larger,
        largerEq,
        SparseMatrix
    });
    /**
   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
   *
   * `P * A * Q = L * U`
   *
   * Syntax:
   *
   *    math.slu(A, order, threshold)
   *
   * Examples:
   *
   *    const A = math.sparse([[4,3], [6, 3]])
   *    math.slu(A, 1, 0.001)
   *    // returns:
   *    // {
   *    //   L: [[1, 0], [1.5, 1]]
   *    //   U: [[4, 3], [0, -1.5]]
   *    //   p: [0, 1]
   *    //   q: [0, 1]
   *    // }
   *
   * See also:
   *
   *    lup, lsolve, usolve, lusolve
   *
   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
   * @param {Number}       order          The Symbolic Ordering and Analysis order:
   *                                       0 - Natural ordering, no permutation vector q is returned
   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.
   *                                           This is appropriatefor LU factorization of unsymmetric matrices.
   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
   *                                           A dense row is a row with more than 10*sqr(columns) entries.
   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
   */ return typed(name, {
        'SparseMatrix, number, number': function SparseMatrix_number_number(a, order, threshold) {
            // verify order
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(order) || order < 0 || order > 3) {
                throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');
            }
            // verify threshold
            if (threshold < 0 || threshold > 1) {
                throw new Error('Partial pivoting threshold must be a number from 0 to 1');
            }
            // perform symbolic ordering and analysis
            var s = csSqr(order, a, false);
            // perform lu decomposition
            var f = csLu(a, s, threshold);
            // return decomposition
            return {
                L: f.L,
                U: f.U,
                p: f.pinv,
                q: s.q,
                toString: function toString() {
                    return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\np: ' + this.p.toString() + (this.q ? '\nq: ' + this.q.toString() : '') + '\n';
                }
            };
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/sort.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSort": (()=>createSort)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'sort';
var dependencies = [
    'typed',
    'matrix',
    'compare',
    'compareNatural'
];
var createSort = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, compare, compareNatural } = _ref;
    var compareAsc = compare;
    var compareDesc = (a, b)=>-compare(a, b);
    /**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.sort(x)
   *    math.sort(x, compare)
   *
   * Examples:
   *
   *    math.sort([5, 10, 1]) // returns [1, 5, 10]
   *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)
   *    // returns ['A', 'B', 'C', 'D']
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length
   *    }
   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)
   *    // returns ['Tom', 'Sara', 'Langdon']
   *
   * See also:
   *
   *    filter, forEach, map, compare, compareNatural
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']
   *        An optional _comparator function or name. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {Matrix | Array} Returns the sorted matrix.
   */ return typed(name, {
        Array: function Array(x) {
            _arrayIsVector(x);
            return x.sort(compareAsc);
        },
        Matrix: function Matrix(x) {
            _matrixIsVector(x);
            return matrix(x.toArray().sort(compareAsc), x.storage());
        },
        'Array, function': function Array_function(x, _comparator) {
            _arrayIsVector(x);
            return x.sort(_comparator);
        },
        'Matrix, function': function Matrix_function(x, _comparator) {
            _matrixIsVector(x);
            return matrix(x.toArray().sort(_comparator), x.storage());
        },
        'Array, string': function Array_string(x, order) {
            _arrayIsVector(x);
            return x.sort(_comparator(order));
        },
        'Matrix, string': function Matrix_string(x, order) {
            _matrixIsVector(x);
            return matrix(x.toArray().sort(_comparator(order)), x.storage());
        }
    });
    "TURBOPACK unreachable";
    /**
   * Get the comparator for given order ('asc', 'desc', 'natural')
   * @param {'asc' | 'desc' | 'natural'} order
   * @return {Function} Returns a _comparator function
   */ function _comparator(order) {
        if (order === 'asc') {
            return compareAsc;
        } else if (order === 'desc') {
            return compareDesc;
        } else if (order === 'natural') {
            return compareNatural;
        } else {
            throw new Error('String "asc", "desc", or "natural" expected');
        }
    }
    /**
   * Validate whether an array is one dimensional
   * Throws an error when this is not the case
   * @param {Array} array
   * @private
   */ function _arrayIsVector(array) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(array).length !== 1) {
            throw new Error('One dimensional array expected');
        }
    }
    /**
   * Validate whether a matrix is one dimensional
   * Throws an error when this is not the case
   * @param {Matrix} matrix
   * @private
   */ function _matrixIsVector(matrix) {
        if (matrix.size().length !== 1) {
            throw new Error('One dimensional matrix expected');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnaryPlus": (()=>createUnaryPlus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'unaryPlus';
var dependencies = [
    'typed',
    'config',
    'numeric'
];
var createUnaryPlus = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, numeric } = _ref;
    /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5)      // returns 3.5
   *    math.unaryPlus(1)     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | bigint | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unaryPlusNumber"],
        Complex: function Complex(x) {
            return x; // complex numbers are immutable
        },
        BigNumber: function BigNumber(x) {
            return x; // bignumbers are immutable
        },
        bigint: function bigint(x) {
            return x;
        },
        Fraction: function Fraction(x) {
            return x; // fractions are immutable
        },
        Unit: function Unit(x) {
            return x.clone();
        },
        // deep map collection, skip zeros since unaryPlus(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true)),
        boolean: function boolean(x) {
            return numeric(x ? 1 : 0, config.number);
        },
        string: function string(x) {
            return numeric(x, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNumberType"])(x, config));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUsolveAll": (()=>createUsolveAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)");
;
;
var name = 'usolveAll';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createUsolveAll = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolveAll(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
   *
   * See also:
   *
   *    usolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var R = _denseBackwardSubstitution(m, b);
            return R.map((r)=>r.valueOf());
        }
    });
    "TURBOPACK unreachable";
    function _denseBackwardSubstitution(m, b_) {
        // the algorithm is derived from
        // https://www.overleaf.com/read/csvgqdxggyjv
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // loop columns backwards
        for(var i = columns - 1; i >= 0; i--){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                if (!equalScalar(M[i][i], 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], M[i][i]);
                    for(var j = i - 1; j >= 0; j--){
                        // b[j] -= b[i] * M[j,i]
                        b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j = i - 1; _j >= 0; _j--){
                        bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
    function _sparseBackwardSubstitution(m, b_) {
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // loop columns backwards
        for(var i = columns - 1; i >= 0; i--){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                // values & indices (column i)
                var iValues = [];
                var iIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[i];
                var lastIndex = ptr[i + 1];
                // find the value at [i, i]
                var Mii = 0;
                for(var j = lastIndex - 1; j >= firstIndex; j--){
                    var J = index[j];
                    // check row
                    if (J === i) {
                        Mii = values[j];
                    } else if (J < i) {
                        // store upper triangular
                        iValues.push(values[j]);
                        iIndices.push(J);
                    }
                }
                if (!equalScalar(Mii, 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], Mii);
                    // loop upper triangular
                    for(var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++){
                        var _J = iIndices[_j2];
                        b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    // loop upper triangular
                    for(var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++){
                        var _J2 = iIndices[_j3];
                        bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/signal/zpk2tf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createZpk2tf": (()=>createZpk2tf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'zpk2tf';
var dependencies = [
    'typed',
    'add',
    'multiply',
    'Complex',
    'number'
];
var createZpk2tf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, multiply, Complex, number } = _ref;
    /**
     * Compute the transfer function of a zero-pole-gain model.
     *
     * Syntax:
     *      math.zpk2tf(z, p, k)
     *
     * Examples:
     *    math.zpk2tf([1, 2], [-1, -2], 1)    // returns [[1, -3, 2], [1, 3, 2]]
     *
     * See also:
     *   freqz
     *
     * @param {Array} z Array of zeros values
     * @param {Array} p Array of poles values
     * @param {number} k Gain value
     * @return {Array} Two dimensional array containing the numerator (first row) and denominator (second row) polynomials
     *
     */ return typed(name, {
        'Array,Array,number': function ArrayArrayNumber(z, p, k) {
            return _zpk2tf(z, p, k);
        },
        'Array,Array': function ArrayArray(z, p) {
            return _zpk2tf(z, p, 1);
        },
        'Matrix,Matrix,number': function MatrixMatrixNumber(z, p, k) {
            return _zpk2tf(z.valueOf(), p.valueOf(), k);
        },
        'Matrix,Matrix': function MatrixMatrix(z, p) {
            return _zpk2tf(z.valueOf(), p.valueOf(), 1);
        }
    });
    "TURBOPACK unreachable";
    function _zpk2tf(z, p, k) {
        // if z is bignumber, convert it to number
        if (z.some((el)=>el.type === 'BigNumber')) {
            z = z.map((el)=>number(el));
        }
        // if p is bignumber, convert it to number
        if (p.some((el)=>el.type === 'BigNumber')) {
            p = p.map((el)=>number(el));
        }
        var num = [
            Complex(1, 0)
        ];
        var den = [
            Complex(1, 0)
        ];
        for(var i = 0; i < z.length; i++){
            var zero = z[i];
            if (typeof zero === 'number') zero = Complex(zero, 0);
            num = _multiply(num, [
                Complex(1, 0),
                Complex(-zero.re, -zero.im)
            ]);
        }
        for(var _i = 0; _i < p.length; _i++){
            var pole = p[_i];
            if (typeof pole === 'number') pole = Complex(pole, 0);
            den = _multiply(den, [
                Complex(1, 0),
                Complex(-pole.re, -pole.im)
            ]);
        }
        for(var _i2 = 0; _i2 < num.length; _i2++){
            num[_i2] = multiply(num[_i2], k);
        }
        return [
            num,
            den
        ];
    }
    function _multiply(a, b) {
        var c = [];
        for(var i = 0; i < a.length + b.length - 1; i++){
            c[i] = Complex(0, 0);
            for(var j = 0; j < a.length; j++){
                if (i - j >= 0 && i - j < b.length) {
                    c[i] = add(c[i], multiply(a[j], b[i - j]));
                }
            }
        }
        return c;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/logical/and.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAnd": (()=>createAnd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/logical.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
var name = 'and';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'zeros',
    'not',
    'concat'
];
var createAnd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, zeros, not, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.and(x, y)
   *
   * Examples:
   *
   *    math.and(2, 4)   // returns true
   *
   *    a = [2, 0, 0]
   *    b = [3, 7, 0]
   *    c = 0
   *
   *    math.and(a, b)   // returns [true, false, false]
   *    math.and(a, c)   // returns [false, false, false]
   *
   * See also:
   *
   *    not, or, xor
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when both inputs are defined with a nonzero/nonempty value.
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["andNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
        },
        'bigint, bigint': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$logical$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["andNumber"],
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>self(x.value || 0, y.value || 0)),
        'SparseMatrix, any': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (not(y)) {
                    // return zero matrix
                    return zeros(x.size(), x.storage());
                }
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, any': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (not(y)) {
                    // return zero matrix
                    return zeros(x.size(), x.storage());
                }
                return matAlgo14xDs(x, y, self, false);
            }),
        'any, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (not(x)) {
                    // return zero matrix
                    return zeros(x.size(), x.storage());
                }
                return matAlgo11xS0s(y, x, self, true);
            }),
        'any, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // check scalar
                if (not(x)) {
                    // return zero matrix
                    return zeros(x.size(), x.storage());
                }
                return matAlgo14xDs(y, x, self, true);
            }),
        'Array, any': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return self(matrix(x), y).valueOf();
            }),
        'any, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return self(x, matrix(y)).valueOf();
            })
    }, matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/ceil.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCeil": (()=>createCeil),
    "createCeilNumber": (()=>createCeilNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decimal.js/decimal.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'ceil';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var bigTen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](10);
var createCeilNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config',
    'round'
], (_ref)=>{
    var { typed, config, round } = _ref;
    function _ceilNumber(x) {
        // See ./floor.js _floorNumber for rationale here
        var c = Math.ceil(x);
        var r = round(x);
        if (c === r) return c;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, r, config.relTol, config.absTol) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, c, config.relTol, config.absTol)) {
            return r;
        }
        return c;
    }
    return typed(name, {
        number: _ceilNumber,
        'number, number': function number_number(x, n) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(n)) {
                throw new RangeError('number of decimals in function ceil must be an integer');
            }
            if (n < 0 || n > 15) {
                throw new RangeError('number of decimals in ceil number must be in range 0-15');
            }
            var shift = 10 ** n;
            return _ceilNumber(x * shift) / shift;
        }
    });
});
var createCeil = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var ceilNumber = createCeilNumber({
        typed,
        config,
        round
    });
    function _bigCeil(x) {
        // see ./floor.js _floorNumber for rationale
        var bne = (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearlyEqual"])(a, b, config.relTol, config.absTol);
        var c = x.ceil();
        var r = round(x);
        if (c.eq(r)) return c;
        if (bne(x, r) && !bne(x, c)) return r;
        return c;
    }
    /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *    math.ceil(x, n)
   *    math.ceil(unit, valuelessUnit)
   *    math.ceil(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.ceil(3.2)               // returns number 4
   *    math.ceil(3.8)               // returns number 4
   *    math.ceil(-4.2)              // returns number -4
   *    math.ceil(-4.7)              // returns number -4
   *
   *    math.ceil(3.212, 2)          // returns number 3.22
   *    math.ceil(3.288, 2)          // returns number 3.29
   *    math.ceil(-4.212, 2)         // returns number -4.21
   *    math.ceil(-4.782, 2)         // returns number -4.78
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.ceil(c)                 // returns Complex 4 - 2i
   *    math.ceil(c, 1)              // returns Complex 3.3 - 2.7i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.ceil(unit, 1, cm)      // returns Unit 3.3 cm
   *    math.ceil(unit, 1, mm)      // returns Unit 32.5 mm
   *
   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
   *    math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('ceil', {
        number: ceilNumber.signatures.number,
        'number,number': ceilNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return x.ceil();
        },
        'Complex, number': function Complex_number(x, n) {
            return x.ceil(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            return x.ceil(n.toNumber());
        },
        BigNumber: _bigCeil,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            var shift = bigTen.pow(n);
            return _bigCeil(x.mul(shift)).div(shift);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.ceil();
        },
        'Fraction, number': function Fraction_number(x, n) {
            return x.ceil(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            return x.ceil(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/column.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createColumn": (()=>createColumn)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'column';
var dependencies = [
    'typed',
    'Index',
    'matrix',
    'range'
];
var createColumn = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Index, matrix, range } = _ref;
    /**
   * Return a column from a Matrix.
   *
   * Syntax:
   *
   *     math.column(value, index)
   *
   * Example:
   *
   *     // get a column
   *     const d = [[1, 2], [3, 4]]
   *     math.column(d, 1) // returns [[2], [4]]
   *
   * See also:
   *
   *     row
   *
   * @param {Array | Matrix } value   An array or matrix
   * @param {number} column           The index of the column
   * @return {Array | Matrix}         The retrieved column
   */ return typed(name, {
        'Matrix, number': _column,
        'Array, number': function Array_number(value, column) {
            return _column(matrix((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(value)), column).valueOf();
        }
    });
    "TURBOPACK unreachable";
    /**
   * Retrieve a column of a matrix
   * @param {Matrix } value  A matrix
   * @param {number} column  The index of the column
   * @return {Matrix}        The retrieved column
   */ function _column(value, column) {
        // check dimensions
        if (value.size().length !== 2) {
            throw new Error('Only two dimensional matrix is supported');
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIndex"])(column, value.size()[1]);
        var rowRange = range(0, value.size()[0]);
        var index = new Index(rowRange, column);
        var result = value.subset(index);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(result) ? result : matrix([
            [
                result
            ]
        ]);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/cross.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCross": (()=>createCross)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'cross';
var dependencies = [
    'typed',
    'matrix',
    'subtract',
    'multiply'
];
var createCross = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, subtract, multiply } = _ref;
    /**
   * Calculate the cross product for two vectors in three dimensional space.
   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
   * as:
   *
   *    cross(A, B) = [
   *      a2 * b3 - a3 * b2,
   *      a3 * b1 - a1 * b3,
   *      a1 * b2 - a2 * b1
   *    ]
   *
   * If one of the input vectors has a dimension greater than 1, the output
   * vector will be a 1x3 (2-dimensional) matrix.
   *
   * Syntax:
   *
   *    math.cross(x, y)
   *
   * Examples:
   *
   *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
   *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
   *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
   *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
   *
   * See also:
   *
   *    dot, multiply
   *
   * @param  {Array | Matrix} x   First vector
   * @param  {Array | Matrix} y   Second vector
   * @return {Array | Matrix}     Returns the cross product of `x` and `y`
   */ return typed(name, {
        'Matrix, Matrix': function Matrix_Matrix(x, y) {
            return matrix(_cross(x.toArray(), y.toArray()));
        },
        'Matrix, Array': function Matrix_Array(x, y) {
            return matrix(_cross(x.toArray(), y));
        },
        'Array, Matrix': function Array_Matrix(x, y) {
            return matrix(_cross(x, y.toArray()));
        },
        'Array, Array': _cross
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the cross product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */ function _cross(x, y) {
        var highestDimension = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x).length, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(y).length);
        x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squeeze"])(x);
        y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squeeze"])(y);
        var xSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x);
        var ySize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(y);
        if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
            throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
        }
        var product = [
            subtract(multiply(x[1], y[2]), multiply(x[2], y[1])),
            subtract(multiply(x[2], y[0]), multiply(x[0], y[2])),
            subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))
        ];
        if (highestDimension > 1) {
            return [
                product
            ];
        } else {
            return product;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/det.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDet": (()=>createDet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'det';
var dependencies = [
    'typed',
    'matrix',
    'subtractScalar',
    'multiply',
    'divideScalar',
    'isZero',
    'unaryMinus'
];
var createDet = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, subtractScalar, multiply, divideScalar, isZero, unaryMinus } = _ref;
    /**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]) // returns -2
   *
   *    const A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A) // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {number} The determinant of `x`
   */ return typed(name, {
        any: function any(x) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x);
        },
        'Array | Matrix': function det(x) {
            var size;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
                size = x.size();
            } else if (Array.isArray(x)) {
                x = matrix(x);
                size = x.size();
            } else {
                // a scalar
                size = [];
            }
            switch(size.length){
                case 0:
                    // scalar
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x);
                case 1:
                    // vector
                    if (size[0] === 1) {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x.valueOf()[0]);
                    }
                    if (size[0] === 0) {
                        return 1; // det of an empty matrix is per definition 1
                    } else {
                        throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                    }
                case 2:
                    {
                        // two-dimensional array
                        var rows = size[0];
                        var cols = size[1];
                        if (rows === cols) {
                            return _det(x.clone().valueOf(), rows, cols);
                        }
                        if (cols === 0) {
                            return 1; // det of an empty matrix is per definition 1
                        } else {
                            throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                        }
                    }
                default:
                    // multi dimensional array
                    throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            }
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {number} rows     Number of rows of the matrix (zero-based)
   * @param {number} cols     Number of columns of the matrix (zero-based)
   * @returns {number} det
   * @private
   */ function _det(matrix, rows, cols) {
        if (rows === 1) {
            // this is a 1 x 1 matrix
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(matrix[0][0]);
        } else if (rows === 2) {
            // this is a 2 x 2 matrix
            // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
            return subtractScalar(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
        } else {
            // Bareiss algorithm
            // this algorithm have same complexity as LUP decomposition (O(n^3))
            // but it preserve precision of floating point more relative to the LUP decomposition
            var negated = false;
            var rowIndices = new Array(rows).fill(0).map((_, i)=>i); // matrix index of row i
            for(var k = 0; k < rows; k++){
                var k_ = rowIndices[k];
                if (isZero(matrix[k_][k])) {
                    var _k = void 0;
                    for(_k = k + 1; _k < rows; _k++){
                        if (!isZero(matrix[rowIndices[_k]][k])) {
                            k_ = rowIndices[_k];
                            rowIndices[_k] = rowIndices[k];
                            rowIndices[k] = k_;
                            negated = !negated;
                            break;
                        }
                    }
                    if (_k === rows) return matrix[k_][k]; // some zero of the type
                }
                var piv = matrix[k_][k];
                var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];
                for(var i = k + 1; i < rows; i++){
                    var i_ = rowIndices[i];
                    for(var j = k + 1; j < rows; j++){
                        matrix[i_][j] = divideScalar(subtractScalar(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);
                    }
                }
            }
            var det = matrix[rowIndices[rows - 1]][rows - 1];
            return negated ? unaryMinus(det) : det;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/fix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFix": (()=>createFix),
    "createFixNumber": (()=>createFixNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'fix';
var dependencies = [
    'typed',
    'Complex',
    'matrix',
    'ceil',
    'floor',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var createFixNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'ceil',
    'floor'
], (_ref)=>{
    var { typed, ceil, floor } = _ref;
    return typed(name, {
        number: function number(x) {
            return x > 0 ? floor(x) : ceil(x);
        },
        'number, number': function number_number(x, n) {
            return x > 0 ? floor(x, n) : ceil(x, n);
        }
    });
});
var createFix = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, Complex: _Complex, matrix, ceil, floor, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var fixNumber = createFixNumber({
        typed,
        ceil,
        floor
    });
    /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *    math.fix(x,n)
   *    math.fix(unit, valuelessUnit)
   *    math.fix(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.fix(3.2)                // returns number 3
   *    math.fix(3.8)                // returns number 3
   *    math.fix(-4.2)               // returns number -4
   *    math.fix(-4.7)               // returns number -4
   *
   *    math.fix(3.12, 1)                // returns number 3.1
   *    math.fix(3.18, 1)                // returns number 3.1
   *    math.fix(-4.12, 1)               // returns number -4.1
   *    math.fix(-4.17, 1)               // returns number -4.1
   *
   *    const c = math.complex(3.22, -2.78)
   *    math.fix(c)                  // returns Complex 3 - 2i
   *    math.fix(c, 1)               // returns Complex 3.2 -2.7i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.fix(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.fix(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]
   *    math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('fix', {
        number: fixNumber.signatures.number,
        'number, number | BigNumber': fixNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
        },
        'Complex, number': function Complex_number(x, n) {
            return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
        },
        'Complex, BigNumber': function Complex_BigNumber(x, bn) {
            var n = bn.toNumber();
            return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
        },
        BigNumber: function BigNumber(x) {
            return x.isNegative() ? ceil(x) : floor(x);
        },
        'BigNumber, number | BigNumber': function BigNumber_number__BigNumber(x, n) {
            return x.isNegative() ? ceil(x, n) : floor(x, n);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.s < 0n ? x.ceil() : x.floor();
        },
        'Fraction, number | BigNumber': function Fraction_number__BigNumber(x, n) {
            return x.s < 0n ? ceil(x, n) : floor(x, n);
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array | Matrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/inv.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createInv": (()=>createInv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'inv';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'addScalar',
    'multiply',
    'unaryMinus',
    'det',
    'identity',
    'abs'
];
var createInv = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, addScalar, multiply, unaryMinus, det, identity, abs } = _ref;
    /**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4)                 // returns 0.25
   *     1 / 4                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(x) {
            var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x) ? x.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x);
            switch(size.length){
                case 1:
                    // vector
                    if (size[0] === 1) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
                            return matrix([
                                divideScalar(1, x.valueOf()[0])
                            ]);
                        } else {
                            return [
                                divideScalar(1, x[0])
                            ];
                        }
                    } else {
                        throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                    }
                case 2:
                    // two dimensional array
                    {
                        var rows = size[0];
                        var cols = size[1];
                        if (rows === cols) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
                                return matrix(_inv(x.valueOf(), rows, cols), x.storage());
                            } else {
                                // return an Array
                                return _inv(x, rows, cols);
                            }
                        } else {
                            throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                        }
                    }
                default:
                    // multi dimensional array
                    throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            }
        },
        any: function any(x) {
            // scalar
            return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the inverse of a square matrix
   * @param {Array[]} mat     A square matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */ function _inv(mat, rows, cols) {
        var r, s, f, value, temp;
        if (rows === 1) {
            // this is a 1 x 1 matrix
            value = mat[0][0];
            if (value === 0) {
                throw Error('Cannot calculate inverse, determinant is zero');
            }
            return [
                [
                    divideScalar(1, value)
                ]
            ];
        } else if (rows === 2) {
            // this is a 2 x 2 matrix
            var d = det(mat);
            if (d === 0) {
                throw Error('Cannot calculate inverse, determinant is zero');
            }
            return [
                [
                    divideScalar(mat[1][1], d),
                    divideScalar(unaryMinus(mat[0][1]), d)
                ],
                [
                    divideScalar(unaryMinus(mat[1][0]), d),
                    divideScalar(mat[0][0], d)
                ]
            ];
        } else {
            // this is a matrix of 3 x 3 or larger
            // calculate inverse using gauss-jordan elimination
            //      https://en.wikipedia.org/wiki/Gaussian_elimination
            //      http://mathworld.wolfram.com/MatrixInverse.html
            //      http://math.uww.edu/~mcfarlat/inverse.htm
            // make a copy of the matrix (only the arrays, not of the elements)
            var A = mat.concat();
            for(r = 0; r < rows; r++){
                A[r] = A[r].concat();
            }
            // create an identity matrix which in the end will contain the
            // matrix inverse
            var B = identity(rows).valueOf();
            // loop over all columns, and perform row reductions
            for(var c = 0; c < cols; c++){
                // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
                var ABig = abs(A[c][c]);
                var rBig = c;
                r = c + 1;
                while(r < rows){
                    if (abs(A[r][c]) > ABig) {
                        ABig = abs(A[r][c]);
                        rBig = r;
                    }
                    r++;
                }
                if (ABig === 0) {
                    throw Error('Cannot calculate inverse, determinant is zero');
                }
                r = rBig;
                if (r !== c) {
                    temp = A[c];
                    A[c] = A[r];
                    A[r] = temp;
                    temp = B[c];
                    B[c] = B[r];
                    B[r] = temp;
                }
                // eliminate non-zero values on the other rows at column c
                var Ac = A[c];
                var Bc = B[c];
                for(r = 0; r < rows; r++){
                    var Ar = A[r];
                    var Br = B[r];
                    if (r !== c) {
                        // eliminate value at column c and row r
                        if (Ar[c] !== 0) {
                            f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
                            // add (f * row c) to row r to eliminate the value
                            // at column c
                            for(s = c; s < cols; s++){
                                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                            }
                            for(s = 0; s < cols; s++){
                                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                            }
                        }
                    } else {
                        // normalize value at Acc to 1,
                        // divide each value on row r with the value at Acc
                        f = Ac[c];
                        for(s = c; s < cols; s++){
                            Ar[s] = divideScalar(Ar[s], f);
                        }
                        for(s = 0; s < cols; s++){
                            Br[s] = divideScalar(Br[s], f);
                        }
                    }
                }
            }
            return B;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/pinv.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPinv": (()=>createPinv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
;
;
;
;
var name = 'pinv';
var dependencies = [
    'typed',
    'matrix',
    'inv',
    'deepEqual',
    'equal',
    'dotDivide',
    'dot',
    'ctranspose',
    'divideScalar',
    'multiply',
    'add',
    'Complex'
];
var createPinv = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, inv, deepEqual, equal, dotDivide, dot, ctranspose, divideScalar, multiply, add, Complex } = _ref;
    /**
   * Calculate the Moore–Penrose inverse of a matrix.
   *
   * Syntax:
   *
   *     math.pinv(x)
   *
   * Examples:
   *
   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]
   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]
   *     math.pinv(4)                         // returns 0.25
   *
   * See also:
   *
   *     inv
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(x) {
            var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x) ? x.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x);
            switch(size.length){
                case 1:
                    // vector
                    if (_isZeros(x)) return ctranspose(x); // null vector
                    if (size[0] === 1) {
                        return inv(x); // invertible matrix
                    } else {
                        return dotDivide(ctranspose(x), dot(x, x));
                    }
                case 2:
                    // two dimensional array
                    {
                        if (_isZeros(x)) return ctranspose(x); // zero matrixx
                        var rows = size[0];
                        var cols = size[1];
                        if (rows === cols) {
                            try {
                                return inv(x); // invertible matrix
                            } catch (err) {
                                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                                // Expected
                                } else {
                                    throw err;
                                }
                            }
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(x)) {
                            return matrix(_pinv(x.valueOf(), rows, cols), x.storage());
                        } else {
                            // return an Array
                            return _pinv(x, rows, cols);
                        }
                    }
                default:
                    // multi dimensional array
                    throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            }
        },
        any: function any(x) {
            // scalar
            if (equal(x, 0)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(x); // zero
            return divideScalar(1, x);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the Moore–Penrose inverse of a matrix
   * @param {Array[]} mat     A matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns
   * @return {Array[]} pinv    Pseudoinverse matrix
   * @private
   */ function _pinv(mat, rows, cols) {
        var { C, F } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)
        var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));
        var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
        return multiply(Fpinv, Cpinv);
    }
    /**
   * Calculate the reduced row echelon form of a matrix
   *
   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form
   *
   * @param {Array[]} mat     A matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns
   * @return {Array[]}        Reduced row echelon form
   * @private
   */ function _rref(mat, rows, cols) {
        var M = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(mat);
        var lead = 0;
        for(var r = 0; r < rows; r++){
            if (cols <= lead) {
                return M;
            }
            var i = r;
            while(_isZero(M[i][lead])){
                i++;
                if (rows === i) {
                    i = r;
                    lead++;
                    if (cols === lead) {
                        return M;
                    }
                }
            }
            [M[i], M[r]] = [
                M[r],
                M[i]
            ];
            var val = M[r][lead];
            for(var j = 0; j < cols; j++){
                M[r][j] = dotDivide(M[r][j], val);
            }
            for(var _i = 0; _i < rows; _i++){
                if (_i === r) continue;
                val = M[_i][lead];
                for(var _j = 0; _j < cols; _j++){
                    M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));
                }
            }
            lead++;
        }
        return M;
    }
    /**
   * Calculate the rank factorization of a matrix
   *
   * @param {Array[]} mat                  A matrix (M)
   * @param {number} rows                  Number of rows
   * @param {number} cols                  Number of columns
   * @return {{C: Array, F: Array}}        rank factorization where M = C F
   * @private
   */ function _rankFact(mat, rows, cols) {
        var rref = _rref(mat, rows, cols);
        var C = mat.map((_, i)=>_.filter((_, j)=>j < rows && !_isZero(dot(rref[j], rref[j]))));
        var F = rref.filter((_, i)=>!_isZero(dot(rref[i], rref[i])));
        return {
            C,
            F
        };
    }
    function _isZero(x) {
        return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));
    }
    function _isZeros(arr) {
        return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/pow.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPow": (()=>createPow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'pow';
var dependencies = [
    'typed',
    'config',
    'identity',
    'multiply',
    'matrix',
    'inv',
    'fraction',
    'number',
    'Complex'
];
var createPow = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, identity, multiply, matrix, inv, number, fraction, Complex } = _ref;
    /**
   * Calculates the power of x to y, `x ^ y`.
   *
   * Matrix exponentiation is supported for square matrices `x` and integers `y`:
   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
   * negative, `x` must be invertible, and then this function returns
   * inv(x)^(-y).
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3)               // returns number 8
   *
   *    const a = math.complex(2, 3)
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    const b = [[1, 2], [4, 3]]
   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
   *
   *    const c = [[1, 2], [4, 3]]
   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | bigint | Complex} y                          The exponent
   * @return {number | BigNumber | bigint | Complex | Array | Matrix} The value of `x` to the power `y`
   */ return typed(name, {
        'number, number': _pow,
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.pow(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            if (y.isInteger() || x >= 0 || config.predictable) {
                return x.pow(y);
            } else {
                return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
            }
        },
        'bigint, bigint': (x, y)=>x ** y,
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            var result = x.pow(y);
            if (result != null) {
                return result;
            }
            if (config.predictable) {
                throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
            } else {
                return _pow(x.valueOf(), y.valueOf());
            }
        },
        'Array, number': _powArray,
        'Array, BigNumber': function Array_BigNumber(x, y) {
            return _powArray(x, y.toNumber());
        },
        'Matrix, number': _powMatrix,
        'Matrix, BigNumber': function Matrix_BigNumber(x, y) {
            return _powMatrix(x, y.toNumber());
        },
        'Unit, number | BigNumber': function Unit_number__BigNumber(x, y) {
            return x.pow(y);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */ function _pow(x, y) {
        // Alternatively could define a 'realmode' config option or something, but
        // 'predictable' will work for now
        if (config.predictable && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(y) && x < 0) {
            // Check to see if y can be represented as a fraction
            try {
                var yFrac = fraction(y);
                var yNum = number(yFrac);
                if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
                    if (yFrac.d % 2n === 1n) {
                        return (yFrac.n % 2n === 0n ? 1 : -1) * Math.pow(-x, y);
                    }
                }
            } catch (ex) {
            // fraction() throws an error if y is Infinity, etc.
            }
        // Unable to express y as a fraction, so continue on
        }
        // **for predictable mode** x^Infinity === NaN if x < -1
        // N.B. this behavour is different from `Math.pow` which gives
        // (-2)^Infinity === Infinity
        if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
            return NaN;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(y) || x >= 0 || config.predictable) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["powNumber"])(x, y);
        } else {
            // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
            // x^Infinity === 0 if -1 < x < 1
            // A real number 0 is returned instead of complex(0)
            if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
                return 0;
            }
            return new Complex(x, 0).pow(y, 0);
        }
    }
    /**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a integer value (positive if `x` is not invertible)
   * @returns {Array}
   * @private
   */ function _powArray(x, y) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(y)) {
            throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
        }
        // verify that A is a 2 dimensional square matrix
        var s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(x);
        if (s.length !== 2) {
            throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
        }
        if (s[0] !== s[1]) {
            throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
        }
        if (y < 0) {
            try {
                return _powArray(inv(x), -y);
            } catch (error) {
                if (error.message === 'Cannot calculate inverse, determinant is zero') {
                    throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
                }
                throw error;
            }
        }
        var res = identity(s[0]).valueOf();
        var px = x;
        while(y >= 1){
            if ((y & 1) === 1) {
                res = multiply(px, res);
            }
            y >>= 1;
            px = multiply(px, px);
        }
        return res;
    }
    /**
   * Calculate the power of a 2d matrix
   * @param {Matrix} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Matrix}
   * @private
   */ function _powMatrix(x, y) {
        return matrix(_powArray(x.valueOf(), y));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setDifference.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetDifference": (()=>createSetDifference)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setDifference';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index',
    'DenseMatrix'
];
var createSetDifference = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index, DenseMatrix } = _ref;
    /**
   * Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setDifference(set1, set2)
   *
   * Examples:
   *
   *    math.setDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2]
   *    math.setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2]
   *
   * See also:
   *
   *    setUnion, setIntersect, setSymDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The difference of two (multi)sets
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            var result;
            if (subset(size(a1), new Index(0)) === 0) {
                // empty-anything=empty
                result = [];
            } else if (subset(size(a2), new Index(0)) === 0) {
                // anything-empty=anything
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a1.toArray());
            } else {
                var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
                var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
                result = [];
                var inb2;
                for(var i = 0; i < b1.length; i++){
                    inb2 = false;
                    for(var j = 0; j < b2.length; j++){
                        if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                            // the identifier is always a decimal int
                            inb2 = true;
                            break;
                        }
                    }
                    if (!inb2) {
                        result.push(b1[i]);
                    }
                }
            }
            // return an array, if both inputs were arrays
            if (Array.isArray(a1) && Array.isArray(a2)) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generalize"])(result);
            }
            // return a matrix otherwise
            return new DenseMatrix((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generalize"])(result));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setMultiplicity.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetMultiplicity": (()=>createSetMultiplicity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setMultiplicity';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index'
];
var createSetMultiplicity = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index } = _ref;
    /**
   * Count the multiplicity of an element in a multiset.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setMultiplicity(element, set)
   *
   * Examples:
   *
   *    math.setMultiplicity(1, [1, 2, 2, 4])    // returns 1
   *    math.setMultiplicity(2, [1, 2, 2, 4])    // returns 2
   *
   * See also:
   *
   *    setDistinct, setSize
   *
   * @param {number | BigNumber | Fraction | Complex} e  An element in the multiset
   * @param {Array | Matrix}     a  A multiset
   * @return {number}            The number of how many times the multiset contains the element
   */ return typed(name, {
        'number | BigNumber | Fraction | Complex, Array | Matrix': function number__BigNumber__Fraction__Complex_Array__Matrix(e, a) {
            if (subset(size(a), new Index(0)) === 0) {
                // if empty, return 0
                return 0;
            }
            var b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a) ? a : a.toArray());
            var count = 0;
            for(var i = 0; i < b.length; i++){
                if (compareNatural(b[i], e) === 0) {
                    count++;
                }
            }
            return count;
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setSymDifference.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetSymDifference": (()=>createSetSymDifference)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setSymDifference';
var dependencies = [
    'typed',
    'size',
    'concat',
    'subset',
    'setDifference',
    'Index'
];
var createSetSymDifference = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, concat, subset, setDifference, Index } = _ref;
    /**
   * Create the symmetric difference of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setSymDifference(set1, set2)
   *
   * Examples:
   *
   *    math.setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 5, 6]
   *    math.setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 5, 6]
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The symmetric difference of two (multi)sets
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            if (subset(size(a1), new Index(0)) === 0) {
                // if any of them is empty, return the other one
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a2);
            } else if (subset(size(a2), new Index(0)) === 0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a1);
            }
            var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a1);
            var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a2);
            return concat(setDifference(b1, b2), setDifference(b2, b1));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/sqrtm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSqrtm": (()=>createSqrtm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'sqrtm';
var dependencies = [
    'typed',
    'abs',
    'add',
    'multiply',
    'map',
    'sqrt',
    'subtract',
    'inv',
    'size',
    'max',
    'identity'
];
var createSqrtm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, multiply, map, sqrt, subtract, inv, size, max, identity } = _ref;
    var _maxIterations = 1e3;
    var _tolerance = 1e-6;
    /**
   * Calculate the principal square root matrix using the Denman–Beavers iterative method
   *
   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration
   *
   * @param  {Array | Matrix} A   The square matrix `A`
   * @return {Array | Matrix}     The principal square root of matrix `A`
   * @private
   */ function _denmanBeavers(A) {
        var error;
        var iterations = 0;
        var Y = A;
        var Z = identity(size(A));
        do {
            var Yk = Y;
            Y = multiply(0.5, add(Yk, inv(Z)));
            Z = multiply(0.5, add(Z, inv(Yk)));
            error = max(abs(subtract(Y, Yk)));
            if (error > _tolerance && ++iterations > _maxIterations) {
                throw new Error('computing square root of matrix: iterative method could not converge');
            }
        }while (error > _tolerance)
        return Y;
    }
    /**
   * Calculate the principal square root of a square matrix.
   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.
   *
   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix
   *
   * Syntax:
   *
   *     math.sqrtm(A)
   *
   * Examples:
   *
   *     math.sqrtm([[33, 24], [48, 57]]) // returns [[5, 2], [4, 7]]
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param  {Array | Matrix} A   The square matrix `A`
   * @return {Array | Matrix}     The principal square root of matrix `A`
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(A) {
            var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(A) ? A.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(A);
            switch(size.length){
                case 1:
                    // Single element Array | Matrix
                    if (size[0] === 1) {
                        return map(A, sqrt);
                    } else {
                        throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                    }
                case 2:
                    {
                        // Two-dimensional Array | Matrix
                        var rows = size[0];
                        var cols = size[1];
                        if (rows === cols) {
                            return _denmanBeavers(A);
                        } else {
                            throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
                        }
                    }
                default:
                    // Multi dimensional array
                    throw new RangeError('Matrix must be at most two dimensional ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            }
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/sum.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSum": (()=>createSum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'sum';
var dependencies = [
    'typed',
    'config',
    'add',
    'numeric'
];
var createSum = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, add, numeric } = _ref;
    /**
   * Compute the sum of a matrix or a list with values.
   * In case of a multidimensional array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.sum(a, b, c, ...)
   *     math.sum(A)
   *     math.sum(A, dimension)
   *
   * Examples:
   *
   *     math.sum(2, 1, 4, 3)               // returns 10
   *     math.sum([2, 1, 4, 3])             // returns 10
   *     math.sum([[2, 5], [4, 3], [1, 7]]) // returns 22
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, variance, cumsum
   *
   * @param {... *} args  A single matrix or multiple scalar values
   * @return {*} The sum of all values
   */ return typed(name, {
        // sum([a, b, c, d, ...])
        'Array | Matrix': _sum,
        // sum([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': _nsumDim,
        // sum(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('Scalar values expected in function sum');
            }
            return _sum(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Recursively calculate the sum of an n-dimensional array
   * @param {Array | Matrix} array
   * @return {number} sum
   * @private
   */ function _sum(array) {
        var sum;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                sum = sum === undefined ? value : add(sum, value);
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'sum', value);
            }
        });
        // make sure returning numeric value: parse a string into a numeric value
        if (sum === undefined) {
            sum = numeric(0, config.number);
        }
        if (typeof sum === 'string') {
            sum = numeric(sum, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNumberType"])(sum, config));
        }
        return sum;
    }
    function _nsumDim(array, dim) {
        try {
            var sum = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reduce"])(array, dim, add);
            return sum;
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'sum');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotPow": (()=>createDotPow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'dotPow';
var dependencies = [
    'typed',
    'equalScalar',
    'matrix',
    'pow',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createDotPow = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar, matrix, pow, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var powScalarSignatures = {};
    for(var signature in pow.signatures){
        if (Object.prototype.hasOwnProperty.call(pow.signatures, signature)) {
            if (!signature.includes('Matrix') && !signature.includes('Array')) {
                powScalarSignatures[signature] = pow.signatures[signature];
            }
        }
    }
    var powScalar = typed(powScalarSignatures);
    /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3)            // returns number 8
   *
   *    const a = [[1, 2], [4, 3]]
   *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: powScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/expm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createExpm": (()=>createExpm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'expm';
var dependencies = [
    'typed',
    'abs',
    'add',
    'identity',
    'inv',
    'multiply'
];
var createExpm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, identity, inv, multiply } = _ref;
    /**
   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.
   * Not to be confused with exp(a), which performs element-wise
   * exponentiation.
   *
   * The exponential is calculated using the Padé approximant with scaling and
   * squaring; see "Nineteen Dubious Ways to Compute the Exponential of a
   * Matrix," by Moler and Van Loan.
   *
   * Syntax:
   *
   *     math.expm(x)
   *
   * Examples:
   *
   *     const A = [[0,2],[0,0]]
   *     math.expm(A)        // returns [[1,2],[0,1]]
   *
   * See also:
   *
   *     exp
   *
   * @param {Matrix} x  A square Matrix
   * @return {Matrix}   The exponential of x
   */ return typed(name, {
        Matrix: function Matrix(A) {
            // Check matrix size
            var size = A.size();
            if (size.length !== 2 || size[0] !== size[1]) {
                throw new RangeError('Matrix must be square ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(size) + ')');
            }
            var n = size[0];
            // Desired accuracy of the approximant (The actual accuracy
            // will be affected by round-off error)
            var eps = 1e-15;
            // The Padé approximant is not so accurate when the values of A
            // are "large", so scale A by powers of two. Then compute the
            // exponential, and square the result repeatedly according to
            // the identity e^A = (e^(A/m))^m
            // Compute infinity-norm of A, ||A||, to see how "big" it is
            var infNorm = infinityNorm(A);
            // Find the optimal scaling factor and number of terms in the
            // Padé approximant to reach the desired accuracy
            var params = findParams(infNorm, eps);
            var q = params.q;
            var j = params.j;
            // The Pade approximation to e^A is:
            // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)
            // where
            // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i
            // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i
            // Scale A by 1 / 2^j
            var Apos = multiply(A, Math.pow(2, -j));
            // The i=0 term is just the identity matrix
            var N = identity(n);
            var D = identity(n);
            // Initialization (i=0)
            var factor = 1;
            // Initialization (i=1)
            var AposToI = Apos; // Cloning not necessary
            var alternate = -1;
            for(var i = 1; i <= q; i++){
                if (i > 1) {
                    AposToI = multiply(AposToI, Apos);
                    alternate = -alternate;
                }
                factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
                N = add(N, multiply(factor, AposToI));
                D = add(D, multiply(factor * alternate, AposToI));
            }
            var R = multiply(inv(D), N);
            // Square j times
            for(var _i = 0; _i < j; _i++){
                R = multiply(R, R);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSparseMatrix"])(A) ? A.createSparseMatrix(R) : R;
        }
    });
    "TURBOPACK unreachable";
    function infinityNorm(A) {
        var n = A.size()[0];
        var infNorm = 0;
        for(var i = 0; i < n; i++){
            var rowSum = 0;
            for(var j = 0; j < n; j++){
                rowSum += abs(A.get([
                    i,
                    j
                ]));
            }
            infNorm = Math.max(rowSum, infNorm);
        }
        return infNorm;
    }
    /**
   * Find the best parameters for the Pade approximant given
   * the matrix norm and desired accuracy. Returns the first acceptable
   * combination in order of increasing computational load.
   */ function findParams(infNorm, eps) {
        var maxSearchSize = 30;
        for(var k = 0; k < maxSearchSize; k++){
            for(var q = 0; q <= k; q++){
                var j = k - q;
                if (errorEstimate(infNorm, q, j) < eps) {
                    return {
                        q,
                        j
                    };
                }
            }
        }
        throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');
    }
    /**
   * Returns the estimated error of the Pade approximant for the given
   * parameters.
   */ function errorEstimate(infNorm, q, j) {
        var qfac = 1;
        for(var i = 2; i <= q; i++){
            qfac *= i;
        }
        var twoqfac = qfac;
        for(var _i2 = q + 1; _i2 <= 2 * q; _i2++){
            twoqfac *= _i2;
        }
        var twoqp1fac = twoqfac * (2 * q + 1);
        return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/fft.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFft": (()=>createFft)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'fft';
var dependencies = [
    'typed',
    'matrix',
    'addScalar',
    'multiplyScalar',
    'divideScalar',
    'exp',
    'tau',
    'i',
    'dotDivide',
    'conj',
    'pow',
    'ceil',
    'log2'
];
var createFft = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, addScalar, multiplyScalar, divideScalar, exp, tau, i: I, dotDivide, conj, pow, ceil, log2 } = _ref;
    /**
   * Calculate N-dimensional Fourier transform
   *
   * Syntax:
   *
   *     math.fft(arr)
   *
   * Examples:
   *
   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]
   *
   *
   * See Also:
   *
   *      ifft
   *
   * @param {Array | Matrix} arr    An array or matrix
   * @return {Array | Matrix}       N-dimensional Fourier transformation of the array
   */ return typed(name, {
        Array: _ndFft,
        Matrix: function Matrix(matrix) {
            return matrix.create(_ndFft(matrix.valueOf()), matrix.datatype());
        }
    });
    "TURBOPACK unreachable";
    /**
   * Perform an N-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */ function _ndFft(arr) {
        var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(arr);
        if (size.length === 1) return _fft(arr, size[0]);
        // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0
        return _1dFft(arr.map((slice)=>_ndFft(slice, size.slice(1))), 0);
    }
    /**
   * Perform an 1-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @param {number} dim     dimension of the array to perform on
   * @return {Array}         resulting array
   */ function _1dFft(arr, dim) {
        var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(arr);
        if (dim !== 0) return new Array(size[0]).fill(0).map((_, i)=>_1dFft(arr[i], dim - 1));
        if (size.length === 1) return _fft(arr);
        function _transpose(arr) {
            // Swap first 2 dimensions
            var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(arr);
            return new Array(size[1]).fill(0).map((_, j)=>new Array(size[0]).fill(0).map((_, i)=>arr[i][j]));
        }
        return _transpose(_1dFft(_transpose(arr), 1));
    }
    /**
   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */ function _czt(arr) {
        var n = arr.length;
        var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));
        var chirp = [];
        for(var i = 1 - n; i < n; i++){
            chirp.push(pow(w, divideScalar(pow(i, 2), 2)));
        }
        var N2 = pow(2, ceil(log2(n + n - 1)));
        var xp = [
            ...new Array(n).fill(0).map((_, i)=>multiplyScalar(arr[i], chirp[n - 1 + i])),
            ...new Array(N2 - n).fill(0)
        ];
        var ichirp = [
            ...new Array(n + n - 1).fill(0).map((_, i)=>divideScalar(1, chirp[i])),
            ...new Array(N2 - (n + n - 1)).fill(0)
        ];
        var fftXp = _fft(xp);
        var fftIchirp = _fft(ichirp);
        var fftProduct = new Array(N2).fill(0).map((_, i)=>multiplyScalar(fftXp[i], fftIchirp[i]));
        var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
        var ret = [];
        for(var _i = n - 1; _i < n + n - 1; _i++){
            ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));
        }
        return ret;
    }
    /**
   * Perform an 1-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */ function _fft(arr) {
        var len = arr.length;
        if (len === 1) return [
            arr[0]
        ];
        if (len % 2 === 0) {
            var ret = [
                ..._fft(arr.filter((_, i)=>i % 2 === 0), len / 2),
                ..._fft(arr.filter((_, i)=>i % 2 === 1), len / 2)
            ];
            for(var k = 0; k < len / 2; k++){
                var p = ret[k];
                var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));
                ret[k] = addScalar(p, q);
                ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));
            }
            return ret;
        } else {
            // use chirp-z transform for non-power-of-2 FFT
            return _czt(arr);
        }
    // throw new Error('Can only calculate FFT of power-of-two size')
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/gamma.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createGamma": (()=>createGamma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/probability.js [app-ssr] (ecmascript)");
;
;
var name = 'gamma';
var dependencies = [
    'typed',
    'config',
    'multiplyScalar',
    'pow',
    'BigNumber',
    'Complex'
];
var createGamma = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, multiplyScalar, pow, BigNumber: _BigNumber, Complex } = _ref;
    /**
   * Compute the gamma function of a value using Lanczos approximation for
   * small values, and an extended Stirling approximation for large values.
   *
   * To avoid confusion with the matrix Gamma function, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.gamma(n)
   *
   * Examples:
   *
   *    math.gamma(5)       // returns 24
   *    math.gamma(-0.5)    // returns -3.5449077018110335
   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i
   *
   * See also:
   *
   *    combinations, factorial, permutations
   *
   * @param {number | BigNumber | Complex} n   A real or complex number
   * @return {number | BigNumber | Complex}    The gamma of `n`
   */ function gammaComplex(n) {
        if (n.im === 0) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaNumber"])(n.re);
        }
        // Lanczos approximation doesn't work well with real part lower than 0.5
        // So reflection formula is required
        if (n.re < 0.5) {
            // Euler's reflection formula
            // gamma(1-z) * gamma(z) = PI / sin(PI * z)
            // real part of Z should not be integer [sin(PI) == 0 -> 1/0 - undefined]
            // thanks to imperfect sin implementation sin(PI * n) != 0
            // we can safely use it anyway
            var _t = new Complex(1 - n.re, -n.im);
            var r = new Complex(Math.PI * n.re, Math.PI * n.im);
            return new Complex(Math.PI).div(r.sin()).div(gammaComplex(_t));
        }
        // Lanczos approximation
        // z -= 1
        n = new Complex(n.re - 1, n.im);
        // x = gammaPval[0]
        var x = new Complex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaP"][0], 0);
        // for (i, gammaPval) in enumerate(gammaP):
        for(var i = 1; i < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaP"].length; ++i){
            // x += gammaPval / (z + i)
            var gammaPval = new Complex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaP"][i], 0);
            x = x.add(gammaPval.div(n.add(i)));
        }
        // t = z + gammaG + 0.5
        var t = new Complex(n.re + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaG"] + 0.5, n.im);
        // y = sqrt(2 * pi) * t ** (z + 0.5) * exp(-t) * x
        var twoPiSqrt = Math.sqrt(2 * Math.PI);
        var tpow = t.pow(n.add(0.5));
        var expt = t.neg().exp();
        // y = [x] * [sqrt(2 * pi)] * [t ** (z + 0.5)] * [exp(-t)]
        return x.mul(twoPiSqrt).mul(tpow).mul(expt);
    }
    return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$probability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gammaNumber"],
        Complex: gammaComplex,
        BigNumber: function BigNumber(n) {
            if (n.isInteger()) {
                return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
            }
            if (!n.isFinite()) {
                return new _BigNumber(n.isNegative() ? NaN : Infinity);
            }
            throw new Error('Integer BigNumber expected');
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate factorial for a BigNumber
   * @param {BigNumber} n
   * @returns {BigNumber} Returns the factorial of n
   */ function bigFactorial(n) {
        if (n < 8) {
            return new _BigNumber([
                1,
                1,
                2,
                6,
                24,
                120,
                720,
                5040
            ][n]);
        }
        var precision = config.precision + (Math.log(n.toNumber()) | 0);
        var Big = _BigNumber.clone({
            precision
        });
        if (n % 2 === 1) {
            return n.times(bigFactorial(new _BigNumber(n - 1)));
        }
        var p = n;
        var prod = new Big(n);
        var sum = n.toNumber();
        while(p > 2){
            p -= 2;
            sum += p;
            prod = prod.times(sum);
        }
        return new _BigNumber(prod.toPrecision(_BigNumber.precision));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/ifft.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIfft": (()=>createIfft)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
var name = 'ifft';
var dependencies = [
    'typed',
    'fft',
    'dotDivide',
    'conj'
];
var createIfft = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, fft, dotDivide, conj } = _ref;
    /**
   * Calculate N-dimensional inverse Fourier transform
   *
   * Syntax:
   *
   *     math.ifft(arr)
   *
   * Examples:
   *
   *    math.ifft([[2, 2], [0, 0]]) // returns [[{re:1, im:0}, {re:0, im:0}], [{re:1, im:0}, {re:0, im:0}]]
   *
   * See Also:
   *
   *      fft
   *
   * @param {Array | Matrix} arr    An array or matrix
   * @return {Array | Matrix}       N-dimensional Fourier transformation of the array
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(arr) {
            var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(arr) ? arr.size() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(arr);
            return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr)=>acc * curr, 1));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setSize.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetSize": (()=>createSetSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setSize';
var dependencies = [
    'typed',
    'compareNatural'
];
var createSetSize = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, compareNatural } = _ref;
    /**
   * Count the number of elements of a (multi)set. When a second parameter is 'true', count only the unique values.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setSize(set)
   *    math.setSize(set, unique)
   *
   * Examples:
   *
   *    math.setSize([1, 2, 2, 4])          // returns 4
   *    math.setSize([1, 2, 2, 4], true)    // returns 3
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix} a  A multiset
   * @param {boolean} [unique]  If true, only the unique values are counted. False by default
   * @return {number}           The number of elements of the (multi)set
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(a) {
            return Array.isArray(a) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a).length : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a.toArray()).length;
        },
        'Array | Matrix, boolean': function Array__Matrix_boolean(a, unique) {
            if (unique === false || a.length === 0) {
                return Array.isArray(a) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a).length : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a.toArray()).length;
            } else {
                var b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
                var count = 1;
                for(var i = 1; i < b.length; i++){
                    if (compareNatural(b[i], b[i - 1]) !== 0) {
                        count++;
                    }
                }
                return count;
            }
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/divide.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDivide": (()=>createDivide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'divide';
var dependencies = [
    'typed',
    'matrix',
    'multiply',
    'equalScalar',
    'divideScalar',
    'inv'
];
var createDivide = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, multiply, equalScalar, divideScalar, inv } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3)            // returns number 0.6666666666666666
   *
   *    const a = math.complex(5, 14)
   *    const b = math.complex(4, 1)
   *    math.divide(a, b)            // returns Complex 2 + 3i
   *
   *    const c = [[7, -6], [13, -4]]
   *    const d = [[1, 2], [4, 3]]
   *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
   *
   *    const e = math.unit('18 km')
   *    math.divide(e, 4.5)          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */ return typed('divide', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extend"])({
        // we extend the signatures of divideScalar with signatures dealing with matrices
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(x, y) {
            // TODO: implement matrix right division using pseudo inverse
            // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
            // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
            // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
            return multiply(x, inv(y));
        },
        'DenseMatrix, any': function DenseMatrix_any(x, y) {
            return matAlgo14xDs(x, y, divideScalar, false);
        },
        'SparseMatrix, any': function SparseMatrix_any(x, y) {
            return matAlgo11xS0s(x, y, divideScalar, false);
        },
        'Array, any': function Array_any(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();
        },
        'any, Array | Matrix': function any_Array__Matrix(x, y) {
            return multiply(x, inv(y));
        }
    }, divideScalar.signatures));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/factorial.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFactorial": (()=>createFactorial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'factorial';
var dependencies = [
    'typed',
    'gamma'
];
var createFactorial = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, gamma } = _ref;
    /**
   * Compute the factorial of a value
   *
   * Factorial only supports an integer value as argument.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.factorial(n)
   *
   * Examples:
   *
   *    math.factorial(5)    // returns 120
   *    math.factorial(3)    // returns 6
   *
   * See also:
   *
   *    combinations, combinationsWithRep, gamma, permutations
   *
   * @param {number | BigNumber | Array | Matrix} n   An integer number
   * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
   */ return typed(name, {
        number: function number(n) {
            if (n < 0) {
                throw new Error('Value must be non-negative');
            }
            return gamma(n + 1);
        },
        BigNumber: function BigNumber(n) {
            if (n.isNegative()) {
                throw new Error('Value must be non-negative');
            }
            return gamma(n.plus(1));
        },
        'Array | Matrix': typed.referToSelf((self)=>(n)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMap"])(n, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/geometry/intersect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIntersect": (()=>createIntersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'intersect';
var dependencies = [
    'typed',
    'config',
    'abs',
    'add',
    'addScalar',
    'matrix',
    'multiply',
    'multiplyScalar',
    'divideScalar',
    'subtract',
    'smaller',
    'equalScalar',
    'flatten',
    'isZero',
    'isNumeric'
];
var createIntersect = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, abs, add, addScalar, matrix, multiply, multiplyScalar, divideScalar, subtract, smaller, equalScalar, flatten, isZero, isNumeric } = _ref;
    /**
   * Calculates the point of intersection of two lines in two or three dimensions
   * and of a line and a plane in three dimensions. The inputs are in the form of
   * arrays or 1 dimensional matrices. The line intersection functions return null
   * if the lines do not meet.
   *
   * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
   *
   * Syntax:
   *
   *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
   *    math.intersect(endPoint1, endPoint2, planeCoefficients)
   *
   * Examples:
   *
   *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10])              // Returns [5, 5]
   *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0])  // Returns [5, 5, 0]
   *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])            // Returns [7, -4, 3]
   *
   * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
   * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
   * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
   *                              OR Co-efficients of the plane's equation
   * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
   *                              OR undefined if the calculation is for line and plane
   * @return {Array}              Returns the point of intersection of lines/lines-planes
   */ return typed('intersect', {
        'Array, Array, Array': _AAA,
        'Array, Array, Array, Array': _AAAA,
        'Matrix, Matrix, Matrix': function Matrix_Matrix_Matrix(x, y, plane) {
            var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
            return arr === null ? null : matrix(arr);
        },
        'Matrix, Matrix, Matrix, Matrix': function Matrix_Matrix_Matrix_Matrix(w, x, y, z) {
            // TODO: output matrix type should match input matrix type
            var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
            return arr === null ? null : matrix(arr);
        }
    });
    "TURBOPACK unreachable";
    function _AAA(x, y, plane) {
        x = _coerceArr(x);
        y = _coerceArr(y);
        plane = _coerceArr(plane);
        if (!_3d(x)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
        }
        if (!_3d(y)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
        }
        if (!_4d(plane)) {
            throw new TypeError('Array with 4 numbers expected as third argument');
        }
        return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
    }
    function _AAAA(w, x, y, z) {
        w = _coerceArr(w);
        x = _coerceArr(x);
        y = _coerceArr(y);
        z = _coerceArr(z);
        if (w.length === 2) {
            if (!_2d(w)) {
                throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
            }
            if (!_2d(x)) {
                throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
            }
            if (!_2d(y)) {
                throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
            }
            if (!_2d(z)) {
                throw new TypeError('Array with 2 numbers or BigNumbers expected for fourth argument');
            }
            return _intersect2d(w, x, y, z);
        } else if (w.length === 3) {
            if (!_3d(w)) {
                throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
            }
            if (!_3d(x)) {
                throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
            }
            if (!_3d(y)) {
                throw new TypeError('Array with 3 numbers or BigNumbers expected for third argument');
            }
            if (!_3d(z)) {
                throw new TypeError('Array with 3 numbers or BigNumbers expected for fourth argument');
            }
            return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
        } else {
            throw new TypeError('Arrays with two or thee dimensional points expected');
        }
    }
    /** Coerce row and column 2-dim arrays to 1-dim array */ function _coerceArr(arr) {
        // row matrix
        if (arr.length === 1) return arr[0];
        // column matrix
        if (arr.length > 1 && Array.isArray(arr[0])) {
            if (arr.every((el)=>Array.isArray(el) && el.length === 1)) return flatten(arr);
        }
        return arr;
    }
    function _2d(x) {
        return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
    }
    function _3d(x) {
        return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
    }
    function _4d(x) {
        return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
    }
    function _intersect2d(p1a, p1b, p2a, p2b) {
        var o1 = p1a;
        var o2 = p2a;
        var d1 = subtract(o1, p1b);
        var d2 = subtract(o2, p2b);
        var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
        if (isZero(det)) return null;
        if (smaller(abs(det), config.relTol)) {
            return null;
        }
        var d20o11 = multiplyScalar(d2[0], o1[1]);
        var d21o10 = multiplyScalar(d2[1], o1[0]);
        var d20o21 = multiplyScalar(d2[0], o2[1]);
        var d21o20 = multiplyScalar(d2[1], o2[0]);
        var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
        return add(multiply(d1, t), o1);
    }
    function _intersect3dHelper(a, b, c, d, e, f, g, h, i, j, k, l) {
        // (a - b)*(c - d) + (e - f)*(g - h) + (i - j)*(k - l)
        var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
        var add2 = multiplyScalar(subtract(e, f), subtract(g, h));
        var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
        return addScalar(addScalar(add1, add2), add3);
    }
    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
        var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
        var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
        var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
        var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
        var numerator = subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
        var denominator = subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
        if (isZero(denominator)) return null;
        var ta = divideScalar(numerator, denominator);
        var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
        var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
        var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
        var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
        var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
        var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
        var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
        if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
            return [
                pax,
                pay,
                paz
            ];
        } else {
            return null;
        }
    }
    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
        var x1x = multiplyScalar(x1, x);
        var x2x = multiplyScalar(x2, x);
        var y1y = multiplyScalar(y1, y);
        var y2y = multiplyScalar(y2, y);
        var z1z = multiplyScalar(z1, z);
        var z2z = multiplyScalar(z2, z);
        var numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
        var denominator = subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
        var t = divideScalar(numerator, denominator);
        var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
        var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
        var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
        return [
            px,
            py,
            pz
        ];
    // TODO: Add cases when line is parallel to the plane:
    //       (a) no intersection,
    //       (b) line contained in plane
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLup": (()=>createLup)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'lup';
var dependencies = [
    'typed',
    'matrix',
    'abs',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'larger',
    'equalScalar',
    'unaryMinus',
    'DenseMatrix',
    'SparseMatrix',
    'Spa'
];
var createLup = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, abs, addScalar, divideScalar, multiplyScalar, subtractScalar, larger, equalScalar, unaryMinus, DenseMatrix, SparseMatrix, Spa } = _ref;
    /**
   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
   * row permutation vector `p` where `A[p,:] = L * U`
   *
   * Syntax:
   *
   *    math.lup(A)
   *
   * Example:
   *
   *    const m = [[2, 1], [1, 4]]
   *    const r = math.lup(m)
   *    // r = {
   *    //   L: [[1, 0], [0.5, 1]],
   *    //   U: [[2, 1], [0, 3.5]],
   *    //   P: [0, 1]
   *    // }
   *
   * See also:
   *
   *    slu, lsolve, lusolve, usolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
   *
   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.
   */ return typed(name, {
        DenseMatrix: function DenseMatrix(m) {
            return _denseLUP(m);
        },
        SparseMatrix: function SparseMatrix(m) {
            return _sparseLUP(m);
        },
        Array: function Array(a) {
            // create dense matrix from array
            var m = matrix(a);
            // lup, use matrix implementation
            var r = _denseLUP(m);
            // result
            return {
                L: r.L.valueOf(),
                U: r.U.valueOf(),
                p: r.p
            };
        }
    });
    "TURBOPACK unreachable";
    function _denseLUP(m) {
        // rows & columns
        var rows = m._size[0];
        var columns = m._size[1];
        // minimum rows and columns
        var n = Math.min(rows, columns);
        // matrix array, clone original data
        var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(m._data);
        // l matrix arrays
        var ldata = [];
        var lsize = [
            rows,
            n
        ];
        // u matrix arrays
        var udata = [];
        var usize = [
            n,
            columns
        ];
        // vars
        var i, j, k;
        // permutation vector
        var p = [];
        for(i = 0; i < rows; i++){
            p[i] = i;
        }
        // loop columns
        for(j = 0; j < columns; j++){
            // skip first column in upper triangular matrix
            if (j > 0) {
                // loop rows
                for(i = 0; i < rows; i++){
                    // min i,j
                    var min = Math.min(i, j);
                    // v[i, j]
                    var s = 0;
                    // loop up to min
                    for(k = 0; k < min; k++){
                        // s = l[i, k] - data[k, j]
                        s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
                    }
                    data[i][j] = subtractScalar(data[i][j], s);
                }
            }
            // row with larger value in cvector, row >= j
            var pi = j;
            var pabsv = 0;
            var vjj = 0;
            // loop rows
            for(i = j; i < rows; i++){
                // data @ i, j
                var v = data[i][j];
                // absolute value
                var absv = abs(v);
                // value is greater than pivote value
                if (larger(absv, pabsv)) {
                    // store row
                    pi = i;
                    // update max value
                    pabsv = absv;
                    // value @ [j, j]
                    vjj = v;
                }
            }
            // swap rows (j <-> pi)
            if (j !== pi) {
                // swap values j <-> pi in p
                p[j] = [
                    p[pi],
                    p[pi] = p[j]
                ][0];
                // swap j <-> pi in data
                DenseMatrix._swapRows(j, pi, data);
            }
            // check column is in lower triangular matrix
            if (j < rows) {
                // loop rows (lower triangular matrix)
                for(i = j + 1; i < rows; i++){
                    // value @ i, j
                    var vij = data[i][j];
                    if (!equalScalar(vij, 0)) {
                        // update data
                        data[i][j] = divideScalar(data[i][j], vjj);
                    }
                }
            }
        }
        // loop columns
        for(j = 0; j < columns; j++){
            // loop rows
            for(i = 0; i < rows; i++){
                // initialize row in arrays
                if (j === 0) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i] = [];
                    }
                    // L
                    ldata[i] = [];
                }
                // check we are in the upper triangular matrix
                if (i < j) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i][j] = data[i][j];
                    }
                    // check column exists in lower triangular matrix
                    if (j < rows) {
                        // L
                        ldata[i][j] = 0;
                    }
                    continue;
                }
                // diagonal value
                if (i === j) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i][j] = data[i][j];
                    }
                    // check column exists in lower triangular matrix
                    if (j < rows) {
                        // L
                        ldata[i][j] = 1;
                    }
                    continue;
                }
                // check row exists in upper triangular matrix
                if (i < columns) {
                    // U
                    udata[i][j] = 0;
                }
                // check column exists in lower triangular matrix
                if (j < rows) {
                    // L
                    ldata[i][j] = data[i][j];
                }
            }
        }
        // l matrix
        var l = new DenseMatrix({
            data: ldata,
            size: lsize
        });
        // u matrix
        var u = new DenseMatrix({
            data: udata,
            size: usize
        });
        // p vector
        var pv = [];
        for(i = 0, n = p.length; i < n; i++){
            pv[p[i]] = i;
        }
        // return matrices
        return {
            L: l,
            U: u,
            p: pv,
            toString: function toString() {
                return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
            }
        };
    }
    function _sparseLUP(m) {
        // rows & columns
        var rows = m._size[0];
        var columns = m._size[1];
        // minimum rows and columns
        var n = Math.min(rows, columns);
        // matrix arrays (will not be modified, thanks to permutation vector)
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // l matrix arrays
        var lvalues = [];
        var lindex = [];
        var lptr = [];
        var lsize = [
            rows,
            n
        ];
        // u matrix arrays
        var uvalues = [];
        var uindex = [];
        var uptr = [];
        var usize = [
            n,
            columns
        ];
        // vars
        var i, j, k;
        // permutation vectors, (current index -> original index) and (original index -> current index)
        var pvCo = [];
        var pvOc = [];
        for(i = 0; i < rows; i++){
            pvCo[i] = i;
            pvOc[i] = i;
        }
        // swap indices in permutation vectors (condition x < y)!
        var swapIndeces = function swapIndeces(x, y) {
            // find pv indeces getting data from x and y
            var kx = pvOc[x];
            var ky = pvOc[y];
            // update permutation vector current -> original
            pvCo[kx] = y;
            pvCo[ky] = x;
            // update permutation vector original -> current
            pvOc[x] = ky;
            pvOc[y] = kx;
        };
        // loop columns
        var _loop = function _loop() {
            // sparse accumulator
            var spa = new Spa();
            // check lower triangular matrix has a value @ column j
            if (j < rows) {
                // update ptr
                lptr.push(lvalues.length);
                // first value in j column for lower triangular matrix
                lvalues.push(1);
                lindex.push(j);
            }
            // update ptr
            uptr.push(uvalues.length);
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            // copy column j into sparse accumulator
            for(k = k0; k < k1; k++){
                // row
                i = index[k];
                // copy column values into sparse accumulator (use permutation vector)
                spa.set(pvCo[i], values[k]);
            }
            // skip first column in upper triangular matrix
            if (j > 0) {
                // loop rows in column j (above diagonal)
                spa.forEach(0, j - 1, function(k, vkj) {
                    // loop rows in column k (L)
                    SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function(i, vik) {
                        // check row is below k
                        if (i > k) {
                            // update spa value
                            spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));
                        }
                    });
                });
            }
            // row with larger value in spa, row >= j
            var pi = j;
            var vjj = spa.get(j);
            var pabsv = abs(vjj);
            // loop values in spa (order by row, below diagonal)
            spa.forEach(j + 1, rows - 1, function(x, v) {
                // absolute value
                var absv = abs(v);
                // value is greater than pivote value
                if (larger(absv, pabsv)) {
                    // store row
                    pi = x;
                    // update max value
                    pabsv = absv;
                    // value @ [j, j]
                    vjj = v;
                }
            });
            // swap rows (j <-> pi)
            if (j !== pi) {
                // swap values j <-> pi in L
                SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
                // swap values j <-> pi in U
                SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
                // swap values in spa
                spa.swap(j, pi);
                // update permutation vector (swap values @ j, pi)
                swapIndeces(j, pi);
            }
            // loop values in spa (order by row)
            spa.forEach(0, rows - 1, function(x, v) {
                // check we are above diagonal
                if (x <= j) {
                    // update upper triangular matrix
                    uvalues.push(v);
                    uindex.push(x);
                } else {
                    // update value
                    v = divideScalar(v, vjj);
                    // check value is non zero
                    if (!equalScalar(v, 0)) {
                        // update lower triangular matrix
                        lvalues.push(v);
                        lindex.push(x);
                    }
                }
            });
        };
        for(j = 0; j < columns; j++){
            _loop();
        }
        // update ptrs
        uptr.push(uvalues.length);
        lptr.push(lvalues.length);
        // return matrices
        return {
            L: new SparseMatrix({
                values: lvalues,
                index: lindex,
                ptr: lptr,
                size: lsize
            }),
            U: new SparseMatrix({
                values: uvalues,
                index: uindex,
                ptr: uptr,
                size: usize
            }),
            p: pvCo,
            toString: function toString() {
                return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
            }
        };
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/multinomial.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMultinomial": (()=>createMultinomial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'multinomial';
var dependencies = [
    'typed',
    'add',
    'divide',
    'multiply',
    'factorial',
    'isInteger',
    'isPositive'
];
var createMultinomial = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, divide, multiply, factorial, isInteger, isPositive } = _ref;
    /**
   * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
   *
   * multinomial takes one array of integers as an argument.
   * The following condition must be enforced: every ai <= 0
   *
   * Syntax:
   *
   *     math.multinomial(a) // a is an array type
   *
   * Examples:
   *
   *    math.multinomial([1,2,1]) // returns 12
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
   * @return {Number | BigNumber}         Multinomial coefficient.
   */ return typed(name, {
        'Array | Matrix': function Array__Matrix(a) {
            var sum = 0;
            var denom = 1;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(a, function(ai) {
                if (!isInteger(ai) || !isPositive(ai)) {
                    throw new TypeError('Positive integer value expected in function multinomial');
                }
                sum = add(sum, ai);
                denom = multiply(denom, factorial(ai));
            });
            return divide(factorial(sum), denom);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/permutations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPermutations": (()=>createPermutations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/product.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'permutations';
var dependencies = [
    'typed',
    'factorial'
];
var createPermutations = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, factorial } = _ref;
    /**
   * Compute the number of ways of obtaining an ordered subset of `k` elements
   * from a set of `n` elements.
   *
   * Permutations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.permutations(n)
   *     math.permutations(n, k)
   *
   * Examples:
   *
   *    math.permutations(5)     // 120
   *    math.permutations(5, 3)  // 60
   *
   * See also:
   *
   *    combinations, combinationsWithRep, factorial
   *
   * @param {number | BigNumber} n   The number of objects in total
   * @param {number | BigNumber} [k] The number of objects in the subset
   * @return {number | BigNumber}    The number of permutations
   */ return typed(name, {
        'number | BigNumber': factorial,
        'number, number': function number_number(n, k) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(n) || n < 0) {
                throw new TypeError('Positive integer value expected in function permutations');
            }
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(k) || k < 0) {
                throw new TypeError('Positive integer value expected in function permutations');
            }
            if (k > n) {
                throw new TypeError('second argument k must be less than or equal to first argument n');
            }
            // Permute n objects, k at a time
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$product$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["product"])(n - k + 1, n);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(n, k) {
            var result, i;
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
                throw new TypeError('Positive integer value expected in function permutations');
            }
            if (k.gt(n)) {
                throw new TypeError('second argument k must be less than or equal to first argument n');
            }
            var one = n.mul(0).add(1);
            result = one;
            for(i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)){
                result = result.times(i);
            }
            return result;
        }
    });
});
/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */ function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPolynomialRoot": (()=>createPolynomialRoot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'polynomialRoot';
var dependencies = [
    'typed',
    'isZero',
    'equalScalar',
    'add',
    'subtract',
    'multiply',
    'divide',
    'sqrt',
    'unaryMinus',
    'cbrt',
    'typeOf',
    'im',
    're'
];
var createPolynomialRoot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isZero, equalScalar, add, subtract, multiply, divide, sqrt, unaryMinus, cbrt, typeOf, im, re } = _ref;
    /**
   * Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
   * Currently operates only on linear, quadratic, and cubic polynomials using the standard
   * formulas for the roots.
   *
   * Syntax:
   *
   *     math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
   *
   * Examples:
   *     // linear
   *     math.polynomialRoot(6, 3)                                        // [-2]
   *     math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]
   *     math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]
   *     // quadratic
   *     math.polynomialRoot(2, -3, 1)                                    // [2, 1]
   *     math.polynomialRoot(8, 8, 2)                                     // [-2]
   *     math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]
   *     math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]
   *     math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]
   *     // cubic
   *     math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]
   *     math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]
   *     math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]
   *     math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]
   *
   * See also:
   *     cbrt, sqrt
   *
   * @param {... number | Complex} coeffs
   *     The coefficients of the polynomial, starting with with the constant coefficent, followed
   *     by the linear coefficient and subsequent coefficients of increasing powers.
   * @return {Array} The distinct roots of the polynomial
   */ return typed(name, {
        'number|Complex, ...number|Complex': (constant, restCoeffs)=>{
            var coeffs = [
                constant,
                ...restCoeffs
            ];
            while(coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])){
                coeffs.pop();
            }
            if (coeffs.length < 2) {
                throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
            }
            switch(coeffs.length){
                case 2:
                    // linear
                    return [
                        unaryMinus(divide(coeffs[0], coeffs[1]))
                    ];
                case 3:
                    {
                        // quadratic
                        var [c, b, a] = coeffs;
                        var denom = multiply(2, a);
                        var d1 = multiply(b, b);
                        var d2 = multiply(4, a, c);
                        if (equalScalar(d1, d2)) return [
                            divide(unaryMinus(b), denom)
                        ];
                        var discriminant = sqrt(subtract(d1, d2));
                        return [
                            divide(subtract(discriminant, b), denom),
                            divide(subtract(unaryMinus(discriminant), b), denom)
                        ];
                    }
                case 4:
                    {
                        // cubic, cf. https://en.wikipedia.org/wiki/Cubic_equation
                        var [d, _c, _b, _a] = coeffs;
                        var _denom = unaryMinus(multiply(3, _a));
                        var D0_1 = multiply(_b, _b);
                        var D0_2 = multiply(3, _a, _c);
                        var D1_1 = add(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
                        var D1_2 = multiply(9, _a, _b, _c);
                        if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
                            return [
                                divide(_b, _denom)
                            ];
                        }
                        var Delta0 = subtract(D0_1, D0_2);
                        var Delta1 = subtract(D1_1, D1_2);
                        var discriminant1 = add(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
                        var discriminant2 = add(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
                        if (equalScalar(discriminant1, discriminant2)) {
                            return [
                                divide(subtract(multiply(4, _a, _b, _c), add(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
                                // simple root
                                divide(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0)) // double root
                            ];
                        }
                        // OK, we have three distinct roots
                        var Ccubed;
                        if (equalScalar(D0_1, D0_2)) {
                            Ccubed = Delta1;
                        } else {
                            Ccubed = divide(add(Delta1, sqrt(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
                        }
                        var allRoots = true;
                        var rawRoots = cbrt(Ccubed, allRoots).toArray().map((C)=>divide(add(_b, C, divide(Delta0, C)), _denom));
                        return rawRoots.map((r)=>{
                            if (typeOf(r) === 'Complex' && equalScalar(re(r), re(r) + im(r))) {
                                return re(r);
                            }
                            return r;
                        });
                    }
                default:
                    throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
            }
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setIntersect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetIntersect": (()=>createSetIntersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setIntersect';
var dependencies = [
    'typed',
    'size',
    'subset',
    'compareNatural',
    'Index',
    'DenseMatrix'
];
var createSetIntersect = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, subset, compareNatural, Index, DenseMatrix } = _ref;
    /**
   * Create the intersection of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setIntersect(set1, set2)
   *
   * Examples:
   *
   *    math.setIntersect([1, 2, 3, 4], [3, 4, 5, 6])            // returns [3, 4]
   *    math.setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [3, 4]
   *
   * See also:
   *
   *    setUnion, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The intersection of two (multi)sets
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            var result;
            if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
                // of any of them is empty, return empty
                result = [];
            } else {
                var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
                var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
                result = [];
                for(var i = 0; i < b1.length; i++){
                    for(var j = 0; j < b2.length; j++){
                        if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                            // the identifier is always a decimal int
                            result.push(b1[i]);
                            break;
                        }
                    }
                }
            }
            // return an array, if both inputs were arrays
            if (Array.isArray(a1) && Array.isArray(a2)) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generalize"])(result);
            }
            // return a matrix otherwise
            return new DenseMatrix((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generalize"])(result));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/numeric/solveODE.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSolveODE": (()=>createSolveODE)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
;
;
var name = 'solveODE';
var dependencies = [
    'typed',
    'add',
    'subtract',
    'multiply',
    'divide',
    'max',
    'map',
    'abs',
    'isPositive',
    'isNegative',
    'larger',
    'smaller',
    'matrix',
    'bignumber',
    'unaryMinus'
];
var createSolveODE = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, subtract, multiply, divide, max, map, abs, isPositive, isNegative, larger, smaller, matrix, bignumber, unaryMinus } = _ref;
    /**
     * Numerical Integration of Ordinary Differential Equations
     *
     * Two variable step methods are provided:
     * - "RK23": Bogacki–Shampine method
     * - "RK45": Dormand-Prince method RK5(4)7M (default)
     *
     * The arguments are expected as follows.
     *
     * - `func` should be the forcing function `f(t, y)`
     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`
     * - `y0` the initial state values, should be a scalar or a flat array
     * - `options` should be an object with the following information:
     *   - `method` ('RK45'): ['RK23', 'RK45']
     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value
     *   - `firstStep`: Initial step size
     *   - `minStep`: minimum step size of the method
     *   - `maxStep`: maximum step size of the method
     *   - `minDelta` (0.2): minimum ratio of change for the step
     *   - `maxDelta` (5): maximum ratio of change for the step
     *   - `maxIter` (1e4): maximum number of iterations
     *
     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:
     * - `t` an array of size `[n]`
     * - `y` the states array can be in two ways
     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`
     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`
     *
     * Syntax:
     *
     *     math.solveODE(func, tspan, y0)
     *     math.solveODE(func, tspan, y0, options)
     *
     * Examples:
     *
     *     function func(t, y) {return y}
     *     const tspan = [0, 4]
     *     const y0 = 1
     *     math.solveODE(func, tspan, y0)
     *     math.solveODE(func, tspan, [1, 2])
     *     math.solveODE(func, tspan, y0, { method:"RK23", maxStep:0.1 })
     *
     * See also:
     *
     *     derivative, simplifyCore
     *
     * @param {function} func The forcing function f(t,y)
     * @param {Array | Matrix} tspan The time span
     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value
     * @param {Object} [options] Optional configuration options
     * @return {Object} Return an object with t and y values as arrays
     */ function _rk(butcherTableau) {
        // generates an adaptive runge kutta method from it's butcher tableau
        return function(f, tspan, y0, options) {
            // adaptive runge kutta methods
            var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUnit"])));
            if (wrongTSpan) {
                throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
            }
            var t0 = tspan[0]; // initial time
            var tf = tspan[1]; // final time
            var isForwards = larger(tf, t0);
            var firstStep = options.firstStep;
            if (firstStep !== undefined && !isPositive(firstStep)) {
                throw new Error('"firstStep" must be positive');
            }
            var maxStep = options.maxStep;
            if (maxStep !== undefined && !isPositive(maxStep)) {
                throw new Error('"maxStep" must be positive');
            }
            var minStep = options.minStep;
            if (minStep && isNegative(minStep)) {
                throw new Error('"minStep" must be positive or zero');
            }
            var timeVars = [
                t0,
                tf,
                firstStep,
                minStep,
                maxStep
            ].filter((x)=>x !== undefined);
            if (!(timeVars.every(isNumOrBig) || timeVars.every(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUnit"]))) {
                throw new Error('Inconsistent type of "t" dependant variables');
            }
            var steps = 1; // divide time in this number of steps
            var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)
            var minDelta = options.minDelta ? options.minDelta : 0.2;
            var maxDelta = options.maxDelta ? options.maxDelta : 5;
            var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong
            var hasBigNumbers = [
                t0,
                tf,
                ...y0,
                maxStep,
                minStep
            ].some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"]);
            var [a, c, b, bp] = hasBigNumbers ? [
                bignumber(butcherTableau.a),
                bignumber(butcherTableau.c),
                bignumber(butcherTableau.b),
                bignumber(butcherTableau.bp)
            ] : [
                butcherTableau.a,
                butcherTableau.c,
                butcherTableau.b,
                butcherTableau.bp
            ];
            var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size
            var t = [
                t0
            ]; // start the time array
            var y = [
                y0
            ]; // start the solution array
            var deltaB = subtract(b, bp); // b - bp
            var n = 0;
            var iter = 0;
            var ongoing = _createOngoing(isForwards);
            var trimStep = _createTrimStep(isForwards);
            // iterate unitil it reaches either the final time or maximum iterations
            while(ongoing(t[n], tf)){
                var k = [];
                // trim the time step so that it doesn't overshoot
                h = trimStep(t[n], tf, h);
                // calculate the first value of k
                k.push(f(t[n], y[n]));
                // calculate the rest of the values of k
                for(var i = 1; i < c.length; ++i){
                    k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));
                }
                // estimate the error by comparing solutions of different orders
                var TE = max(abs(map(multiply(deltaB, k), (X)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUnit"])(X) ? X.value : X)));
                if (TE < tol && tol / TE > 1 / 4) {
                    // push solution if within tol
                    t.push(add(t[n], h));
                    y.push(add(y[n], multiply(h, b, k)));
                    n++;
                }
                // estimate the delta value that will affect the step size
                var delta = 0.84 * (tol / TE) ** (1 / 5);
                if (smaller(delta, minDelta)) {
                    delta = minDelta;
                } else if (larger(delta, maxDelta)) {
                    delta = maxDelta;
                }
                delta = hasBigNumbers ? bignumber(delta) : delta;
                h = multiply(h, delta);
                if (maxStep && larger(abs(h), maxStep)) {
                    h = isForwards ? maxStep : unaryMinus(maxStep);
                } else if (minStep && smaller(abs(h), minStep)) {
                    h = isForwards ? minStep : unaryMinus(minStep);
                }
                iter++;
                if (iter > maxIter) {
                    throw new Error('Maximum number of iterations reached, try changing options');
                }
            }
            return {
                t,
                y
            };
        };
    }
    function _rk23(f, tspan, y0, options) {
        // Bogacki–Shampine method
        // Define the butcher table
        var a = [
            [],
            [
                1 / 2
            ],
            [
                0,
                3 / 4
            ],
            [
                2 / 9,
                1 / 3,
                4 / 9
            ]
        ];
        var c = [
            null,
            1 / 2,
            3 / 4,
            1
        ];
        var b = [
            2 / 9,
            1 / 3,
            4 / 9,
            0
        ];
        var bp = [
            7 / 24,
            1 / 4,
            1 / 3,
            1 / 8
        ];
        var butcherTableau = {
            a,
            c,
            b,
            bp
        };
        // Solve an adaptive step size rk method
        return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _rk45(f, tspan, y0, options) {
        // Dormand Prince method
        // Define the butcher tableau
        var a = [
            [],
            [
                1 / 5
            ],
            [
                3 / 40,
                9 / 40
            ],
            [
                44 / 45,
                -56 / 15,
                32 / 9
            ],
            [
                19372 / 6561,
                -25360 / 2187,
                64448 / 6561,
                -212 / 729
            ],
            [
                9017 / 3168,
                -355 / 33,
                46732 / 5247,
                49 / 176,
                -5103 / 18656
            ],
            [
                35 / 384,
                0,
                500 / 1113,
                125 / 192,
                -2187 / 6784,
                11 / 84
            ]
        ];
        var c = [
            null,
            1 / 5,
            3 / 10,
            4 / 5,
            8 / 9,
            1,
            1
        ];
        var b = [
            35 / 384,
            0,
            500 / 1113,
            125 / 192,
            -2187 / 6784,
            11 / 84,
            0
        ];
        var bp = [
            5179 / 57600,
            0,
            7571 / 16695,
            393 / 640,
            -92097 / 339200,
            187 / 2100,
            1 / 40
        ];
        var butcherTableau = {
            a,
            c,
            b,
            bp
        };
        // Solve an adaptive step size rk method
        return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _solveODE(f, tspan, y0, opt) {
        var method = opt.method ? opt.method : 'RK45';
        var methods = {
            RK23: _rk23,
            RK45: _rk45
        };
        if (method.toUpperCase() in methods) {
            var methodOptions = _objectSpread({}, opt); // clone the options object
            delete methodOptions.method; // delete the method as it won't be needed
            return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
        } else {
            // throw an error indicating there is no such method
            var methodsWithQuotes = Object.keys(methods).map((x)=>"\"".concat(x, "\""));
            // generates a string of methods like: "BDF", "RK23" and "RK45"
            var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(', '), " and ").concat(methodsWithQuotes.slice(-1));
            throw new Error("Unavailable method \"".concat(method, "\". Available methods are ").concat(availableMethodsString));
        }
    }
    function _createOngoing(isForwards) {
        // returns the correct function to test if it's still iterating
        return isForwards ? smaller : larger;
    }
    function _createTrimStep(isForwards) {
        var outOfBounds = isForwards ? larger : smaller;
        return function(t, tf, h) {
            var next = add(t, h);
            return outOfBounds(next, tf) ? subtract(tf, t) : h;
        };
    }
    function isNumOrBig(x) {
        // checks if it's a number or bignumber
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(x) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(x);
    }
    function _matrixSolveODE(f, T, y0, options) {
        // receives matrices and returns matrices
        var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
        return {
            t: matrix(sol.t),
            y: matrix(sol.y)
        };
    }
    return typed('solveODE', {
        'function, Array, Array, Object': _solveODE,
        'function, Matrix, Matrix, Object': _matrixSolveODE,
        'function, Array, Array': (f, T, y0)=>_solveODE(f, T, y0, {}),
        'function, Matrix, Matrix': (f, T, y0)=>_matrixSolveODE(f, T, y0, {}),
        'function, Array, number | BigNumber | Unit': (f, T, y0)=>{
            var sol = _solveODE(f, T, [
                y0
            ], {});
            return {
                t: sol.t,
                y: sol.y.map((Y)=>Y[0])
            };
        },
        'function, Matrix, number | BigNumber | Unit': (f, T, y0)=>{
            var sol = _solveODE(f, T.toArray(), [
                y0
            ], {});
            return {
                t: matrix(sol.t),
                y: matrix(sol.y.map((Y)=>Y[0]))
            };
        },
        'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options)=>{
            var sol = _solveODE(f, T, [
                y0
            ], options);
            return {
                t: sol.t,
                y: sol.y.map((Y)=>Y[0])
            };
        },
        'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options)=>{
            var sol = _solveODE(f, T.toArray(), [
                y0
            ], options);
            return {
                t: matrix(sol.t),
                y: matrix(sol.y.map((Y)=>Y[0]))
            };
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createStirlingS2": (()=>createStirlingS2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
var name = 'stirlingS2';
var dependencies = [
    'typed',
    'addScalar',
    'subtractScalar',
    'multiplyScalar',
    'divideScalar',
    'pow',
    'factorial',
    'combinations',
    'isNegative',
    'isInteger',
    'number',
    '?bignumber',
    'larger'
];
var createStirlingS2 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, subtractScalar, multiplyScalar, divideScalar, pow, factorial, combinations, isNegative, isInteger, number, bignumber, larger } = _ref;
    var smallCache = [];
    var bigCache = [];
    /**
   * The Stirling numbers of the second kind, counts the number of ways to partition
   * a set of n labelled objects into k nonempty unlabelled subsets.
   * stirlingS2 only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   *  If n = k or k = 1 <= n, then s(n,k) = 1
   *  If k = 0 < n, then s(n,k) = 0
   *
   * Note that if either n or k is supplied as a BigNumber, the result will be
   * as well.
   *
   * Syntax:
   *
   *   math.stirlingS2(n, k)
   *
   * Examples:
   *
   *    math.stirlingS2(5, 3) //returns 25
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     S(n,k)
   */ return typed(name, {
        'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(n, k) {
            if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {
                throw new TypeError('Non-negative integer value expected in function stirlingS2');
            } else if (larger(k, n)) {
                throw new TypeError('k must be less than or equal to n in function stirlingS2');
            }
            var big = !((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(n) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(k));
            var cache = big ? bigCache : smallCache;
            var make = big ? bignumber : number;
            var nn = number(n);
            var nk = number(k);
            /* See if we already have the value: */ if (cache[nn] && cache[nn].length > nk) {
                return cache[nn][nk];
            }
            /* Fill the cache */ for(var m = 0; m <= nn; ++m){
                if (!cache[m]) {
                    cache[m] = [
                        m === 0 ? make(1) : make(0)
                    ];
                }
                if (m === 0) continue;
                var row = cache[m];
                var prev = cache[m - 1];
                for(var i = row.length; i <= m && i <= nk; ++i){
                    if (i === m) {
                        row[i] = 1;
                    } else {
                        row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
                    }
                }
            }
            return cache[nn][nk];
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBellNumbers": (()=>createBellNumbers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'bellNumbers';
var dependencies = [
    'typed',
    'addScalar',
    'isNegative',
    'isInteger',
    'stirlingS2'
];
var createBellNumbers = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, addScalar, isNegative, isInteger, stirlingS2 } = _ref;
    /**
   * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
   * bellNumbers only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.bellNumbers(n)
   *
   * Examples:
   *
   *    math.bellNumbers(3) // returns 5
   *    math.bellNumbers(8) // returns 4140
   *
   * See also:
   *
   *    stirlingS2
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @return {Number | BigNumber}     B(n)
   */ return typed(name, {
        'number | BigNumber': function number__BigNumber(n) {
            if (!isInteger(n) || isNegative(n)) {
                throw new TypeError('Non-negative integer value expected in function bellNumbers');
            }
            // Sum (k=0, n) S(n,k).
            var result = 0;
            for(var i = 0; i <= n; i++){
                result = addScalar(result, stirlingS2(n, i));
            }
            return result;
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/cumsum.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCumSum": (()=>createCumSum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$switch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/switch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/IndexError.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'cumsum';
var dependencies = [
    'typed',
    'add',
    'unaryPlus'
];
var createCumSum = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, unaryPlus } = _ref;
    /**
   * Compute the cumulative sum of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the cumulative sums
   * along a specified dimension (defaulting to the first) will be calculated.
   *
   * Syntax:
   *
   *     math.cumsum(a, b, c, ...)
   *     math.cumsum(A)
   *
   * Examples:
   *
   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]
   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]
   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]
   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]
   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]
   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, variance, sum
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The cumulative sum of all values
   */ return typed(name, {
        // sum([a, b, c, d, ...])
        Array: _cumsum,
        Matrix: function Matrix(matrix) {
            return matrix.create(_cumsum(matrix.valueOf(), matrix.datatype()));
        },
        // sum([a, b, c, d, ...], dim)
        'Array, number | BigNumber': _ncumSumDim,
        'Matrix, number | BigNumber': function Matrix_number__BigNumber(matrix, dim) {
            return matrix.create(_ncumSumDim(matrix.valueOf(), dim), matrix.datatype());
        },
        // cumsum(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('All values expected to be scalar in function cumsum');
            }
            return _cumsum(args);
        }
    });
    "TURBOPACK unreachable";
    /**
     * Recursively calculate the cumulative sum of an n-dimensional array
     * @param {Array} array
     * @return {number} cumsum
     * @private
     */ function _cumsum(array) {
        try {
            return _cumsummap(array);
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, name);
        }
    }
    function _cumsummap(array) {
        if (array.length === 0) {
            return [];
        }
        var sums = [
            unaryPlus(array[0])
        ]; // unaryPlus converts to number if need be
        for(var i = 1; i < array.length; ++i){
            // Must use add below and not addScalar for the case of summing a
            // 2+-dimensional array along the 0th dimension (the row vectors,
            // or higher-d analogues, are literally added to each other).
            sums.push(add(sums[i - 1], array[i]));
        }
        return sums;
    }
    function _ncumSumDim(array, dim) {
        var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(array);
        if (dim < 0 || dim >= size.length) {
            // TODO: would be more clear when throwing a DimensionError here
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$IndexError$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IndexError"](dim, size.length);
        }
        try {
            return _cumsumDimensional(array, dim);
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, name);
        }
    }
    /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */ function _cumsumDimensional(mat, dim) {
        var i, ret, tran;
        if (dim <= 0) {
            var initialValue = mat[0][0];
            if (!Array.isArray(initialValue)) {
                return _cumsummap(mat);
            } else {
                tran = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$switch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_switch"])(mat);
                ret = [];
                for(i = 0; i < tran.length; i++){
                    ret[i] = _cumsumDimensional(tran[i], dim - 1);
                }
                return ret;
            }
        } else {
            ret = [];
            for(i = 0; i < mat.length; i++){
                ret[i] = _cumsumDimensional(mat[i], dim - 1);
            }
            return ret;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createComplexEigs": (()=>createComplexEigs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
function createComplexEigs(_ref) {
    var { addScalar, subtract, flatten, multiply, multiplyScalar, divideScalar, sqrt, abs, bignumber, diag, size, reshape, inv, qr, usolve, usolveAll, equal, complex, larger, smaller, matrixFromColumns, dot } = _ref;
    /**
   * @param {number[][]} arr the matrix to find eigenvalues of
   * @param {number} N size of the matrix
   * @param {number|BigNumber} prec precision, anything lower will be considered zero
   * @param {'number'|'BigNumber'|'Complex'} type
   * @param {boolean} findVectors should we find eigenvectors?
   *
   * @returns {{ values: number[], vectors: number[][] }}
   */ function complexEigs(arr, N, prec, type) {
        var findVectors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        // TODO check if any row/col are zero except the diagonal
        // make sure corresponding rows and columns have similar magnitude
        // important because of numerical stability
        // MODIFIES arr by side effect!
        var R = balance(arr, N, prec, type, findVectors);
        // R is the row transformation matrix
        // arr = A' = R A R^-1, A is the original matrix
        // (if findVectors is false, R is undefined)
        // (And so to return to original matrix: A = R^-1 arr R)
        // TODO if magnitudes of elements vary over many orders,
        // move greatest elements to the top left corner
        // using similarity transformations, reduce the matrix
        // to Hessenberg form (upper triangular plus one subdiagonal row)
        // updates the transformation matrix R with new row operationsq
        // MODIFIES arr by side effect!
        reduceToHessenberg(arr, N, prec, type, findVectors, R);
        // still true that original A = R^-1 arr R)
        // find eigenvalues
        var { values, C } = iterateUntilTriangular(arr, N, prec, type, findVectors);
        // values is the list of eigenvalues, C is the column
        // transformation matrix that transforms arr, the hessenberg
        // matrix, to upper triangular
        // (So U = C^-1 arr C and the relationship between current arr
        // and original A is unchanged.)
        if (findVectors) {
            var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
            return {
                values,
                eigenvectors
            };
        }
        return {
            values
        };
    }
    /**
   * @param {number[][]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {number[][]}
   */ function balance(arr, N, prec, type, findVectors) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var realzero = big ? bignumber(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        var realone = big ? bignumber(1) : 1;
        // base of the floating-point arithmetic
        var radix = big ? bignumber(10) : 2;
        var radixSq = multiplyScalar(radix, radix);
        // the diagonal transformation matrix R
        var Rdiag;
        if (findVectors) {
            Rdiag = Array(N).fill(one);
        }
        // this isn't the only time we loop thru the matrix...
        var last = false;
        while(!last){
            // ...haha I'm joking! unless...
            last = true;
            for(var i = 0; i < N; i++){
                // compute the taxicab norm of i-th column and row
                // TODO optimize for complex numbers
                var colNorm = realzero;
                var rowNorm = realzero;
                for(var j = 0; j < N; j++){
                    if (i === j) continue;
                    colNorm = addScalar(colNorm, abs(arr[j][i]));
                    rowNorm = addScalar(rowNorm, abs(arr[i][j]));
                }
                if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
                    // find integer power closest to balancing the matrix
                    // (we want to scale only by integer powers of radix,
                    // so that we don't lose any precision due to round-off)
                    var f = realone;
                    var c = colNorm;
                    var rowDivRadix = divideScalar(rowNorm, radix);
                    var rowMulRadix = multiplyScalar(rowNorm, radix);
                    while(smaller(c, rowDivRadix)){
                        c = multiplyScalar(c, radixSq);
                        f = multiplyScalar(f, radix);
                    }
                    while(larger(c, rowMulRadix)){
                        c = divideScalar(c, radixSq);
                        f = divideScalar(f, radix);
                    }
                    // check whether balancing is needed
                    // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)
                    var condition = smaller(divideScalar(addScalar(c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));
                    // apply balancing similarity transformation
                    if (condition) {
                        // we should loop once again to check whether
                        // another rebalancing is needed
                        last = false;
                        var g = divideScalar(1, f);
                        for(var _j = 0; _j < N; _j++){
                            if (i === _j) {
                                continue;
                            }
                            arr[i][_j] = multiplyScalar(arr[i][_j], g);
                            arr[_j][i] = multiplyScalar(arr[_j][i], f);
                        }
                        // keep track of transformations
                        if (findVectors) {
                            Rdiag[i] = multiplyScalar(Rdiag[i], g);
                        }
                    }
                }
            }
        }
        // return the diagonal row transformation matrix
        return findVectors ? diag(Rdiag) : null;
    }
    /**
   * @param {number[][]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number'|'BigNumber'|'Complex'} type
   * @param {boolean} findVectors
   * @param {number[][]} R the row transformation matrix that will be modified
   */ function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        if (big) {
            prec = bignumber(prec);
        }
        for(var i = 0; i < N - 2; i++){
            // Find the largest subdiag element in the i-th col
            var maxIndex = 0;
            var max = zero;
            for(var j = i + 1; j < N; j++){
                var el = arr[j][i];
                if (smaller(abs(max), abs(el))) {
                    max = el;
                    maxIndex = j;
                }
            }
            // This col is pivoted, no need to do anything
            if (smaller(abs(max), prec)) {
                continue;
            }
            if (maxIndex !== i + 1) {
                // Interchange maxIndex-th and (i+1)-th row
                var tmp1 = arr[maxIndex];
                arr[maxIndex] = arr[i + 1];
                arr[i + 1] = tmp1;
                // Interchange maxIndex-th and (i+1)-th column
                for(var _j2 = 0; _j2 < N; _j2++){
                    var tmp2 = arr[_j2][maxIndex];
                    arr[_j2][maxIndex] = arr[_j2][i + 1];
                    arr[_j2][i + 1] = tmp2;
                }
                // keep track of transformations
                if (findVectors) {
                    var tmp3 = R[maxIndex];
                    R[maxIndex] = R[i + 1];
                    R[i + 1] = tmp3;
                }
            }
            // Reduce following rows and columns
            for(var _j3 = i + 2; _j3 < N; _j3++){
                var n = divideScalar(arr[_j3][i], max);
                if (n === 0) {
                    continue;
                }
                // from j-th row subtract n-times (i+1)th row
                for(var k = 0; k < N; k++){
                    arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
                }
                // to (i+1)th column add n-times j-th column
                for(var _k = 0; _k < N; _k++){
                    arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
                }
                // keep track of transformations
                if (findVectors) {
                    for(var _k2 = 0; _k2 < N; _k2++){
                        R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
                    }
                }
            }
        }
        return R;
    }
    /**
   * @returns {{values: values, C: Matrix}}
   * @see Press, Wiliams: Numerical recipes in Fortran 77
   * @see https://en.wikipedia.org/wiki/QR_algorithm
   */ function iterateUntilTriangular(A, N, prec, type, findVectors) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        if (big) {
            prec = bignumber(prec);
        }
        // The Francis Algorithm
        // The core idea of this algorithm is that doing successive
        // A' = QtAQ transformations will eventually converge to block-
        // upper-triangular with diagonal blocks either 1x1 or 2x2.
        // The Q here is the one from the QR decomposition, A = QR.
        // Since the eigenvalues of a block-upper-triangular matrix are
        // the eigenvalues of its diagonal blocks and we know how to find
        // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.
        var arr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(A);
        // the list of converged eigenvalues
        var lambdas = [];
        // size of arr, which will get smaller as eigenvalues converge
        var n = N;
        // the diagonal of the block-diagonal matrix that turns
        // converged 2x2 matrices into upper triangular matrices
        var Sdiag = [];
        // N×N matrix describing the overall transformation done during the QR algorithm
        var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;
        // nxn matrix describing the QR transformations done since last convergence
        var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;
        // last eigenvalue converged before this many steps
        var lastConvergenceBefore = 0;
        while(lastConvergenceBefore <= 100){
            lastConvergenceBefore += 1;
            // TODO if the convergence is slow, do something clever
            // Perform the factorization
            var k = arr[n - 1][n - 1]; // TODO this is apparently a somewhat
            // old-fashioned choice; ideally set close to an eigenvalue, or
            // perhaps better yet switch to the implicit QR version that is sometimes
            // specifically called the "Francis algorithm" that is alluded to
            // in the following TODO. (Or perhaps we switch to an independently
            // optimized third-party package for the linear algebra operations...)
            for(var i = 0; i < n; i++){
                arr[i][i] = subtract(arr[i][i], k);
            }
            // TODO do an implicit QR transformation
            var { Q, R } = qr(arr);
            arr = multiply(R, Q);
            for(var _i = 0; _i < n; _i++){
                arr[_i][_i] = addScalar(arr[_i][_i], k);
            }
            // keep track of transformations
            if (findVectors) {
                Qpartial = multiply(Qpartial, Q);
            }
            // The rightmost diagonal element converged to an eigenvalue
            if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
                lastConvergenceBefore = 0;
                lambdas.push(arr[n - 1][n - 1]);
                // keep track of transformations
                if (findVectors) {
                    Sdiag.unshift([
                        [
                            1
                        ]
                    ]);
                    inflateMatrix(Qpartial, N);
                    Qtotal = multiply(Qtotal, Qpartial);
                    if (n > 1) {
                        Qpartial = diag(Array(n - 1).fill(one));
                    }
                }
                // reduce the matrix size
                n -= 1;
                arr.pop();
                for(var _i2 = 0; _i2 < n; _i2++){
                    arr[_i2].pop();
                }
            // The rightmost diagonal 2x2 block converged
            } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
                lastConvergenceBefore = 0;
                var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
                lambdas.push(...ll);
                // keep track of transformations
                if (findVectors) {
                    Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
                    inflateMatrix(Qpartial, N);
                    Qtotal = multiply(Qtotal, Qpartial);
                    if (n > 2) {
                        Qpartial = diag(Array(n - 2).fill(one));
                    }
                }
                // reduce the matrix size
                n -= 2;
                arr.pop();
                arr.pop();
                for(var _i3 = 0; _i3 < n; _i3++){
                    arr[_i3].pop();
                    arr[_i3].pop();
                }
            }
            if (n === 0) {
                break;
            }
        }
        // standard sorting
        lambdas.sort((a, b)=>+subtract(abs(a), abs(b)));
        // the algorithm didn't converge
        if (lastConvergenceBefore > 100) {
            var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));
            err.values = lambdas;
            err.vectors = [];
            throw err;
        }
        // combine the overall QR transformation Qtotal with the subsequent
        // transformation S that turns the diagonal 2x2 blocks to upper triangular
        var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
        return {
            values: lambdas,
            C
        };
    }
    /**
   * @param {Matrix} A hessenberg-form matrix
   * @param {number} N size of A
   * @param {Matrix} C column transformation matrix that turns A into upper triangular
   * @param {Matrix} R similarity that turns original matrix into A
   * @param {number[]} values array of eigenvalues of A
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {number[][]} eigenvalues
   */ function findEigenvectors(A, N, C, R, values, prec, type) {
        var Cinv = inv(C);
        var U = multiply(Cinv, A, C);
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        // turn values into a kind of "multiset"
        // this way it is easier to find eigenvectors
        var uniqueValues = [];
        var multiplicities = [];
        for (var lambda of values){
            var i = indexOf(uniqueValues, lambda, equal);
            if (i === -1) {
                uniqueValues.push(lambda);
                multiplicities.push(1);
            } else {
                multiplicities[i] += 1;
            }
        }
        // find eigenvectors by solving U − lambdaE = 0
        // TODO replace with an iterative eigenvector algorithm
        // (this one might fail for imprecise eigenvalues)
        var vectors = [];
        var len = uniqueValues.length;
        var b = Array(N).fill(zero);
        var E = diag(Array(N).fill(one));
        var _loop = function _loop() {
            var lambda = uniqueValues[_i4];
            var S = subtract(U, multiply(lambda, E)); // the characteristic matrix
            var solutions = usolveAll(S, b);
            solutions.shift(); // ignore the null vector
            // looks like we missed something, try inverse iteration
            // But if that fails, just presume that the original matrix truly
            // was defective.
            while(solutions.length < multiplicities[_i4]){
                var approxVec = inverseIterate(S, N, solutions, prec, type);
                if (approxVec === null) {
                    break;
                } // no more vectors were found
                solutions.push(approxVec);
            }
            // Transform back into original array coordinates
            var correction = multiply(inv(R), C);
            solutions = solutions.map((v)=>multiply(correction, v));
            vectors.push(...solutions.map((v)=>({
                    value: lambda,
                    vector: flatten(v)
                })));
        };
        for(var _i4 = 0; _i4 < len; _i4++){
            _loop();
        }
        return vectors;
    }
    /**
   * Compute the eigenvalues of an 2x2 matrix
   * @return {[number,number]}
   */ function eigenvalues2x2(a, b, c, d) {
        // lambda_+- = 1/2 trA +- 1/2 sqrt( tr^2 A - 4 detA )
        var trA = addScalar(a, d);
        var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
        var x = multiplyScalar(trA, 0.5);
        var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
        return [
            addScalar(x, y),
            subtract(x, y)
        ];
    }
    /**
   * For an 2x2 matrix compute the transformation matrix S,
   * so that SAS^-1 is an upper triangular matrix
   * @return {[[number,number],[number,number]]}
   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
   */ function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        // matrix is already upper triangular
        // return an identity matrix
        if (smaller(abs(c), prec)) {
            return [
                [
                    one,
                    zero
                ],
                [
                    zero,
                    one
                ]
            ];
        }
        // matrix is diagonalizable
        // return its eigenvectors as columns
        if (larger(abs(subtract(l1, l2)), prec)) {
            return [
                [
                    subtract(l1, d),
                    subtract(l2, d)
                ],
                [
                    c,
                    c
                ]
            ];
        }
        // matrix is not diagonalizable
        // compute diagonal elements of N = A - lambdaI
        var na = subtract(a, l1);
        var nd = subtract(d, l1);
        // col(N,2) = 0  implies  S = ( col(N,1), e_1 )
        // col(N,2) != 0 implies  S = ( col(N,2), e_2 )
        if (smaller(abs(b), prec) && smaller(abs(nd), prec)) {
            return [
                [
                    na,
                    one
                ],
                [
                    c,
                    zero
                ]
            ];
        } else {
            return [
                [
                    b,
                    zero
                ],
                [
                    nd,
                    one
                ]
            ];
        }
    }
    /**
   * Enlarge the matrix from nxn to NxN, setting the new
   * elements to 1 on diagonal and 0 elsewhere
   */ function inflateMatrix(arr, N) {
        // add columns
        for(var i = 0; i < arr.length; i++){
            arr[i].push(...Array(N - arr[i].length).fill(0));
        }
        // add rows
        for(var _i5 = arr.length; _i5 < N; _i5++){
            arr.push(Array(N).fill(0));
            arr[_i5][_i5] = 1;
        }
        return arr;
    }
    /**
   * Create a block-diagonal matrix with the given square matrices on the diagonal
   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
   * @param {number} N the size of the resulting matrix
   */ function blockDiag(arr, N) {
        var M = [];
        for(var i = 0; i < N; i++){
            M[i] = Array(N).fill(0);
        }
        var I = 0;
        for (var sub of arr){
            var n = sub.length;
            for(var _i6 = 0; _i6 < n; _i6++){
                for(var j = 0; j < n; j++){
                    M[I + _i6][I + j] = sub[_i6][j];
                }
            }
            I += n;
        }
        return M;
    }
    /**
   * Finds the index of an element in an array using a custom equality function
   * @template T
   * @param {Array<T>} arr array in which to search
   * @param {T} el the element to find
   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
   * @returns {number} the index of `el`, or -1 when it's not in `arr`
   */ function indexOf(arr, el, fn) {
        for(var i = 0; i < arr.length; i++){
            if (fn(arr[i], el)) {
                return i;
            }
        }
        return -1;
    }
    /**
   * Provided a near-singular upper-triangular matrix A and a list of vectors,
   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
   * to each vector in the list
   * @template T
   * @param {T[][]} A near-singular square matrix
   * @param {number} N dimension
   * @param {T[][]} orthog list of vectors
   * @param {number} prec epsilon
   * @param {'number'|'BigNumber'|'Complex'} type
   * @return {T[] | null} eigenvector
   *
   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration
   */ function inverseIterate(A, N, orthog, prec, type) {
        var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;
        var b; // the vector
        // you better choose a random vector before I count to five
        var i = 0;
        for(; i < 5; ++i){
            b = randomOrthogonalVector(N, orthog, type);
            try {
                b = usolve(A, b);
            } catch (_unused) {
                continue;
            }
            if (larger(norm(b), largeNum)) {
                break;
            }
        }
        if (i >= 5) {
            return null; // couldn't find any orthogonal vector in the image
        }
        // you better converge before I count to ten
        i = 0;
        while(true){
            var c = usolve(A, b);
            if (smaller(norm(orthogonalComplement(b, [
                c
            ])), prec)) {
                break;
            }
            if (++i >= 10) {
                return null;
            }
            b = normalize(c);
        }
        return b;
    }
    /**
   * Generates a random unit vector of dimension N, orthogonal to each vector in the list
   * @template T
   * @param {number} N dimension
   * @param {T[][]} orthog list of vectors
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {T[]} random vector
   */ function randomOrthogonalVector(N, orthog, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        // generate random vector with the correct type
        var v = Array(N).fill(0).map((_)=>2 * Math.random() - 1);
        if (big) {
            v = v.map((n)=>bignumber(n));
        }
        if (cplx) {
            v = v.map((n)=>complex(n));
        }
        // project to orthogonal complement
        v = orthogonalComplement(v, orthog);
        // normalize
        return normalize(v, type);
    }
    /**
   * Project vector v to the orthogonal complement of an array of vectors
   */ function orthogonalComplement(v, orthog) {
        var vectorShape = size(v);
        for (var w of orthog){
            w = reshape(w, vectorShape); // make sure this is just a vector computation
            // v := v − (w, v)/|w|^2 w
            v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
        }
        return v;
    }
    /**
   * Calculate the norm of a vector.
   * We can't use math.norm because factory can't handle circular dependency.
   * Seriously, I'm really fed up with factory.
   */ function norm(v) {
        return abs(sqrt(dot(v, v)));
    }
    /**
   * Normalize a vector
   * @template T
   * @param {T[]} v
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {T[]} normalized vec
   */ function normalize(v, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        return multiply(divideScalar(one, norm(v)), v);
    }
    return complexEigs;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRealSymmetric": (()=>createRealSymmetric)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-ssr] (ecmascript)");
;
function createRealSymmetric(_ref) {
    var { config, addScalar, subtract, abs, atan, cos, sin, multiplyScalar, inv, bignumber, multiply, add } = _ref;
    /**
   * @param {number[] | BigNumber[]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number' | 'BigNumber'} type
   */ function main(arr, N) {
        var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.relTol;
        var type = arguments.length > 3 ? arguments[3] : undefined;
        var computeVectors = arguments.length > 4 ? arguments[4] : undefined;
        if (type === 'number') {
            return diag(arr, prec, computeVectors);
        }
        if (type === 'BigNumber') {
            return diagBig(arr, prec, computeVectors);
        }
        throw TypeError('Unsupported data type: ' + type);
    }
    // diagonalization implementation for number (efficient)
    function diag(x, precision, computeVectors) {
        var N = x.length;
        var e0 = Math.abs(precision / N);
        var psi;
        var Sij;
        if (computeVectors) {
            Sij = new Array(N);
            // Sij is Identity Matrix
            for(var i = 0; i < N; i++){
                Sij[i] = Array(N).fill(0);
                Sij[i][i] = 1.0;
            }
        }
        // initial error
        var Vab = getAij(x);
        while(Math.abs(Vab[1]) >= Math.abs(e0)){
            var _i = Vab[0][0];
            var j = Vab[0][1];
            psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
            x = x1(x, psi, _i, j);
            if (computeVectors) Sij = Sij1(Sij, psi, _i, j);
            Vab = getAij(x);
        }
        var Ei = Array(N).fill(0); // eigenvalues
        for(var _i2 = 0; _i2 < N; _i2++){
            Ei[_i2] = x[_i2][_i2];
        }
        return sorting((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(Ei), Sij, computeVectors);
    }
    // diagonalization implementation for bigNumber
    function diagBig(x, precision, computeVectors) {
        var N = x.length;
        var e0 = abs(precision / N);
        var psi;
        var Sij;
        if (computeVectors) {
            Sij = new Array(N);
            // Sij is Identity Matrix
            for(var i = 0; i < N; i++){
                Sij[i] = Array(N).fill(0);
                Sij[i][i] = 1.0;
            }
        }
        // initial error
        var Vab = getAijBig(x);
        while(abs(Vab[1]) >= abs(e0)){
            var _i3 = Vab[0][0];
            var j = Vab[0][1];
            psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
            x = x1Big(x, psi, _i3, j);
            if (computeVectors) Sij = Sij1Big(Sij, psi, _i3, j);
            Vab = getAijBig(x);
        }
        var Ei = Array(N).fill(0); // eigenvalues
        for(var _i4 = 0; _i4 < N; _i4++){
            Ei[_i4] = x[_i4][_i4];
        }
        // return [clone(Ei), clone(Sij)]
        return sorting((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(Ei), Sij, computeVectors);
    }
    // get angle
    function getTheta(aii, ajj, aij) {
        var denom = ajj - aii;
        if (Math.abs(denom) <= config.relTol) {
            return Math.PI / 4.0;
        } else {
            return 0.5 * Math.atan(2.0 * aij / (ajj - aii));
        }
    }
    // get angle
    function getThetaBig(aii, ajj, aij) {
        var denom = subtract(ajj, aii);
        if (abs(denom) <= config.relTol) {
            return bignumber(-1).acos().div(4);
        } else {
            return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));
        }
    }
    // update eigvec
    function Sij1(Sij, theta, i, j) {
        var N = Sij.length;
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var Ski = Array(N).fill(0);
        var Skj = Array(N).fill(0);
        for(var k = 0; k < N; k++){
            Ski[k] = c * Sij[k][i] - s * Sij[k][j];
            Skj[k] = s * Sij[k][i] + c * Sij[k][j];
        }
        for(var _k = 0; _k < N; _k++){
            Sij[_k][i] = Ski[_k];
            Sij[_k][j] = Skj[_k];
        }
        return Sij;
    }
    // update eigvec for overlap
    function Sij1Big(Sij, theta, i, j) {
        var N = Sij.length;
        var c = cos(theta);
        var s = sin(theta);
        var Ski = Array(N).fill(bignumber(0));
        var Skj = Array(N).fill(bignumber(0));
        for(var k = 0; k < N; k++){
            Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
            Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
        }
        for(var _k2 = 0; _k2 < N; _k2++){
            Sij[_k2][i] = Ski[_k2];
            Sij[_k2][j] = Skj[_k2];
        }
        return Sij;
    }
    // update matrix
    function x1Big(Hij, theta, i, j) {
        var N = Hij.length;
        var c = bignumber(cos(theta));
        var s = bignumber(sin(theta));
        var c2 = multiplyScalar(c, c);
        var s2 = multiplyScalar(s, s);
        var Aki = Array(N).fill(bignumber(0));
        var Akj = Array(N).fill(bignumber(0));
        // 2cs Hij
        var csHij = multiply(bignumber(2), c, s, Hij[i][j]);
        //  Aii
        var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
        var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));
        // 0  to i
        for(var k = 0; k < N; k++){
            Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
            Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
        }
        // Modify Hij
        Hij[i][i] = Aii;
        Hij[j][j] = Ajj;
        Hij[i][j] = bignumber(0);
        Hij[j][i] = bignumber(0);
        // 0  to i
        for(var _k3 = 0; _k3 < N; _k3++){
            if (_k3 !== i && _k3 !== j) {
                Hij[i][_k3] = Aki[_k3];
                Hij[_k3][i] = Aki[_k3];
                Hij[j][_k3] = Akj[_k3];
                Hij[_k3][j] = Akj[_k3];
            }
        }
        return Hij;
    }
    // update matrix
    function x1(Hij, theta, i, j) {
        var N = Hij.length;
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var c2 = c * c;
        var s2 = s * s;
        var Aki = Array(N).fill(0);
        var Akj = Array(N).fill(0);
        //  Aii
        var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
        var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
        // 0  to i
        for(var k = 0; k < N; k++){
            Aki[k] = c * Hij[i][k] - s * Hij[j][k];
            Akj[k] = s * Hij[i][k] + c * Hij[j][k];
        }
        // Modify Hij
        Hij[i][i] = Aii;
        Hij[j][j] = Ajj;
        Hij[i][j] = 0;
        Hij[j][i] = 0;
        // 0  to i
        for(var _k4 = 0; _k4 < N; _k4++){
            if (_k4 !== i && _k4 !== j) {
                Hij[i][_k4] = Aki[_k4];
                Hij[_k4][i] = Aki[_k4];
                Hij[j][_k4] = Akj[_k4];
                Hij[_k4][j] = Akj[_k4];
            }
        }
        return Hij;
    }
    // get max off-diagonal value from Upper Diagonal
    function getAij(Mij) {
        var N = Mij.length;
        var maxMij = 0;
        var maxIJ = [
            0,
            1
        ];
        for(var i = 0; i < N; i++){
            for(var j = i + 1; j < N; j++){
                if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
                    maxMij = Math.abs(Mij[i][j]);
                    maxIJ = [
                        i,
                        j
                    ];
                }
            }
        }
        return [
            maxIJ,
            maxMij
        ];
    }
    // get max off-diagonal value from Upper Diagonal
    function getAijBig(Mij) {
        var N = Mij.length;
        var maxMij = 0;
        var maxIJ = [
            0,
            1
        ];
        for(var i = 0; i < N; i++){
            for(var j = i + 1; j < N; j++){
                if (abs(maxMij) < abs(Mij[i][j])) {
                    maxMij = abs(Mij[i][j]);
                    maxIJ = [
                        i,
                        j
                    ];
                }
            }
        }
        return [
            maxIJ,
            maxMij
        ];
    }
    // sort results
    function sorting(E, S, computeVectors) {
        var N = E.length;
        var values = Array(N);
        var vecs;
        if (computeVectors) {
            vecs = Array(N);
            for(var k = 0; k < N; k++){
                vecs[k] = Array(N);
            }
        }
        for(var i = 0; i < N; i++){
            var minID = 0;
            var minE = E[0];
            for(var j = 0; j < E.length; j++){
                if (abs(E[j]) < abs(minE)) {
                    minID = j;
                    minE = E[minID];
                }
            }
            values[i] = E.splice(minID, 1)[0];
            if (computeVectors) {
                for(var _k5 = 0; _k5 < N; _k5++){
                    vecs[i][_k5] = S[_k5][minID];
                    S[_k5].splice(minID, 1);
                }
            }
        }
        if (!computeVectors) return {
            values
        };
        var eigenvectors = vecs.map((vector, i)=>({
                value: values[i],
                vector
            }));
        return {
            values,
            eigenvectors
        };
    }
    return main;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/eigs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEigs": (()=>createEigs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/extends.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$matrix$2f$eigs$2f$complexEigs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$matrix$2f$eigs$2f$realSymmetric$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var name = 'eigs';
// The absolute state of math.js's dependency system:
var dependencies = [
    'config',
    'typed',
    'matrix',
    'addScalar',
    'equal',
    'subtract',
    'abs',
    'atan',
    'cos',
    'sin',
    'multiplyScalar',
    'divideScalar',
    'inv',
    'bignumber',
    'multiply',
    'add',
    'larger',
    'column',
    'flatten',
    'number',
    'complex',
    'sqrt',
    'diag',
    'size',
    'reshape',
    'qr',
    'usolve',
    'usolveAll',
    'im',
    're',
    'smaller',
    'matrixFromColumns',
    'dot'
];
var createEigs = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, matrix, addScalar, subtract, equal, abs, atan, cos, sin, multiplyScalar, divideScalar, inv, bignumber, multiply, add, larger, column, flatten, number, complex, sqrt, diag, size, reshape, qr, usolve, usolveAll, im, re, smaller, matrixFromColumns, dot } = _ref;
    var doRealSymmetric = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$matrix$2f$eigs$2f$realSymmetric$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRealSymmetric"])({
        config,
        addScalar,
        subtract,
        column,
        flatten,
        equal,
        abs,
        atan,
        cos,
        sin,
        multiplyScalar,
        inv,
        bignumber,
        complex,
        multiply,
        add
    });
    var doComplexEigs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$matrix$2f$eigs$2f$complexEigs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createComplexEigs"])({
        config,
        addScalar,
        subtract,
        multiply,
        multiplyScalar,
        flatten,
        divideScalar,
        sqrt,
        abs,
        bignumber,
        diag,
        size,
        reshape,
        qr,
        inv,
        usolve,
        usolveAll,
        equal,
        complex,
        larger,
        smaller,
        matrixFromColumns,
        dot
    });
    /**
   * Compute eigenvalues and optionally eigenvectors of a square matrix.
   * The eigenvalues are sorted by their absolute value, ascending, and
   * returned as a vector in the `values` property of the returned project.
   * An eigenvalue with algebraic multiplicity k will be listed k times, so
   * that the returned `values` vector always has length equal to the size
   * of the input matrix.
   *
   * The `eigenvectors` property of the return value provides the eigenvectors.
   * It is an array of plain objects: the `value` property of each gives the
   * associated eigenvalue, and the `vector` property gives the eigenvector
   * itself. Note that the same `value` property will occur as many times in
   * the list provided by `eigenvectors` as the geometric multiplicity of
   * that value.
   *
   * If the algorithm fails to converge, it will throw an error –
   * in that case, however, you may still find useful information
   * in `err.values` and `err.vectors`.
   *
   * Note that the 'precision' option does not directly specify the _accuracy_
   * of the returned eigenvalues. Rather, it determines how small an entry
   * of the iterative approximations to an upper triangular matrix must be
   * in order to be considered zero. The actual accuracy of the returned
   * eigenvalues may be greater or less than the precision, depending on the
   * conditioning of the matrix and how far apart or close the actual
   * eigenvalues are. Note that currently, relatively simple, "traditional"
   * methods of eigenvalue computation are being used; this is not a modern,
   * high-precision eigenvalue computation. That said, it should typically
   * produce fairly reasonable results.
   *
   * Syntax:
   *
   *     math.eigs(x, [prec])
   *     math.eigs(x, {options})
   *
   * Examples:
   *
   *     const { eigs, multiply, column, transpose, matrixFromColumns } = math
   *     const H = [[5, 2.3], [2.3, 1]]
   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], eigenvectors: [{value: E1, vector: v2}, {value: e, vector: v2}, ...]
   *     const E = ans.values
   *     const V = ans.eigenvectors
   *     multiply(H, V[0].vector)) // returns multiply(E[0], V[0].vector))
   *     const U = matrixFromColumns(...V.map(obj => obj.vector))
   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H if possible
   *     E[0] == UTxHxU[0][0]  // returns true always
   *
   *     // Compute only approximate eigenvalues:
   *     const {values} = eigs(H, {eigenvectors: false, precision: 1e-6})
   *
   * See also:
   *
   *     inv
   *
   * @param {Array | Matrix} x  Matrix to be diagonalized
   *
   * @param {number | BigNumber | OptsObject} [opts] Object with keys `precision`, defaulting to config.relTol, and `eigenvectors`, defaulting to true and specifying whether to compute eigenvectors. If just a number, specifies precision.
   * @return {{values: Array|Matrix, eigenvectors?: Array<EVobj>}} Object containing an array of eigenvalues and an array of {value: number|BigNumber, vector: Array|Matrix} objects. The eigenvectors property is undefined if eigenvectors were not requested.
   *
   */ return typed('eigs', {
        // The conversion to matrix in the first two implementations,
        // just to convert back to an array right away in
        // computeValuesAndVectors, is unfortunate, and should perhaps be
        // streamlined. It is done because the Matrix object carries some
        // type information about its entries, and so constructing the matrix
        // is a roundabout way of doing type detection.
        Array: function Array(x) {
            return doEigs(matrix(x));
        },
        'Array, number|BigNumber': function Array_numberBigNumber(x, prec) {
            return doEigs(matrix(x), {
                precision: prec
            });
        },
        'Array, Object' (x, opts) {
            return doEigs(matrix(x), opts);
        },
        Matrix: function Matrix(mat) {
            return doEigs(mat, {
                matricize: true
            });
        },
        'Matrix, number|BigNumber': function Matrix_numberBigNumber(mat, prec) {
            return doEigs(mat, {
                precision: prec,
                matricize: true
            });
        },
        'Matrix, Object': function Matrix_Object(mat, opts) {
            var useOpts = {
                matricize: true
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$extends$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(useOpts, opts);
            return doEigs(mat, useOpts);
        }
    });
    "TURBOPACK unreachable";
    function doEigs(mat) {
        var _opts$precision;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var computeVectors = 'eigenvectors' in opts ? opts.eigenvectors : true;
        var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config.relTol;
        var result = computeValuesAndVectors(mat, prec, computeVectors);
        if (opts.matricize) {
            result.values = matrix(result.values);
            if (computeVectors) {
                result.eigenvectors = result.eigenvectors.map((_ref2)=>{
                    var { value, vector } = _ref2;
                    return {
                        value,
                        vector: matrix(vector)
                    };
                });
            }
        }
        if (computeVectors) {
            Object.defineProperty(result, 'vectors', {
                enumerable: false,
                // to make sure that the eigenvectors can still be
                // converted to string.
                get: ()=>{
                    throw new Error('eigs(M).vectors replaced with eigs(M).eigenvectors');
                }
            });
        }
        return result;
    }
    function computeValuesAndVectors(mat, prec, computeVectors) {
        var arr = mat.toArray(); // NOTE: arr is guaranteed to be unaliased
        // and so safe to modify in place
        var asize = mat.size();
        if (asize.length !== 2 || asize[0] !== asize[1]) {
            throw new RangeError("Matrix must be square (size: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(asize), ")"));
        }
        var N = asize[0];
        if (isReal(arr, N, prec)) {
            coerceReal(arr, N); // modifies arr by side effect
            if (isSymmetric(arr, N, prec)) {
                var _type = coerceTypes(mat, arr, N); // modifies arr by side effect
                return doRealSymmetric(arr, N, prec, _type, computeVectors);
            }
        }
        var type = coerceTypes(mat, arr, N); // modifies arr by side effect
        return doComplexEigs(arr, N, prec, type, computeVectors);
    }
    /** @return {boolean} */ function isSymmetric(arr, N, prec) {
        for(var i = 0; i < N; i++){
            for(var j = i; j < N; j++){
                // TODO proper comparison of bignum and frac
                if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
                    return false;
                }
            }
        }
        return true;
    }
    /** @return {boolean} */ function isReal(arr, N, prec) {
        for(var i = 0; i < N; i++){
            for(var j = 0; j < N; j++){
                // TODO proper comparison of bignum and frac
                if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
                    return false;
                }
            }
        }
        return true;
    }
    function coerceReal(arr, N) {
        for(var i = 0; i < N; i++){
            for(var j = 0; j < N; j++){
                arr[i][j] = re(arr[i][j]);
            }
        }
    }
    /** @return {'number' | 'BigNumber' | 'Complex'} */ function coerceTypes(mat, arr, N) {
        /** @type {string} */ var type = mat.datatype();
        if (type === 'number' || type === 'BigNumber' || type === 'Complex') {
            return type;
        }
        var hasNumber = false;
        var hasBig = false;
        var hasComplex = false;
        for(var i = 0; i < N; i++){
            for(var j = 0; j < N; j++){
                var el = arr[i][j];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFraction"])(el)) {
                    hasNumber = true;
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(el)) {
                    hasBig = true;
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isComplex"])(el)) {
                    hasComplex = true;
                } else {
                    throw TypeError('Unsupported type in Matrix: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeOf"])(el));
                }
            }
        }
        if (hasBig && hasComplex) {
            console.warn('Complex BigNumbers not supported, this operation will lose precission.');
        }
        if (hasComplex) {
            for(var _i = 0; _i < N; _i++){
                for(var _j = 0; _j < N; _j++){
                    arr[_i][_j] = complex(arr[_i][_j]);
                }
            }
            return 'Complex';
        }
        if (hasBig) {
            for(var _i2 = 0; _i2 < N; _i2++){
                for(var _j2 = 0; _j2 < N; _j2++){
                    arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
                }
            }
            return 'BigNumber';
        }
        if (hasNumber) {
            for(var _i3 = 0; _i3 < N; _i3++){
                for(var _j3 = 0; _j3 < N; _j3++){
                    arr[_i3][_j3] = number(arr[_i3][_j3]);
                }
            }
            return 'number';
        } else {
            throw TypeError('Matrix contains unsupported types only.');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/probability/kldivergence.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createKldivergence": (()=>createKldivergence)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'kldivergence';
var dependencies = [
    'typed',
    'matrix',
    'divide',
    'sum',
    'multiply',
    'map',
    'dotDivide',
    'log',
    'isNumeric'
];
var createKldivergence = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divide, sum, multiply, map, dotDivide, log, isNumeric } = _ref;
    /**
     * Calculate the Kullback-Leibler (KL) divergence  between two distributions
     *
     * Syntax:
     *
     *     math.kldivergence(x, y)
     *
     * Examples:
     *
     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153
     *
     *
     * @param  {Array | Matrix} q    First vector
     * @param  {Array | Matrix} p    Second vector
     * @return {number}              Returns distance between q and p
     */ return typed(name, {
        'Array, Array': function Array_Array(q, p) {
            return _kldiv(matrix(q), matrix(p));
        },
        'Matrix, Array': function Matrix_Array(q, p) {
            return _kldiv(q, matrix(p));
        },
        'Array, Matrix': function Array_Matrix(q, p) {
            return _kldiv(matrix(q), p);
        },
        'Matrix, Matrix': function Matrix_Matrix(q, p) {
            return _kldiv(q, p);
        }
    });
    "TURBOPACK unreachable";
    function _kldiv(q, p) {
        var plength = p.size().length;
        var qlength = q.size().length;
        if (plength > 1) {
            throw new Error('first object must be one dimensional');
        }
        if (qlength > 1) {
            throw new Error('second object must be one dimensional');
        }
        if (plength !== qlength) {
            throw new Error('Length of two vectors must be equal');
        }
        // Before calculation, apply normalization
        var sumq = sum(q);
        if (sumq === 0) {
            throw new Error('Sum of elements in first object must be non zero');
        }
        var sump = sum(p);
        if (sump === 0) {
            throw new Error('Sum of elements in second object must be non zero');
        }
        var qnorm = divide(q, sum(q));
        var pnorm = divide(p, sum(p));
        var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), (x)=>log(x))));
        if (isNumeric(result)) {
            return result;
        } else {
            return Number.NaN;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
 *
 * @param {Array} p           The permutation vector of length n. null value denotes identity
 * @param {Array} b           The input vector
 *
 * @return {Array}            The output vector x = P'b
 */ __turbopack_context__.s({
    "csIpvec": (()=>csIpvec)
});
function csIpvec(p, b) {
    // vars
    var k;
    var n = b.length;
    var x = [];
    // check permutation vector was provided, p = null denotes identity
    if (p) {
        // loop vector
        for(k = 0; k < n; k++){
            // apply permutation
            x[p[k]] = b[k];
        }
    } else {
        // loop vector
        for(k = 0; k < n; k++){
            // x[i] = b[i]
            x[k] = b[k];
        }
    }
    return x;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLusolve": (()=>createLusolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'lusolve';
var dependencies = [
    'typed',
    'matrix',
    'lup',
    'slu',
    'usolve',
    'lsolve',
    'DenseMatrix'
];
var createLusolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, lup, slu, usolve, lsolve, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
   *
   * Syntax:
   *
   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
   *
   * Examples:
   *
   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
   *
   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]
   *
   *    const f = math.lup(m)
   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = math.lusolve(a, b)  // [[2], [5]]
   *
   * See also:
   *
   *    lup, slu, lsolve, usolve
   *
   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
   * @param {Matrix | Array} b               Column Vector
   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
   *
   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
   */ return typed(name, {
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            a = matrix(a);
            var d = lup(a);
            var x = _lusolve(d.L, d.U, d.p, null, b);
            return x.valueOf();
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
        },
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
        },
        'SparseMatrix, Array | Matrix, number, number': function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {
            var d = slu(a, order, threshold);
            return _lusolve(d.L, d.U, d.p, d.q, b);
        },
        'Object, Array | Matrix': function Object_Array__Matrix(d, b) {
            return _lusolve(d.L, d.U, d.p, d.q, b);
        }
    });
    "TURBOPACK unreachable";
    function _toMatrix(a) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMatrix"])(a)) {
            return a;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isArray"])(a)) {
            return matrix(a);
        }
        throw new TypeError('Invalid Matrix LU decomposition');
    }
    function _lusolve(l, u, p, q, b) {
        // verify decomposition
        l = _toMatrix(l);
        u = _toMatrix(u);
        // apply row permutations if needed (b is a DenseMatrix)
        if (p) {
            b = solveValidation(l, b, true);
            b._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csIpvec"])(p, b._data);
        }
        // use forward substitution to resolve L * y = b
        var y = lsolve(l, b);
        // use backward substitution to resolve U * x = y
        var x = usolve(u, y);
        // apply column permutations if needed (x is a DenseMatrix)
        if (q) {
            x._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["csIpvec"])(q, x._data);
        }
        return x;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/mean.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMean": (()=>createMean)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'mean';
var dependencies = [
    'typed',
    'add',
    'divide'
];
var createMean = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, divide } = _ref;
    /**
   * Compute the mean value of matrix or a list with values.
   * In case of a multidimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.mean(a, b, c, ...)
   *     math.mean(A)
   *     math.mean(A, dimension)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3)                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4])               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0)    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1)    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */ return typed(name, {
        // mean([a, b, c, d, ...])
        'Array | Matrix': _mean,
        // mean([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': _nmeanDim,
        // mean(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('Scalar values expected in function mean');
            }
            return _mean(args);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {number} dim
   * @return {number} mean
   * @private
   */ function _nmeanDim(array, dim) {
        try {
            var sum = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reduce"])(array, dim, add);
            var s = Array.isArray(array) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(array) : array.size();
            return divide(sum, s[dim]);
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'mean');
        }
    }
    /**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {number} mean
   * @private
   */ function _mean(array) {
        var sum;
        var num = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                sum = sum === undefined ? value : add(sum, value);
                num++;
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'mean', value);
            }
        });
        if (num === 0) {
            throw new Error('Cannot calculate the mean of an empty array');
        }
        return divide(sum, num);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createQuantileSeq": (()=>createQuantileSeq)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
;
var name = 'quantileSeq';
var dependencies = [
    'typed',
    '?bignumber',
    'add',
    'subtract',
    'divide',
    'multiply',
    'partitionSelect',
    'compare',
    'isInteger',
    'smaller',
    'smallerEq',
    'larger',
    'mapSlices'
];
var createQuantileSeq = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, bignumber, add, subtract, divide, multiply, partitionSelect, compare, isInteger, smaller, smallerEq, larger, mapSlices } = _ref;
    /**
   * Compute the prob order quantile of a matrix or a list with values.
   * The sequence is sorted and the middle value is returned.
   * Supported types of sequence values are: Number, BigNumber, Unit
   * Supported types of probability are: Number, BigNumber
   *
   * In case of a multidimensional array or matrix, the prob order quantile
   * of all elements will be calculated.
   *
   * Syntax:
   *
   *     math.quantileSeq(A, prob[, sorted])
   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
   *     math.quantileSeq(A, N[, sorted])
   *
   * Examples:
   *
   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4
   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]
   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]
   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, variance
   *
   * @param {Array, Matrix} data                A single matrix or Array
   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
   *                                            the amount of evenly distributed steps of
   *                                            probabilities; only one of these options can
   *                                            be provided
   * @param {Boolean} sorted=false              is data sorted in ascending order
   * @return {Number, BigNumber, Unit, Array}   Quantile(s)
   */ return typed(name, {
        'Array | Matrix, number | BigNumber': (data, p)=>_quantileSeqProbNumber(data, p, false),
        'Array | Matrix, number | BigNumber, number': (data, prob, dim)=>_quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
        'Array | Matrix, number | BigNumber, boolean': _quantileSeqProbNumber,
        'Array | Matrix, number | BigNumber, boolean, number': (data, prob, sorted, dim)=>_quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
        'Array | Matrix, Array | Matrix': (data, p)=>_quantileSeqProbCollection(data, p, false),
        'Array | Matrix, Array | Matrix, number': (data, prob, dim)=>_quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
        'Array | Matrix, Array | Matrix, boolean': _quantileSeqProbCollection,
        'Array | Matrix, Array | Matrix, boolean, number': (data, prob, sorted, dim)=>_quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
    });
    "TURBOPACK unreachable";
    function _quantileSeqDim(data, prob, sorted, dim, fn) {
        return mapSlices(data, dim, (x)=>fn(x, prob, sorted));
    }
    function _quantileSeqProbNumber(data, probOrN, sorted) {
        var probArr;
        var dataArr = data.valueOf();
        if (smaller(probOrN, 0)) {
            throw new Error('N/prob must be non-negative');
        }
        if (smallerEq(probOrN, 1)) {
            // quantileSeq([a, b, c, d, ...], prob[,sorted])
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));
        }
        if (larger(probOrN, 1)) {
            // quantileSeq([a, b, c, d, ...], N[,sorted])
            if (!isInteger(probOrN)) {
                throw new Error('N must be a positive integer');
            }
            // largest possible Array length is 2^32-1
            // 2^32 < 10^15, thus safe conversion guaranteed
            if (larger(probOrN, 4294967295)) {
                throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
            }
            var nPlusOne = add(probOrN, 1);
            probArr = [];
            for(var i = 0; smaller(i, probOrN); i++){
                var prob = divide(i + 1, nPlusOne);
                probArr.push(_quantileSeq(dataArr, prob, sorted));
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(probOrN) ? probArr : bignumber(probArr);
        }
    }
    /**
   * Calculate the prob order quantile of an n-dimensional array.
   *
   * @param {Array, Matrix} array
   * @param {Array, Matrix} prob
   * @param {Boolean} sorted
   * @return {Number, BigNumber, Unit} prob order quantile
   * @private
   */ function _quantileSeqProbCollection(data, probOrN, sorted) {
        var dataArr = data.valueOf();
        // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
        var probOrNArr = probOrN.valueOf();
        var probArr = [];
        for(var i = 0; i < probOrNArr.length; ++i){
            probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));
        }
        return probArr;
    }
    /**
   * Calculate the prob order quantile of an n-dimensional array.
   *
   * @param {Array} array
   * @param {Number, BigNumber} prob
   * @param {Boolean} sorted
   * @return {Number, BigNumber, Unit} prob order quantile
   * @private
   */ function _quantileSeq(array, prob, sorted) {
        var flat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(array);
        var len = flat.length;
        if (len === 0) {
            throw new Error('Cannot calculate quantile of an empty sequence');
        }
        var index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(prob) ? prob * (len - 1) : prob.times(len - 1);
        var integerPart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(prob) ? Math.floor(index) : index.floor().toNumber();
        var fracPart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(prob) ? index % 1 : index.minus(integerPart);
        if (isInteger(index)) {
            return sorted ? flat[index] : partitionSelect(flat, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(prob) ? index : index.valueOf());
        }
        var left;
        var right;
        if (sorted) {
            left = flat[integerPart];
            right = flat[integerPart + 1];
        } else {
            right = partitionSelect(flat, integerPart + 1);
            // max of partition is kth largest
            left = flat[integerPart];
            for(var i = 0; i < integerPart; ++i){
                if (compare(flat[i], left) > 0) {
                    left = flat[i];
                }
            }
        }
        // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
        return add(multiply(left, subtract(1, fracPart)), multiply(right, fracPart));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/set/setUnion.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSetUnion": (()=>createSetUnion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'setUnion';
var dependencies = [
    'typed',
    'size',
    'concat',
    'subset',
    'setIntersect',
    'setSymDifference',
    'Index'
];
var createSetUnion = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, size, concat, subset, setIntersect, setSymDifference, Index } = _ref;
    /**
   * Create the union of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setUnion(set1, set2)
   *
   * Examples:
   *
   *    math.setUnion([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 3, 4, 5, 6]
   *    math.setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 3, 4, 5, 6]
   *
   * See also:
   *
   *    setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The union of two (multi)sets
   */ return typed(name, {
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(a1, a2) {
            if (subset(size(a1), new Index(0)) === 0) {
                // if any of them is empty, return the other one
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a2);
            } else if (subset(size(a2), new Index(0)) === 0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a1);
            }
            var b1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a1);
            var b2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(a2);
            return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/variance.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createVariance": (()=>createVariance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var DEFAULT_NORMALIZATION = 'unbiased';
var name = 'variance';
var dependencies = [
    'typed',
    'add',
    'subtract',
    'multiply',
    'divide',
    'mapSlices',
    'isNaN'
];
var createVariance = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, subtract, multiply, divide, mapSlices, isNaN: mathIsNaN } = _ref;
    /**
   * Compute the variance of a matrix or a  list with values.
   * In case of a multidimensional array or matrix, the variance over all
   * elements will be calculated.
   *
   * Additionally, it is possible to compute the variance along the rows
   * or columns of a matrix by specifying the dimension as the second argument.
   *
   * Optionally, the type of normalization can be specified as the final
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   *
   * Note that older browser may not like the variable name `var`. In that
   * case, the function can be called as `math['var'](...)` instead of
   * `math.var(...)`.
   *
   * Syntax:
   *
   *     math.variance(a, b, c, ...)
   *     math.variance(A)
   *     math.variance(A, normalization)
   *     math.variance(A, dimension)
   *     math.variance(A, dimension, normalization)
   *
   * Examples:
   *
   *     math.variance(2, 4, 6)                     // returns 4
   *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667
   *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5
   *     math.variance([2, 4, 6, 8], 'biased')      // returns 4
   *
   *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5
   *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]
   *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]
   *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]
   *
   * See also:
   *
   *    mean, median, max, min, prod, std, sum
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @param dimension {number | BigNumber}
   *                        Determines the axis to compute the variance for a matrix
   * @return {*} The variance
   */ return typed(name, {
        // variance([a, b, c, d, ...])
        'Array | Matrix': function Array__Matrix(array) {
            return _var(array, DEFAULT_NORMALIZATION);
        },
        // variance([a, b, c, d, ...], normalization)
        'Array | Matrix, string': _var,
        // variance([a, b, c, c, ...], dim)
        'Array | Matrix, number | BigNumber': function Array__Matrix_number__BigNumber(array, dim) {
            return _varDim(array, dim, DEFAULT_NORMALIZATION);
        },
        // variance([a, b, c, c, ...], dim, normalization)
        'Array | Matrix, number | BigNumber, string': _varDim,
        // variance(a, b, c, d, ...)
        '...': function _(args) {
            return _var(args, DEFAULT_NORMALIZATION);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Recursively calculate the variance of an n-dimensional array
   * @param {Array} array
   * @param {string} normalization
   *                        Determines how to normalize the variance:
   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
   *                        - 'uncorrected' The sum of squared errors is divided by n
   *                        - 'biased'      The sum of squared errors is divided by (n + 1)
   * @return {number | BigNumber} variance
   * @private
   */ function _var(array, normalization) {
        var sum;
        var num = 0;
        if (array.length === 0) {
            throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
        }
        // calculate the mean and number of elements
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            try {
                sum = sum === undefined ? value : add(sum, value);
                num++;
            } catch (err) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'variance', value);
            }
        });
        if (num === 0) throw new Error('Cannot calculate variance of an empty array');
        var mean = divide(sum, num);
        // calculate the variance
        sum = undefined;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepForEach"])(array, function(value) {
            var diff = subtract(value, mean);
            sum = sum === undefined ? multiply(diff, diff) : add(sum, multiply(diff, diff));
        });
        if (mathIsNaN(sum)) {
            return sum;
        }
        switch(normalization){
            case 'uncorrected':
                return divide(sum, num);
            case 'biased':
                return divide(sum, num + 1);
            case 'unbiased':
                {
                    var zero = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(sum) ? sum.mul(0) : 0;
                    return num === 1 ? zero : divide(sum, num - 1);
                }
            default:
                throw new Error('Unknown normalization "' + normalization + '". ' + 'Choose "unbiased" (default), "uncorrected", or "biased".');
        }
    }
    function _varDim(array, dim, normalization) {
        try {
            if (array.length === 0) {
                throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
            }
            return mapSlices(array, dim, (x)=>_var(x, normalization));
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'variance');
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/median.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMedian": (()=>createMedian)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
;
var name = 'median';
var dependencies = [
    'typed',
    'add',
    'divide',
    'compare',
    'partitionSelect'
];
var createMedian = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, divide, compare, partitionSelect } = _ref;
    /**
   * Recursively calculate the median of an n-dimensional array
   * @param {Array} array
   * @return {Number} median
   * @private
   */ function _median(array) {
        try {
            array = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(array.valueOf());
            var num = array.length;
            if (num === 0) {
                throw new Error('Cannot calculate median of an empty array');
            }
            if (num % 2 === 0) {
                // even: return the average of the two middle values
                var mid = num / 2 - 1;
                var right = partitionSelect(array, mid + 1);
                // array now partitioned at mid + 1, take max of left part
                var left = array[mid];
                for(var i = 0; i < mid; ++i){
                    if (compare(array[i], left) > 0) {
                        left = array[i];
                    }
                }
                return middle2(left, right);
            } else {
                // odd: return the middle value
                var m = partitionSelect(array, (num - 1) / 2);
                return middle(m);
            }
        } catch (err) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'median');
        }
    }
    // helper function to type check the middle value of the array
    var middle = typed({
        'number | BigNumber | Complex | Unit': function number__BigNumber__Complex__Unit(value) {
            return value;
        }
    });
    // helper function to type check the two middle value of the array
    var middle2 = typed({
        'number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit': function number__BigNumber__Complex__Unit_number__BigNumber__Complex__Unit(left, right) {
            return divide(add(left, right), 2);
        }
    });
    /**
   * Compute the median of a matrix or a list with values. The values are
   * sorted and the middle value is returned. In case of an even number of
   * values, the average of the two middle values is returned.
   * Supported types of values are: Number, BigNumber, Unit
   *
   * In case of a (multi dimensional) array or matrix, the median of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.median(a, b, c, ...)
   *     math.median(A)
   *
   * Examples:
   *
   *     math.median(5, 2, 7)        // returns 5
   *     math.median([3, -1, 5, 7])  // returns 4
   *
   * See also:
   *
   *     mean, min, max, sum, prod, std, variance, quantileSeq
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The median
   */ return typed(name, {
        // median([a, b, c, d, ...])
        'Array | Matrix': _median,
        // median([a, b, c, d, ...], dim)
        'Array | Matrix, number | BigNumber': function Array__Matrix_number__BigNumber(array, dim) {
            // TODO: implement median(A, dim)
            throw new Error('median(A, dim) is not yet supported');
        // return reduce(arguments[0], arguments[1], ...)
        },
        // median(a, b, c, d, ...)
        '...': function _(args) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsCollections"])(args)) {
                throw new TypeError('Scalar values expected in function median');
            }
            return _median(args);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/corr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCorr": (()=>createCorr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'corr';
var dependencies = [
    'typed',
    'matrix',
    'mean',
    'sqrt',
    'sum',
    'add',
    'subtract',
    'multiply',
    'pow',
    'divide'
];
var createCorr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, sqrt, sum, add, subtract, multiply, pow, divide } = _ref;
    /**
   * Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
   *
   * Syntax:
   *
   *     math.corr(A, B)
   *
   * Examples:
   *
   *     math.corr([1, 2, 3, 4, 5], [4, 5, 6, 7, 8])     // returns 1
   *     math.corr([1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8])     //returns 0.9569941688503644
   *     math.corr([[1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8]],[[1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8]])   // returns [1,1]
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, variance
   *
   * @param {Array | Matrix} A The first array or matrix to compute correlation coefficient
   * @param {Array | Matrix} B The second array or matrix to compute correlation coefficient
   * @return {*} The correlation coefficient
   */ return typed(name, {
        'Array, Array': function Array_Array(A, B) {
            return _corr(A, B);
        },
        'Matrix, Matrix': function Matrix_Matrix(A, B) {
            var res = _corr(A.toArray(), B.toArray());
            return Array.isArray(res) ? matrix(res) : res;
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the correlation coefficient between two arrays or matrices.
   * @param {Array | Matrix} A
   * @param {Array | Matrix} B
   * @return {*} correlation coefficient
   * @private
   */ function _corr(A, B) {
        var correlations = [];
        if (Array.isArray(A[0]) && Array.isArray(B[0])) {
            if (A.length !== B.length) {
                throw new SyntaxError('Dimension mismatch. Array A and B must have the same length.');
            }
            for(var i = 0; i < A.length; i++){
                if (A[i].length !== B[i].length) {
                    throw new SyntaxError('Dimension mismatch. Array A and B must have the same number of elements.');
                }
                correlations.push(correlation(A[i], B[i]));
            }
            return correlations;
        } else {
            if (A.length !== B.length) {
                throw new SyntaxError('Dimension mismatch. Array A and B must have the same number of elements.');
            }
            return correlation(A, B);
        }
    }
    function correlation(A, B) {
        var n = A.length;
        var sumX = sum(A);
        var sumY = sum(B);
        var sumXY = A.reduce((acc, x, index)=>add(acc, multiply(x, B[index])), 0);
        var sumXSquare = sum(A.map((x)=>pow(x, 2)));
        var sumYSquare = sum(B.map((y)=>pow(y, 2)));
        var numerator = subtract(multiply(n, sumXY), multiply(sumX, sumY));
        var denominator = sqrt(multiply(subtract(multiply(n, sumXSquare), pow(sumX, 2)), subtract(multiply(n, sumYSquare), pow(sumY, 2))));
        return divide(numerator, denominator);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/signal/freqz.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFreqz": (()=>createFreqz)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'freqz';
var dependencies = [
    'typed',
    'add',
    'multiply',
    'Complex',
    'divide',
    'matrix'
];
var createFreqz = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, add, multiply, Complex, divide, matrix } = _ref;
    /**
     * Calculates the frequency response of a filter given its numerator and denominator coefficients.
     *
     * Syntax:
     *    math.freqz(b, a)
     *    math.freqz(b, a, w)
     *
     * Examples:
     *   math.freqz([1, 2], [1, 2, 3], 4) // returns { h: [0.5 + 0i, 0.4768589245763655 + 0.2861153547458193i, 0.25000000000000006 + 0.75i, -0.770976571635189 + 0.4625859429811135i], w: [0, 0.7853981633974483, 1.5707963267948966, 2.356194490192345 ] }
     *   math.freqz([1, 2], [1, 2, 3], [0, 1]) // returns { h: [0.5 + 0i, 0.45436781 + 0.38598051i], w: [0, 1] }
     *
     * See also:
     *  zpk2tf
     *
     * @param {Array.<number>} b The numerator coefficients of the filter.
     * @param {Array.<number>} a The denominator coefficients of the filter.
     * @param {Array.<number>} [w] A vector of frequencies (in radians/sample) at which the frequency response is to be computed or the number of points to compute (if a number is not provided, the default is 512 points)
     * @returns {Object} An object with two properties: h, a vector containing the complex frequency response, and w, a vector containing the normalized frequencies (in radians/sample) at which the response was computed.
     *
     *
     */ return typed(name, {
        'Array, Array': function Array_Array(b, a) {
            var w = createBins(512);
            return _freqz(b, a, w);
        },
        'Array, Array, Array': function Array_Array_Array(b, a, w) {
            return _freqz(b, a, w);
        },
        'Array, Array, number': function Array_Array_number(b, a, w) {
            if (w < 0) {
                throw new Error('w must be a positive number');
            }
            var w2 = createBins(w);
            return _freqz(b, a, w2);
        },
        'Matrix, Matrix': function Matrix_Matrix(b, a) {
            // console.log('here')
            var _w = createBins(512);
            var { w, h } = _freqz(b.valueOf(), a.valueOf(), _w);
            return {
                w: matrix(w),
                h: matrix(h)
            };
        },
        'Matrix, Matrix, Matrix': function Matrix_Matrix_Matrix(b, a, w) {
            var { h } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
            return {
                h: matrix(h),
                w: matrix(w)
            };
        },
        'Matrix, Matrix, number': function Matrix_Matrix_number(b, a, w) {
            if (w < 0) {
                throw new Error('w must be a positive number');
            }
            var _w = createBins(w);
            var { h } = _freqz(b.valueOf(), a.valueOf(), _w);
            return {
                h: matrix(h),
                w: matrix(_w)
            };
        }
    });
    "TURBOPACK unreachable";
    function _freqz(b, a, w) {
        var num = [];
        var den = [];
        for(var i = 0; i < w.length; i++){
            var sumNum = Complex(0, 0);
            var sumDen = Complex(0, 0);
            for(var j = 0; j < b.length; j++){
                sumNum = add(sumNum, multiply(b[j], Complex(Math.cos(-j * w[i]), Math.sin(-j * w[i]))));
            }
            for(var _j = 0; _j < a.length; _j++){
                sumDen = add(sumDen, multiply(a[_j], Complex(Math.cos(-_j * w[i]), Math.sin(-_j * w[i]))));
            }
            num.push(sumNum);
            den.push(sumDen);
        }
        var h = [];
        for(var _i = 0; _i < num.length; _i++){
            h.push(divide(num[_i], den[_i]));
        }
        return {
            h,
            w
        };
    }
    function createBins(n) {
        var bins = [];
        for(var i = 0; i < n; i++){
            bins.push(i / n * Math.PI);
        }
        return bins;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/mad.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMad": (()=>createMad)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js [app-ssr] (ecmascript)");
;
;
;
var name = 'mad';
var dependencies = [
    'typed',
    'abs',
    'map',
    'median',
    'subtract'
];
var createMad = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, map, median, subtract } = _ref;
    /**
   * Compute the median absolute deviation of a matrix or a list with values.
   * The median absolute deviation is defined as the median of the absolute
   * deviations from the median.
   *
   * Syntax:
   *
   *     math.mad(a, b, c, ...)
   *     math.mad(A)
   *
   * Examples:
   *
   *     math.mad(10, 20, 30)             // returns 10
   *     math.mad([1, 2, 3])              // returns 1
   *     math.mad([[1, 2, 3], [4, 5, 6]]) // returns 1.5
   *
   * See also:
   *
   *     median, mean, std, abs
   *
   * @param {Array | Matrix} array
   *                        A single matrix or multiple scalar values.
   * @return {*} The median absolute deviation.
   */ return typed(name, {
        // mad([a, b, c, d, ...])
        'Array | Matrix': _mad,
        // mad(a, b, c, d, ...)
        '...': function _(args) {
            return _mad(args);
        }
    });
    "TURBOPACK unreachable";
    function _mad(array) {
        array = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])(array.valueOf());
        if (array.length === 0) {
            throw new Error('Cannot calculate median absolute deviation (mad) of an empty array');
        }
        try {
            var med = median(array);
            return median(map(array, function(value) {
                return abs(subtract(value, med));
            }));
        } catch (err) {
            if (err instanceof TypeError && err.message.includes('median')) {
                throw new TypeError(err.message.replace('median', 'mad'));
            } else {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$statistics$2f$utils$2f$improveErrorMessage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["improveErrorMessage"])(err, 'mad');
            }
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/statistics/std.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createStd": (()=>createStd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
;
;
var name = 'std';
var dependencies = [
    'typed',
    'map',
    'sqrt',
    'variance'
];
var createStd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, map, sqrt, variance } = _ref;
    /**
   * Compute the standard deviation of a matrix or a  list with values.
   * The standard deviations is defined as the square root of the variance:
   * `std(A) = sqrt(variance(A))`.
   * In case of a (multi dimensional) array or matrix, the standard deviation
   * over all elements will be calculated by default, unless an axis is specified
   * in which case the standard deviation will be computed along that axis.
   *
   * Additionally, it is possible to compute the standard deviation along the rows
   * or columns of a matrix by specifying the dimension as the second argument.
   *
   * Optionally, the type of normalization can be specified as the final
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   *
   * Syntax:
   *
   *     math.std(a, b, c, ...)
   *     math.std(A)
   *     math.std(A, normalization)
   *     math.std(A, dimension)
   *     math.std(A, dimension, normalization)
   *
   * Examples:
   *
   *     math.std(2, 4, 6)                     // returns 2
   *     math.std([2, 4, 6, 8])                // returns 2.581988897471611
   *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979
   *     math.std([2, 4, 6, 8], 'biased')      // returns 2
   *
   *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707
   *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]
   *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]
   *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]
   *
   * See also:
   *
   *    mean, median, max, min, prod, sum, variance
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @param dimension {number | BigNumber}
   *                        Determines the axis to compute the standard deviation for a matrix
   * @return {*} The standard deviation
   */ return typed(name, {
        // std([a, b, c, d, ...])
        'Array | Matrix': _std,
        // std([a, b, c, d, ...], normalization)
        'Array | Matrix, string': _std,
        // std([a, b, c, c, ...], dim)
        'Array | Matrix, number | BigNumber': _std,
        // std([a, b, c, c, ...], dim, normalization)
        'Array | Matrix, number | BigNumber, string': _std,
        // std(a, b, c, d, ...)
        '...': function _(args) {
            return _std(args);
        }
    });
    "TURBOPACK unreachable";
    function _std(array, normalization) {
        if (array.length === 0) {
            throw new SyntaxError('Function std requires one or more parameters (0 provided)');
        }
        try {
            var v = variance.apply(null, arguments);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isCollection"])(v)) {
                return map(v, sqrt);
            } else {
                return sqrt(v);
            }
        } catch (err) {
            if (err instanceof TypeError && err.message.includes(' variance')) {
                throw new TypeError(err.message.replace(' variance', ' std'));
            } else {
                throw err;
            }
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/special/zeta.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createZeta": (()=>createZeta)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'zeta';
var dependencies = [
    'typed',
    'config',
    'multiply',
    'pow',
    'divide',
    'factorial',
    'equal',
    'smallerEq',
    'isNegative',
    'gamma',
    'sin',
    'subtract',
    'add',
    '?Complex',
    '?BigNumber',
    'pi'
];
var createZeta = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, multiply, pow, divide, factorial, equal, smallerEq, isNegative, gamma, sin, subtract, add, Complex, BigNumber: _BigNumber, pi } = _ref;
    /**
   * Compute the Riemann Zeta function of a value using an infinite series for
   * all of the complex plane using Riemann's Functional equation.
   *
   * Based off the paper by Xavier Gourdon and Pascal Sebah
   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )
   *
   * Implementation and slight modification by Anik Patel
   *
   * Note: the implementation is accurate up to about 6 digits.
   *
   * Syntax:
   *
   *    math.zeta(n)
   *
   * Examples:
   *
   *    math.zeta(5)       // returns 1.0369277551433895
   *    math.zeta(-0.5)    // returns -0.2078862249773449
   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i
   *
   * See also:
   *    erf
   *
   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function
   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`
   */ return typed(name, {
        number: (s)=>zetaNumeric(s, (value)=>value, ()=>20),
        BigNumber: (s)=>zetaNumeric(s, (value)=>new _BigNumber(value), ()=>{
                // relTol is for example 1e-12. Extract the positive exponent 12 from that
                return Math.abs(Math.log10(config.relTol));
            }),
        Complex: zetaComplex
    });
    "TURBOPACK unreachable";
    /**
   * @param {number | BigNumber} s
   * @param {(value: number) => number | BigNumber} createValue
   * @param {(value: number | BigNumber | Complex) => number} determineDigits
   * @returns {number | BigNumber}
   */ function zetaNumeric(s, createValue, determineDigits) {
        if (equal(s, 0)) {
            return createValue(-0.5);
        }
        if (equal(s, 1)) {
            return createValue(NaN);
        }
        if (!isFinite(s)) {
            return isNegative(s) ? createValue(NaN) : createValue(1);
        }
        return zeta(s, createValue, determineDigits, (s)=>s);
    }
    /**
   * @param {Complex} s
   * @returns {Complex}
   */ function zetaComplex(s) {
        if (s.re === 0 && s.im === 0) {
            return new Complex(-0.5);
        }
        if (s.re === 1) {
            return new Complex(NaN, NaN);
        }
        if (s.re === Infinity && s.im === 0) {
            return new Complex(1);
        }
        if (s.im === Infinity || s.re === -Infinity) {
            return new Complex(NaN, NaN);
        }
        return zeta(s, (value)=>value, (s)=>Math.round(1.3 * 15 + 0.9 * Math.abs(s.im)), (s)=>s.re);
    }
    /**
   * @param {number | BigNumber | Complex} s
   * @param {(value: number) => number | BigNumber | Complex} createValue
   * @param {(value: number | BigNumber | Complex) => number} determineDigits
   * @param {(value: number | BigNumber | Complex) => number} getRe
   * @returns {*|number}
   */ function zeta(s, createValue, determineDigits, getRe) {
        var n = determineDigits(s);
        if (getRe(s) > -(n - 1) / 2) {
            return f(s, createValue(n), createValue);
        } else {
            // Function Equation for reflection to x < 1
            var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));
            c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));
            c = multiply(c, gamma(subtract(1, s)));
            return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));
        }
    }
    /**
   * Calculate a portion of the sum
   * @param {number | BigNumber} k   a positive integer
   * @param {number | BigNumber} n   a positive integer
   * @return {number}    the portion of the sum
   **/ function d(k, n) {
        var S = k;
        for(var j = k; smallerEq(j, n); j = add(j, 1)){
            var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));
            S = add(S, factor);
        }
        return multiply(n, S);
    }
    /**
   * Calculate the positive Riemann Zeta function
   * @param {number} s   a real or complex number with s.re > 1
   * @param {number} n   a positive integer
   * @param {(number) => number | BigNumber | Complex} createValue
   * @return {number}    Riemann Zeta of s
   **/ function f(s, n, createValue) {
        var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));
        var S = createValue(0);
        for(var k = createValue(1); smallerEq(k, n); k = add(k, 1)){
            S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));
        }
        return multiply(c, S);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/norm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNorm": (()=>createNorm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'norm';
var dependencies = [
    'typed',
    'abs',
    'add',
    'pow',
    'conj',
    'sqrt',
    'multiply',
    'equalScalar',
    'larger',
    'smaller',
    'matrix',
    'ctranspose',
    'eigs'
];
var createNorm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, pow, conj, sqrt, multiply, equalScalar, larger, smaller, matrix, ctranspose, eigs } = _ref;
    /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5)                         // returns 3.5
   *    math.norm(-3.5)                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4))         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity)        // returns 3
   *    math.norm([1, 2, -3], -Infinity)       // returns 1
   *
   *    math.norm([3, 4], 2)                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */ return typed(name, {
        number: Math.abs,
        Complex: function Complex(x) {
            return x.abs();
        },
        BigNumber: function BigNumber(x) {
            // norm(x) = abs(x)
            return x.abs();
        },
        boolean: function boolean(x) {
            // norm(x) = abs(x)
            return Math.abs(x);
        },
        Array: function Array(x) {
            return _norm(matrix(x), 2);
        },
        Matrix: function Matrix(x) {
            return _norm(x, 2);
        },
        'Array, number | BigNumber | string': function Array_number__BigNumber__string(x, p) {
            return _norm(matrix(x), p);
        },
        'Matrix, number | BigNumber | string': function Matrix_number__BigNumber__string(x, p) {
            return _norm(x, p);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the plus infinity norm for a vector
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNormPlusInfinity(x) {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0;
        // skip zeros since abs(0) === 0
        x.forEach(function(value) {
            var v = abs(value);
            if (larger(v, pinf)) {
                pinf = v;
            }
        }, true);
        return pinf;
    }
    /**
   * Calculate the minus infinity norm for a vector
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNormMinusInfinity(x) {
        // norm(x, -Infinity) = min(abs(x))
        var ninf;
        // skip zeros since abs(0) === 0
        x.forEach(function(value) {
            var v = abs(value);
            if (!ninf || smaller(v, ninf)) {
                ninf = v;
            }
        }, true);
        return ninf || 0;
    }
    /**
   * Calculate the norm for a vector
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNorm(x, p) {
        // check p
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
            return _vectorNormPlusInfinity(x);
        }
        if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
            return _vectorNormMinusInfinity(x);
        }
        if (p === 'fro') {
            return _norm(x, 2);
        }
        if (typeof p === 'number' && !isNaN(p)) {
            // check p != 0
            if (!equalScalar(p, 0)) {
                // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
                var n = 0;
                // skip zeros since abs(0) === 0
                x.forEach(function(value) {
                    n = add(pow(abs(value), p), n);
                }, true);
                return pow(n, 1 / p);
            }
            return Number.POSITIVE_INFINITY;
        }
        // invalid parameter value
        throw new Error('Unsupported parameter value');
    }
    /**
   * Calculate the Frobenius norm for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormFrobenius(x) {
        // norm(x) = sqrt(sum(diag(x'x)))
        var fro = 0;
        x.forEach(function(value, index) {
            fro = add(fro, multiply(value, conj(value)));
        });
        return abs(sqrt(fro));
    }
    /**
   * Calculate the norm L1 for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormOne(x) {
        // norm(x) = the largest column sum
        var c = [];
        // result
        var maxc = 0;
        // skip zeros since abs(0) == 0
        x.forEach(function(value, index) {
            var j = index[1];
            var cj = add(c[j] || 0, abs(value));
            if (larger(cj, maxc)) {
                maxc = cj;
            }
            c[j] = cj;
        }, true);
        return maxc;
    }
    /**
   * Calculate the norm L2 for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormTwo(x) {
        // norm(x) = sqrt( max eigenvalue of A*.A)
        var sizeX = x.size();
        if (sizeX[0] !== sizeX[1]) {
            throw new RangeError('Invalid matrix dimensions');
        }
        var tx = ctranspose(x);
        var squaredX = multiply(tx, x);
        var eigenVals = eigs(squaredX).values.toArray();
        var rho = eigenVals[eigenVals.length - 1];
        return abs(sqrt(rho));
    }
    /**
   * Calculate the infinity norm for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormInfinity(x) {
        // norm(x) = the largest row sum
        var r = [];
        // result
        var maxr = 0;
        // skip zeros since abs(0) == 0
        x.forEach(function(value, index) {
            var i = index[0];
            var ri = add(r[i] || 0, abs(value));
            if (larger(ri, maxr)) {
                maxr = ri;
            }
            r[i] = ri;
        }, true);
        return maxr;
    }
    /**
   * Calculate the norm for a 2D Matrix (M*N)
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNorm(x, p) {
        // check p
        if (p === 1) {
            return _matrixNormOne(x);
        }
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
            return _matrixNormInfinity(x);
        }
        if (p === 'fro') {
            return _matrixNormFrobenius(x);
        }
        if (p === 2) {
            return _matrixNormTwo(x);
        } // invalid parameter value
        throw new Error('Unsupported parameter value ' + p);
    }
    /**
   * Calculate the norm for an array
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _norm(x, p) {
        // size
        var sizeX = x.size();
        // check if it is a vector
        if (sizeX.length === 1) {
            return _vectorNorm(x, p);
        }
        // MxN matrix
        if (sizeX.length === 2) {
            if (sizeX[0] && sizeX[1]) {
                return _matrixNorm(x, p);
            } else {
                throw new RangeError('Invalid matrix dimensions');
            }
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRotationMatrix": (()=>createRotationMatrix)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
;
var name = 'rotationMatrix';
var dependencies = [
    'typed',
    'config',
    'multiplyScalar',
    'addScalar',
    'unaryMinus',
    'norm',
    'matrix',
    'BigNumber',
    'DenseMatrix',
    'SparseMatrix',
    'cos',
    'sin'
];
var createRotationMatrix = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, multiplyScalar, addScalar, unaryMinus, norm, BigNumber, matrix, DenseMatrix, SparseMatrix, cos, sin } = _ref;
    /**
   * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
   * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).
   *
   * Syntax:
   *
   *    math.rotationMatrix(theta)
   *    math.rotationMatrix(theta, format)
   *    math.rotationMatrix(theta, [v])
   *    math.rotationMatrix(theta, [v], format)
   *
   * Examples:
   *
   *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]
   *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]
   *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]
   *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]
   *
   *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]
   *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])
   *
   *
   * See also:
   *
   *    matrix, cos, sin
   *
   *
   * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
   * @param {Array | Matrix} [v]                           Rotation axis
   * @param {string} [format]                              Result Matrix storage format
   * @return {Array | Matrix}                              Rotation matrix
   */ return typed(name, {
        '': function _() {
            return config.matrix === 'Matrix' ? matrix([]) : [];
        },
        string: function string(format) {
            return matrix(format);
        },
        'number | BigNumber | Complex | Unit': function number__BigNumber__Complex__Unit(theta) {
            return _rotationMatrix2x2(theta, config.matrix === 'Matrix' ? 'dense' : undefined);
        },
        'number | BigNumber | Complex | Unit, string': function number__BigNumber__Complex__Unit_string(theta, format) {
            return _rotationMatrix2x2(theta, format);
        },
        'number | BigNumber | Complex | Unit, Array': function number__BigNumber__Complex__Unit_Array(theta, v) {
            var matrixV = matrix(v);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, undefined);
        },
        'number | BigNumber | Complex | Unit, Matrix': function number__BigNumber__Complex__Unit_Matrix(theta, v) {
            _validateVector(v);
            var storageType = v.storage() || (config.matrix === 'Matrix' ? 'dense' : undefined);
            return _rotationMatrix3x3(theta, v, storageType);
        },
        'number | BigNumber | Complex | Unit, Array, string': function number__BigNumber__Complex__Unit_Array_string(theta, v, format) {
            var matrixV = matrix(v);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, format);
        },
        'number | BigNumber | Complex | Unit, Matrix, string': function number__BigNumber__Complex__Unit_Matrix_string(theta, v, format) {
            _validateVector(v);
            return _rotationMatrix3x3(theta, v, format);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Returns 2x2 matrix of 2D rotation of angle theta
   *
   * @param {number | BigNumber | Complex | Unit} theta  The rotation angle
   * @param {string} format                              The result Matrix storage format
   * @returns {Matrix}
   * @private
   */ function _rotationMatrix2x2(theta, format) {
        var Big = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(theta);
        var minusOne = Big ? new BigNumber(-1) : -1;
        var cosTheta = cos(theta);
        var sinTheta = sin(theta);
        var data = [
            [
                cosTheta,
                multiplyScalar(minusOne, sinTheta)
            ],
            [
                sinTheta,
                cosTheta
            ]
        ];
        return _convertToFormat(data, format);
    }
    function _validateVector(v) {
        var size = v.size();
        if (size.length < 1 || size[0] !== 3) {
            throw new RangeError('Vector must be of dimensions 1x3');
        }
    }
    function _mul(array) {
        return array.reduce((p, curr)=>multiplyScalar(p, curr));
    }
    function _convertToFormat(data, format) {
        if (format) {
            if (format === 'sparse') {
                return new SparseMatrix(data);
            }
            if (format === 'dense') {
                return new DenseMatrix(data);
            }
            throw new TypeError("Unknown matrix type \"".concat(format, "\""));
        }
        return data;
    }
    /**
   * Returns a 3x3 matrix of rotation of angle theta around vector v
   *
   * @param {number | BigNumber | Complex | Unit} theta The rotation angle
   * @param {Matrix} v                                  The rotation axis vector
   * @param {string} format                             The storage format of the resulting matrix
   * @returns {Matrix}
   * @private
   */ function _rotationMatrix3x3(theta, v, format) {
        var normV = norm(v);
        if (normV === 0) {
            throw new RangeError('Rotation around zero vector');
        }
        var Big = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBigNumber"])(theta) ? BigNumber : null;
        var one = Big ? new Big(1) : 1;
        var minusOne = Big ? new Big(-1) : -1;
        var vx = Big ? new Big(v.get([
            0
        ]) / normV) : v.get([
            0
        ]) / normV;
        var vy = Big ? new Big(v.get([
            1
        ]) / normV) : v.get([
            1
        ]) / normV;
        var vz = Big ? new Big(v.get([
            2
        ]) / normV) : v.get([
            2
        ]) / normV;
        var c = cos(theta);
        var oneMinusC = addScalar(one, unaryMinus(c));
        var s = sin(theta);
        var r11 = addScalar(c, _mul([
            vx,
            vx,
            oneMinusC
        ]));
        var r12 = addScalar(_mul([
            vx,
            vy,
            oneMinusC
        ]), _mul([
            minusOne,
            vz,
            s
        ]));
        var r13 = addScalar(_mul([
            vx,
            vz,
            oneMinusC
        ]), _mul([
            vy,
            s
        ]));
        var r21 = addScalar(_mul([
            vx,
            vy,
            oneMinusC
        ]), _mul([
            vz,
            s
        ]));
        var r22 = addScalar(c, _mul([
            vy,
            vy,
            oneMinusC
        ]));
        var r23 = addScalar(_mul([
            vy,
            vz,
            oneMinusC
        ]), _mul([
            minusOne,
            vx,
            s
        ]));
        var r31 = addScalar(_mul([
            vx,
            vz,
            oneMinusC
        ]), _mul([
            minusOne,
            vy,
            s
        ]));
        var r32 = addScalar(_mul([
            vy,
            vz,
            oneMinusC
        ]), _mul([
            vx,
            s
        ]));
        var r33 = addScalar(c, _mul([
            vz,
            vz,
            oneMinusC
        ]));
        var data = [
            [
                r11,
                r12,
                r13
            ],
            [
                r21,
                r22,
                r23
            ],
            [
                r31,
                r32,
                r33
            ]
        ];
        return _convertToFormat(data, format);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSchur": (()=>createSchur)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'schur';
var dependencies = [
    'typed',
    'matrix',
    'identity',
    'multiply',
    'qr',
    'norm',
    'subtract'
];
var createSchur = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, identity, multiply, qr, norm, subtract } = _ref;
    /**
   *
   * Performs a real Schur decomposition of the real matrix A = UTU' where U is orthogonal
   * and T is upper quasi-triangular.
   * https://en.wikipedia.org/wiki/Schur_decomposition
   *
   * Syntax:
   *
   *     math.schur(A)
   *
   * Examples:
   *
   *     const A = [[1, 0], [-4, 3]]
   *     math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}
   *
   * See also:
   *
   *     sylvester, lyap, qr
   *
   * @param {Array | Matrix} A  Matrix A
   * @return {{U: Array | Matrix, T: Array | Matrix}} Object containing both matrix U and T of the Schur Decomposition A=UTU'
   */ return typed(name, {
        Array: function Array(X) {
            var r = _schur(matrix(X));
            return {
                U: r.U.valueOf(),
                T: r.T.valueOf()
            };
        },
        Matrix: function Matrix(X) {
            return _schur(X);
        }
    });
    "TURBOPACK unreachable";
    function _schur(X) {
        var n = X.size()[0];
        var A = X;
        var U = identity(n);
        var k = 0;
        var A0;
        do {
            A0 = A;
            var QR = qr(A);
            var Q = QR.Q;
            var R = QR.R;
            A = multiply(R, Q);
            U = multiply(U, Q);
            if (k++ > 100) {
                break;
            }
        }while (norm(subtract(A, A0)) > 1e-4)
        return {
            U,
            T: A
        };
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/matrix/rotate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRotate": (()=>createRotate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-ssr] (ecmascript)");
;
;
var name = 'rotate';
var dependencies = [
    'typed',
    'multiply',
    'rotationMatrix'
];
var createRotate = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, multiply, rotationMatrix } = _ref;
    /**
     * Rotate a vector of size 1x2 counter-clockwise by a given angle
     * Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis
     *
     * Syntax:
     *
     *    math.rotate(w, theta)
     *    math.rotate(w, theta, v)
     *
     * Examples:
     *
     *    math.rotate([11, 12], math.pi / 2)                           // returns [-12, 11]
     *    math.rotate(matrix([11, 12]), math.pi / 2)                   // returns [-12, 11]
     *
     *    math.rotate([1, 0, 0], unit('90deg'), [0, 0, 1])             // returns [0, 1, 0]
     *    math.rotate(matrix([1, 0, 0]), unit('90deg'), [0, 0, 1])     // returns Matrix [0, 1, 0]
     *
     *    math.rotate([1, 0], math.complex(1 + i))                     // returns [cos(1 + i) - sin(1 + i), sin(1 + i) + cos(1 + i)]
     *
     * See also:
     *
     *    matrix, rotationMatrix
     *
     * @param {Array | Matrix} w                             Vector to rotate
     * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
     * @param {Array | Matrix} [v]                           Rotation axis
     * @return {Array | Matrix}                              Multiplication of the rotation matrix and w
     */ return typed(name, {
        'Array , number | BigNumber | Complex | Unit': function Array__number__BigNumber__Complex__Unit(w, theta) {
            _validateSize(w, 2);
            var matrixRes = multiply(rotationMatrix(theta), w);
            return matrixRes.toArray();
        },
        'Matrix , number | BigNumber | Complex | Unit': function Matrix__number__BigNumber__Complex__Unit(w, theta) {
            _validateSize(w, 2);
            return multiply(rotationMatrix(theta), w);
        },
        'Array, number | BigNumber | Complex | Unit, Array | Matrix': function Array_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
            _validateSize(w, 3);
            var matrixRes = multiply(rotationMatrix(theta, v), w);
            return matrixRes;
        },
        'Matrix, number | BigNumber | Complex | Unit, Array | Matrix': function Matrix_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
            _validateSize(w, 3);
            return multiply(rotationMatrix(theta, v), w);
        }
    });
    "TURBOPACK unreachable";
    function _validateSize(v, expectedSize) {
        var actualSize = Array.isArray(v) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arraySize"])(v) : v.size();
        if (actualSize.length > 2) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
        if (actualSize.length === 2 && actualSize[1] !== 1) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
        if (actualSize[0] !== expectedSize) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sylvester.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSylvester": (()=>createSylvester)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'sylvester';
var dependencies = [
    'typed',
    'schur',
    'matrixFromColumns',
    'matrix',
    'multiply',
    'range',
    'concat',
    'transpose',
    'index',
    'subset',
    'add',
    'subtract',
    'identity',
    'lusolve',
    'abs'
];
var createSylvester = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, schur, matrixFromColumns, matrix, multiply, range, concat, transpose, index, subset, add, subtract, identity, lusolve, abs } = _ref;
    /**
   *
   * Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are
   * matrices of appropriate dimensions, being A and B squared. Notice that other
   * equivalent definitions for the Sylvester equation exist and this function
   * assumes the one presented in the original publication of the the Bartels-
   * Stewart algorithm, which is implemented by this function.
   * https://en.wikipedia.org/wiki/Sylvester_equation
   *
   * Syntax:
   *
   *     math.sylvester(A, B, C)
   *
   * Examples:
   *
   *     const A = [[-1, -2], [1, 1]]
   *     const B = [[2, -1], [1, -2]]
   *     const C = [[-3, 2], [3, 0]]
   *     math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]
   *
   * See also:
   *
   *     schur, lyap
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} B  Matrix B
   * @param {Matrix | Array} C  Matrix C
   * @return {Matrix | Array}   Matrix X, solving the Sylvester equation
   */ return typed(name, {
        'Matrix, Matrix, Matrix': _sylvester,
        'Array, Matrix, Matrix': function Array_Matrix_Matrix(A, B, C) {
            return _sylvester(matrix(A), B, C);
        },
        'Array, Array, Matrix': function Array_Array_Matrix(A, B, C) {
            return _sylvester(matrix(A), matrix(B), C);
        },
        'Array, Matrix, Array': function Array_Matrix_Array(A, B, C) {
            return _sylvester(matrix(A), B, matrix(C));
        },
        'Matrix, Array, Matrix': function Matrix_Array_Matrix(A, B, C) {
            return _sylvester(A, matrix(B), C);
        },
        'Matrix, Array, Array': function Matrix_Array_Array(A, B, C) {
            return _sylvester(A, matrix(B), matrix(C));
        },
        'Matrix, Matrix, Array': function Matrix_Matrix_Array(A, B, C) {
            return _sylvester(A, B, matrix(C));
        },
        'Array, Array, Array': function Array_Array_Array(A, B, C) {
            return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();
        }
    });
    "TURBOPACK unreachable";
    function _sylvester(A, B, C) {
        var n = B.size()[0];
        var m = A.size()[0];
        var sA = schur(A);
        var F = sA.T;
        var U = sA.U;
        var sB = schur(multiply(-1, B));
        var G = sB.T;
        var V = sB.U;
        var D = multiply(multiply(transpose(U), C), V);
        var all = range(0, m);
        var y = [];
        var hc = (a, b)=>concat(a, b, 1);
        var vc = (a, b)=>concat(a, b, 0);
        for(var k = 0; k < n; k++){
            if (k < n - 1 && abs(subset(G, index(k + 1, k))) > 1e-5) {
                var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));
                for(var j = 0; j < k; j++){
                    RHS = add(RHS, vc(multiply(y[j], subset(G, index(j, k))), multiply(y[j], subset(G, index(j, k + 1)))));
                }
                var gkk = multiply(identity(m), multiply(-1, subset(G, index(k, k))));
                var gmk = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k))));
                var gkm = multiply(identity(m), multiply(-1, subset(G, index(k, k + 1))));
                var gmm = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k + 1))));
                var LHS = vc(hc(add(F, gkk), gmk), hc(gkm, add(F, gmm)));
                var yAux = lusolve(LHS, RHS);
                y[k] = yAux.subset(index(range(0, m), 0));
                y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));
                k++;
            } else {
                var _RHS = subset(D, index(all, k));
                for(var _j = 0; _j < k; _j++){
                    _RHS = add(_RHS, multiply(y[_j], subset(G, index(_j, k))));
                }
                var _gkk = subset(G, index(k, k));
                var _LHS = subtract(F, multiply(_gkk, identity(m)));
                y[k] = lusolve(_LHS, _RHS);
            }
        }
        var Y = matrix(matrixFromColumns(...y));
        var X = multiply(U, multiply(Y, transpose(V)));
        return X;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/lyap.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLyap": (()=>createLyap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-ssr] (ecmascript)");
;
var name = 'lyap';
var dependencies = [
    'typed',
    'matrix',
    'sylvester',
    'multiply',
    'transpose'
];
var createLyap = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, sylvester, multiply, transpose } = _ref;
    /**
   *
   * Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P, where
   * Q is an input matrix. When Q is symmetric, P is also symmetric. Notice
   * that different equivalent definitions exist for the Continuous-time
   * Lyapunov equation.
   * https://en.wikipedia.org/wiki/Lyapunov_equation
   *
   * Syntax:
   *
   *     math.lyap(A, Q)
   *
   * Examples:
   *
   *     const A = [[-2, 0], [1, -4]]
   *     const Q = [[3, 1], [1, 3]]
   *     const P = math.lyap(A, Q)
   *
   * See also:
   *
   *     sylvester, schur
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} Q  Matrix Q
   * @return {Matrix | Array} Matrix P solution to the Continuous-time Lyapunov equation AP+PA'=Q
   */ return typed(name, {
        'Matrix, Matrix': function Matrix_Matrix(A, Q) {
            return sylvester(A, transpose(A), multiply(-1, Q));
        },
        'Array, Matrix': function Array_Matrix(A, Q) {
            return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q));
        },
        'Matrix, Array': function Matrix_Array(A, Q) {
            return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q)));
        },
        'Array, Array': function Array_Array(A, Q) {
            return sylvester(matrix(A), transpose(matrix(A)), matrix(multiply(-1, Q))).toArray();
        }
    });
});
}}),

};

//# sourceMappingURL=node_modules_mathjs_lib_esm_function_acbc216e._.js.map