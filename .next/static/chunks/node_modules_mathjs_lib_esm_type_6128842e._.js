(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBigNumberClass": (()=>createBigNumberClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decimal.js/decimal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'BigNumber';
var dependencies = [
    '?on',
    'config'
];
var createBigNumberClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { on, config } = _ref;
    var BigNumber = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone({
        precision: config.precision,
        modulo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EUCLID
    });
    BigNumber.prototype = Object.create(BigNumber.prototype);
    /**
   * Attach type information
   */ BigNumber.prototype.type = 'BigNumber';
    BigNumber.prototype.isBigNumber = true;
    /**
   * Get a JSON representation of a BigNumber containing
   * type information
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "BigNumber", "value": "0.2"}`
   */ BigNumber.prototype.toJSON = function() {
        return {
            mathjs: 'BigNumber',
            value: this.toString()
        };
    };
    /**
   * Instantiate a BigNumber from a JSON object
   * @param {Object} json  a JSON object structured as:
   *                       `{"mathjs": "BigNumber", "value": "0.2"}`
   * @return {BigNumber}
   */ BigNumber.fromJSON = function(json) {
        return new BigNumber(json.value);
    };
    if (on) {
        // listen for changed in the configuration, automatically apply changed precision
        on('config', function(curr, prev) {
            if (curr.precision !== prev.precision) {
                BigNumber.config({
                    precision: curr.precision
                });
            }
        });
    }
    return BigNumber;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/complex/Complex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createComplexClass": (()=>createComplexClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/complex.js/dist/complex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
;
var name = 'Complex';
var dependencies = [];
var createComplexClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, ()=>{
    /**
   * Attach type information
   */ Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], 'name', {
        value: 'Complex'
    });
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.constructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.type = 'Complex';
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.isComplex = true;
    /**
   * Get a JSON representation of the complex number
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.toJSON = function() {
        return {
            mathjs: 'Complex',
            re: this.re,
            im: this.im
        };
    };
    /*
   * Return the value of the complex number in polar notation
   * The angle phi will be set in the interval of [-pi, pi].
   * @return {{r: number, phi: number}} Returns and object with properties r and phi.
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.toPolar = function() {
        return {
            r: this.abs(),
            phi: this.arg()
        };
    };
    /**
   * Get a string representation of the complex number,
   * with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string} str
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.format = function(options) {
        var str = '';
        var im = this.im;
        var re = this.re;
        var strRe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.re, options);
        var strIm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.im, options);
        // round either re or im when smaller than the configured precision
        var precision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(options) ? options : options ? options.precision : null;
        if (precision !== null) {
            var epsilon = Math.pow(10, -precision);
            if (Math.abs(re / im) < epsilon) {
                re = 0;
            }
            if (Math.abs(im / re) < epsilon) {
                im = 0;
            }
        }
        if (im === 0) {
            // real value
            str = strRe;
        } else if (re === 0) {
            // purely complex value
            if (im === 1) {
                str = 'i';
            } else if (im === -1) {
                str = '-i';
            } else {
                str = strIm + 'i';
            }
        } else {
            // complex value
            if (im < 0) {
                if (im === -1) {
                    str = strRe + ' - i';
                } else {
                    str = strRe + ' - ' + strIm.substring(1) + 'i';
                }
            } else {
                if (im === 1) {
                    str = strRe + ' + i';
                } else {
                    str = strRe + ' + ' + strIm + 'i';
                }
            }
        }
        return str;
    };
    /**
   * Create a complex number from polar coordinates
   *
   * Usage:
   *
   *     Complex.fromPolar(r: number, phi: number) : Complex
   *     Complex.fromPolar({r: number, phi: number}) : Complex
   *
   * @param {*} args...
   * @return {Complex}
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromPolar = function(args) {
        switch(arguments.length){
            case 1:
                {
                    var arg = arguments[0];
                    if (typeof arg === 'object') {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arg);
                    } else {
                        throw new TypeError('Input has to be an object with r and phi keys.');
                    }
                }
            case 2:
                {
                    var r = arguments[0];
                    var phi = arguments[1];
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(r)) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(phi) && phi.hasBase('ANGLE')) {
                            // convert unit to a number in radians
                            phi = phi.toNumber('rad');
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(phi)) {
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                                r,
                                phi
                            });
                        }
                        throw new TypeError('Phi is not a number nor an angle unit.');
                    } else {
                        throw new TypeError('Radius r is not a number.');
                    }
                }
            default:
                throw new SyntaxError('Wrong number of arguments in function fromPolar');
        }
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.valueOf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.toString;
    /**
   * Create a Complex number from a JSON object
   * @param {Object} json  A JSON Object structured as
   *                       {"mathjs": "Complex", "re": 2, "im": 3}
   *                       All properties are optional, default values
   *                       for `re` and `im` are 0.
   * @return {Complex} Returns a new Complex number
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromJSON = function(json) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](json);
    };
    /**
   * Compare two complex numbers, `a` and `b`:
   *
   * - Returns 1 when the real part of `a` is larger than the real part of `b`
   * - Returns -1 when the real part of `a` is smaller than the real part of `b`
   * - Returns 1 when the real parts are equal
   *   and the imaginary part of `a` is larger than the imaginary part of `b`
   * - Returns -1 when the real parts are equal
   *   and the imaginary part of `a` is smaller than the imaginary part of `b`
   * - Returns 0 when both real and imaginary parts are equal.
   *
   * @params {Complex} a
   * @params {Complex} b
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].compare = function(a, b) {
        if (a.re > b.re) {
            return 1;
        }
        if (a.re < b.re) {
            return -1;
        }
        if (a.im > b.im) {
            return 1;
        }
        if (a.im < b.im) {
            return -1;
        }
        return 0;
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$complex$2e$js$2f$dist$2f$complex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/unit/physicalConstants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAtomicMass": (()=>createAtomicMass),
    "createAvogadro": (()=>createAvogadro),
    "createBohrMagneton": (()=>createBohrMagneton),
    "createBohrRadius": (()=>createBohrRadius),
    "createBoltzmann": (()=>createBoltzmann),
    "createClassicalElectronRadius": (()=>createClassicalElectronRadius),
    "createConductanceQuantum": (()=>createConductanceQuantum),
    "createCoulomb": (()=>createCoulomb),
    "createCoulombConstant": (()=>createCoulombConstant),
    "createDeuteronMass": (()=>createDeuteronMass),
    "createEfimovFactor": (()=>createEfimovFactor),
    "createElectricConstant": (()=>createElectricConstant),
    "createElectronMass": (()=>createElectronMass),
    "createElementaryCharge": (()=>createElementaryCharge),
    "createFaraday": (()=>createFaraday),
    "createFermiCoupling": (()=>createFermiCoupling),
    "createFineStructure": (()=>createFineStructure),
    "createFirstRadiation": (()=>createFirstRadiation),
    "createGasConstant": (()=>createGasConstant),
    "createGravitationConstant": (()=>createGravitationConstant),
    "createGravity": (()=>createGravity),
    "createHartreeEnergy": (()=>createHartreeEnergy),
    "createInverseConductanceQuantum": (()=>createInverseConductanceQuantum),
    "createJosephson": (()=>createJosephson),
    "createKlitzing": (()=>createKlitzing),
    "createLoschmidt": (()=>createLoschmidt),
    "createMagneticConstant": (()=>createMagneticConstant),
    "createMagneticFluxQuantum": (()=>createMagneticFluxQuantum),
    "createMolarMass": (()=>createMolarMass),
    "createMolarMassC12": (()=>createMolarMassC12),
    "createMolarPlanckConstant": (()=>createMolarPlanckConstant),
    "createMolarVolume": (()=>createMolarVolume),
    "createNeutronMass": (()=>createNeutronMass),
    "createNuclearMagneton": (()=>createNuclearMagneton),
    "createPlanckCharge": (()=>createPlanckCharge),
    "createPlanckConstant": (()=>createPlanckConstant),
    "createPlanckLength": (()=>createPlanckLength),
    "createPlanckMass": (()=>createPlanckMass),
    "createPlanckTemperature": (()=>createPlanckTemperature),
    "createPlanckTime": (()=>createPlanckTime),
    "createProtonMass": (()=>createProtonMass),
    "createQuantumOfCirculation": (()=>createQuantumOfCirculation),
    "createReducedPlanckConstant": (()=>createReducedPlanckConstant),
    "createRydberg": (()=>createRydberg),
    "createSackurTetrode": (()=>createSackurTetrode),
    "createSecondRadiation": (()=>createSecondRadiation),
    "createSpeedOfLight": (()=>createSpeedOfLight),
    "createStefanBoltzmann": (()=>createStefanBoltzmann),
    "createThomsonCrossSection": (()=>createThomsonCrossSection),
    "createVacuumImpedance": (()=>createVacuumImpedance),
    "createWeakMixingAngle": (()=>createWeakMixingAngle),
    "createWienDisplacement": (()=>createWienDisplacement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var createSpeedOfLight = /* #__PURE__ */ unitFactory('speedOfLight', '299792458', 'm s^-1');
var createGravitationConstant = /* #__PURE__ */ unitFactory('gravitationConstant', '6.67430e-11', 'm^3 kg^-1 s^-2');
var createPlanckConstant = /* #__PURE__ */ unitFactory('planckConstant', '6.62607015e-34', 'J s');
var createReducedPlanckConstant = /* #__PURE__ */ unitFactory('reducedPlanckConstant', '1.0545718176461565e-34', 'J s');
var createMagneticConstant = /* #__PURE__ */ unitFactory('magneticConstant', '1.25663706212e-6', 'N A^-2');
var createElectricConstant = /* #__PURE__ */ unitFactory('electricConstant', '8.8541878128e-12', 'F m^-1');
var createVacuumImpedance = /* #__PURE__ */ unitFactory('vacuumImpedance', '376.730313667', 'ohm');
var createCoulomb = /* #__PURE__ */ unitFactory('coulomb', '8.987551792261171e9', 'N m^2 C^-2'); // Deprecated in favor of coulombConstant
var createCoulombConstant = /* #__PURE__ */ unitFactory('coulombConstant', '8.987551792261171e9', 'N m^2 C^-2');
var createElementaryCharge = /* #__PURE__ */ unitFactory('elementaryCharge', '1.602176634e-19', 'C');
var createBohrMagneton = /* #__PURE__ */ unitFactory('bohrMagneton', '9.2740100783e-24', 'J T^-1');
var createConductanceQuantum = /* #__PURE__ */ unitFactory('conductanceQuantum', '7.748091729863649e-5', 'S');
var createInverseConductanceQuantum = /* #__PURE__ */ unitFactory('inverseConductanceQuantum', '12906.403729652257', 'ohm');
var createMagneticFluxQuantum = /* #__PURE__ */ unitFactory('magneticFluxQuantum', '2.0678338484619295e-15', 'Wb');
var createNuclearMagneton = /* #__PURE__ */ unitFactory('nuclearMagneton', '5.0507837461e-27', 'J T^-1');
var createKlitzing = /* #__PURE__ */ unitFactory('klitzing', '25812.807459304513', 'ohm');
var createJosephson = /* #__PURE__ */ unitFactory('josephson', '4.835978484169836e14 Hz V', 'Hz V^-1'); // TODO: support for Hz needed
var createBohrRadius = /* #__PURE__ */ unitFactory('bohrRadius', '5.29177210903e-11', 'm');
var createClassicalElectronRadius = /* #__PURE__ */ unitFactory('classicalElectronRadius', '2.8179403262e-15', 'm');
var createElectronMass = /* #__PURE__ */ unitFactory('electronMass', '9.1093837015e-31', 'kg');
var createFermiCoupling = /* #__PURE__ */ unitFactory('fermiCoupling', '1.1663787e-5', 'GeV^-2');
var createFineStructure = numberFactory('fineStructure', 7.2973525693e-3);
var createHartreeEnergy = /* #__PURE__ */ unitFactory('hartreeEnergy', '4.3597447222071e-18', 'J');
var createProtonMass = /* #__PURE__ */ unitFactory('protonMass', '1.67262192369e-27', 'kg');
var createDeuteronMass = /* #__PURE__ */ unitFactory('deuteronMass', '3.3435830926e-27', 'kg');
var createNeutronMass = /* #__PURE__ */ unitFactory('neutronMass', '1.6749271613e-27', 'kg');
var createQuantumOfCirculation = /* #__PURE__ */ unitFactory('quantumOfCirculation', '3.6369475516e-4', 'm^2 s^-1');
var createRydberg = /* #__PURE__ */ unitFactory('rydberg', '10973731.568160', 'm^-1');
var createThomsonCrossSection = /* #__PURE__ */ unitFactory('thomsonCrossSection', '6.6524587321e-29', 'm^2');
var createWeakMixingAngle = numberFactory('weakMixingAngle', 0.22290);
var createEfimovFactor = numberFactory('efimovFactor', 22.7);
var createAtomicMass = /* #__PURE__ */ unitFactory('atomicMass', '1.66053906660e-27', 'kg');
var createAvogadro = /* #__PURE__ */ unitFactory('avogadro', '6.02214076e23', 'mol^-1');
var createBoltzmann = /* #__PURE__ */ unitFactory('boltzmann', '1.380649e-23', 'J K^-1');
var createFaraday = /* #__PURE__ */ unitFactory('faraday', '96485.33212331001', 'C mol^-1');
var createFirstRadiation = /* #__PURE__ */ unitFactory('firstRadiation', '3.7417718521927573e-16', 'W m^2');
var createLoschmidt = /* #__PURE__ */ unitFactory('loschmidt', '2.686780111798444e25', 'm^-3');
var createGasConstant = /* #__PURE__ */ unitFactory('gasConstant', '8.31446261815324', 'J K^-1 mol^-1');
var createMolarPlanckConstant = /* #__PURE__ */ unitFactory('molarPlanckConstant', '3.990312712893431e-10', 'J s mol^-1');
var createMolarVolume = /* #__PURE__ */ unitFactory('molarVolume', '0.022413969545014137', 'm^3 mol^-1');
var createSackurTetrode = numberFactory('sackurTetrode', -1.16487052358);
var createSecondRadiation = /* #__PURE__ */ unitFactory('secondRadiation', '0.014387768775039337', 'm K');
var createStefanBoltzmann = /* #__PURE__ */ unitFactory('stefanBoltzmann', '5.67037441918443e-8', 'W m^-2 K^-4');
var createWienDisplacement = /* #__PURE__ */ unitFactory('wienDisplacement', '2.897771955e-3', 'm K');
var createMolarMass = /* #__PURE__ */ unitFactory('molarMass', '0.99999999965e-3', 'kg mol^-1');
var createMolarMassC12 = /* #__PURE__ */ unitFactory('molarMassC12', '11.9999999958e-3', 'kg mol^-1');
var createGravity = /* #__PURE__ */ unitFactory('gravity', '9.80665', 'm s^-2');
var createPlanckLength = /* #__PURE__ */ unitFactory('planckLength', '1.616255e-35', 'm');
var createPlanckMass = /* #__PURE__ */ unitFactory('planckMass', '2.176435e-8', 'kg');
var createPlanckTime = /* #__PURE__ */ unitFactory('planckTime', '5.391245e-44', 's');
var createPlanckCharge = /* #__PURE__ */ unitFactory('planckCharge', '1.87554603778e-18', 'C');
var createPlanckTemperature = /* #__PURE__ */ unitFactory('planckTemperature', '1.416785e+32', 'K');
// helper function to create a factory function which creates a physical constant,
// a Unit with either a number value or a BigNumber value depending on the configuration
function unitFactory(name, valueStr, unitStr) {
    var dependencies = [
        'config',
        'Unit',
        'BigNumber'
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
        var { config, Unit, BigNumber } = _ref;
        // Note that we can parse into number or BigNumber.
        // We do not parse into Fractions as that doesn't make sense: we would lose precision of the values
        // Therefore we dont use Unit.parse()
        var value = config.number === 'BigNumber' ? new BigNumber(valueStr) : parseFloat(valueStr);
        var unit = new Unit(value, unitStr);
        unit.fixPrefix = true;
        return unit;
    });
}
// helper function to create a factory function which creates a numeric constant,
// either a number or BigNumber depending on the configuration
function numberFactory(name, value) {
    var dependencies = [
        'config',
        'BigNumber'
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
        var { config, BigNumber } = _ref2;
        return config.number === 'BigNumber' ? new BigNumber(value) : value;
    });
}
}}),
"[project]/node_modules/mathjs/lib/esm/type/fraction/Fraction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFractionClass": (()=>createFractionClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fraction.js/dist/fraction.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'Fraction';
var dependencies = [];
var createFractionClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, ()=>{
    /**
   * Attach type information
   */ Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], 'name', {
        value: 'Fraction'
    });
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.constructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.type = 'Fraction';
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.isFraction = true;
    /**
   * Get a JSON representation of a Fraction containing type information
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Fraction", "n": "3", "d": "8"}`
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.toJSON = function() {
        return {
            mathjs: 'Fraction',
            n: String(this.s * this.n),
            d: String(this.d)
        };
    };
    /**
   * Instantiate a Fraction from a JSON object
   * @param {Object} json  a JSON object structured as:
   *                       `{"mathjs": "Fraction", "n": "3", "d": "8"}`
   * @return {BigNumber}
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromJSON = function(json) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](json);
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fraction$2e$js$2f$dist$2f$fraction$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/Matrix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrixClass": (()=>createMatrixClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'Matrix';
var dependencies = [];
var createMatrixClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, ()=>{
    /**
   * @constructor Matrix
   *
   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
   * array. A matrix can be constructed as:
   *
   *     let matrix = math.matrix(data)
   *
   * Matrix contains the functions to resize, get and set values, get the size,
   * clone the matrix and to convert the matrix to a vector, array, or scalar.
   * Furthermore, one can iterate over the matrix using map and forEach.
   * The internal Array of the Matrix can be accessed using the function valueOf.
   *
   * Example usage:
   *
   *     let matrix = math.matrix([[1, 2], [3, 4]])
   *     matix.size()              // [2, 2]
   *     matrix.resize([3, 2], 5)
   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
   *     matrix.subset([1,2])       // 3 (indexes are zero-based)
   *
   */ function Matrix() {
        if (!(this instanceof Matrix)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
    }
    /**
   * Attach type information
   */ Matrix.prototype.type = 'Matrix';
    Matrix.prototype.isMatrix = true;
    /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()   // retrieve storage format
   *
   * @return {string}           The storage format.
   */ Matrix.prototype.storage = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke storage on a Matrix interface');
    };
    /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()    // retrieve matrix datatype
   *
   * @return {string}           The datatype.
   */ Matrix.prototype.datatype = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke datatype on a Matrix interface');
    };
    /**
   * Create a new Matrix With the type of the current matrix instance
   * @param {Array | Object} data
   * @param {string} [datatype]
   */ Matrix.prototype.create = function(data, datatype) {
        throw new Error('Cannot invoke create on a Matrix interface');
    };
    /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */ Matrix.prototype.subset = function(index, replacement, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke subset on a Matrix interface');
    };
    /**
   * Get a single element from the matrix.
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */ Matrix.prototype.get = function(index) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke get on a Matrix interface');
    };
    /**
   * Replace a single element in the matrix.
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {Matrix} self
   */ Matrix.prototype.set = function(index, value, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke set on a Matrix interface');
    };
    /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */ Matrix.prototype.resize = function(size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke resize on a Matrix interface');
    };
    /**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * @param {number[]} size           The new size the matrix should have.
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */ Matrix.prototype.reshape = function(size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke reshape on a Matrix interface');
    };
    /**
   * Create a clone of the matrix
   * @return {Matrix} clone
   */ Matrix.prototype.clone = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke clone on a Matrix interface');
    };
    /**
   * Retrieve the size of the matrix.
   * @returns {number[]} size
   */ Matrix.prototype.size = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke size on a Matrix interface');
    };
    /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {Matrix} matrix
   */ Matrix.prototype.map = function(callback, skipZeros) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke map on a Matrix interface');
    };
    /**
   * Execute a callback function on each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   */ Matrix.prototype.forEach = function(callback) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke forEach on a Matrix interface');
    };
    /**
   * Iterate over the matrix elements
   * @return {Iterable<{ value, index: number[] }>}
   */ Matrix.prototype[Symbol.iterator] = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot iterate a Matrix interface');
    };
    /**
   * Create an Array with a copy of the data of the Matrix
   * @returns {Array} array
   */ Matrix.prototype.toArray = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toArray on a Matrix interface');
    };
    /**
   * Get the primitive value of the Matrix: a multidimensional array
   * @returns {Array} array
   */ Matrix.prototype.valueOf = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke valueOf on a Matrix interface');
    };
    /**
   * Get a string representation of the matrix, with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */ Matrix.prototype.format = function(options) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke format on a Matrix interface');
    };
    /**
   * Get a string representation of the matrix
   * @returns {string} str
   */ Matrix.prototype.toString = function() {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toString on a Matrix interface');
    };
    return Matrix;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/Range.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRangeClass": (()=>createRangeClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
var name = 'Range';
var dependencies = [];
var createRangeClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, ()=>{
    /**
   * Create a range of numbers. A range has a start, step, and end,
   * and contains functions to iterate over the range.
   *
   * A range can be constructed as:
   *
   *     const range = new Range(start, end)
   *     const range = new Range(start, end, step)
   *
   * Note that the endpoints and step may be specified with other numeric
   * types such as bigint or BigNumber, but they will be demoted to the
   * built-in `number` type and the Range will only contain numbers. The
   * rationale for this demotion is that Range objects are primarily used
   * for indexing Matrix objects, and Matrix objects may only be indexed
   * with `number`s.
   *
   * To get the result of the range:
   *     range.forEach(function (x) {
   *         console.log(x)
   *     })
   *     range.map(function (x) {
   *         return math.sin(x)
   *     })
   *     range.toArray()
   *
   * Example usage:
   *
   *     const c = new Range(2, 6)       // 2:1:5
   *     c.toArray()                     // [2, 3, 4, 5]
   *     const d = new Range(2, -3, -1)  // 2:-1:-2
   *     d.toArray()                     // [2, 1, 0, -1, -2]
   *
   * @class Range
   * @constructor Range
   * @param {number} start  included lower bound
   * @param {number} end    excluded upper bound
   * @param {number} [step] step size, default value is 1
   */ function Range(start, end, step) {
        if (!(this instanceof Range)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        var hasStart = start !== null && start !== undefined;
        var hasEnd = end !== null && end !== undefined;
        var hasStep = step !== null && step !== undefined;
        if (hasStart) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(start)) {
                start = start.toNumber();
            } else if (typeof start !== 'number' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigInt"])(start)) {
                throw new TypeError('Parameter start must be a number or bigint');
            }
        }
        if (hasEnd) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(end)) {
                end = end.toNumber();
            } else if (typeof end !== 'number' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigInt"])(end)) {
                throw new TypeError('Parameter end must be a number or bigint');
            }
        }
        if (hasStep) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(step)) {
                step = step.toNumber();
            } else if (typeof step !== 'number' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigInt"])(step)) {
                throw new TypeError('Parameter step must be a number or bigint');
            }
        }
        this.start = hasStart ? parseFloat(start) : 0;
        this.end = hasEnd ? parseFloat(end) : 0;
        this.step = hasStep ? parseFloat(step) : 1;
    }
    /**
   * Attach type information
   */ Range.prototype.type = 'Range';
    Range.prototype.isRange = true;
    /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @memberof Range
   * @param {string} str
   * @return {Range | null} range
   */ Range.parse = function(str) {
        if (typeof str !== 'string') {
            return null;
        }
        var args = str.split(':');
        var nums = args.map(function(arg) {
            return parseFloat(arg);
        });
        var invalid = nums.some(function(num) {
            return isNaN(num);
        });
        if (invalid) {
            return null;
        }
        switch(nums.length){
            case 2:
                return new Range(nums[0], nums[1]);
            case 3:
                return new Range(nums[0], nums[2], nums[1]);
            default:
                return null;
        }
    };
    /**
   * Create a clone of the range
   * @return {Range} clone
   */ Range.prototype.clone = function() {
        return new Range(this.start, this.end, this.step);
    };
    /**
   * Retrieve the size of the range.
   * Returns an array containing one number, the number of elements in the range.
   * @memberof Range
   * @returns {number[]} size
   */ Range.prototype.size = function() {
        var len = 0;
        var start = this.start;
        var step = this.step;
        var end = this.end;
        var diff = end - start;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sign"])(step) === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sign"])(diff)) {
            len = Math.ceil(diff / step);
        } else if (diff === 0) {
            len = 0;
        }
        if (isNaN(len)) {
            len = 0;
        }
        return [
            len
        ];
    };
    /**
   * Calculate the minimum value in the range
   * @memberof Range
   * @return {number | undefined} min
   */ Range.prototype.min = function() {
        var size = this.size()[0];
        if (size > 0) {
            if (this.step > 0) {
                // positive step
                return this.start;
            } else {
                // negative step
                return this.start + (size - 1) * this.step;
            }
        } else {
            return undefined;
        }
    };
    /**
   * Calculate the maximum value in the range
   * @memberof Range
   * @return {number | undefined} max
   */ Range.prototype.max = function() {
        var size = this.size()[0];
        if (size > 0) {
            if (this.step > 0) {
                // positive step
                return this.start + (size - 1) * this.step;
            } else {
                // negative step
                return this.start;
            }
        } else {
            return undefined;
        }
    };
    /**
   * Execute a callback function for each value in the range.
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Range being traversed.
   */ Range.prototype.forEach = function(callback) {
        var x = this.start;
        var step = this.step;
        var end = this.end;
        var i = 0;
        if (step > 0) {
            while(x < end){
                callback(x, [
                    i
                ], this);
                x += step;
                i++;
            }
        } else if (step < 0) {
            while(x > end){
                callback(x, [
                    i
                ], this);
                x += step;
                i++;
            }
        }
    };
    /**
   * Execute a callback function for each value in the Range, and return the
   * results as an array
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @returns {Array} array
   */ Range.prototype.map = function(callback) {
        var array = [];
        this.forEach(function(value, index, obj) {
            array[index[0]] = callback(value, index, obj);
        });
        return array;
    };
    /**
   * Create an Array with a copy of the Ranges data
   * @memberof Range
   * @returns {Array} array
   */ Range.prototype.toArray = function() {
        var array = [];
        this.forEach(function(value, index) {
            array[index[0]] = value;
        });
        return array;
    };
    /**
   * Get the primitive value of the Range, a one dimensional array
   * @memberof Range
   * @returns {Array} array
   */ Range.prototype.valueOf = function() {
        // TODO: implement a caching mechanism for range.valueOf()
        return this.toArray();
    };
    /**
   * Get a string representation of the range, with optional formatting options.
   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
   * @memberof Range
   * @param {Object | number | function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */ Range.prototype.format = function(options) {
        var str = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.start, options);
        if (this.step !== 1) {
            str += ':' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.step, options);
        }
        str += ':' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.end, options);
        return str;
    };
    /**
   * Get a string representation of the range.
   * @memberof Range
   * @returns {string}
   */ Range.prototype.toString = function() {
        return this.format();
    };
    /**
   * Get a JSON representation of the range
   * @memberof Range
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   */ Range.prototype.toJSON = function() {
        return {
            mathjs: 'Range',
            start: this.start,
            end: this.end,
            step: this.step
        };
    };
    /**
   * Instantiate a Range from a JSON object
   * @memberof Range
   * @param {Object} json A JSON object structured as:
   *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   * @return {Range}
   */ Range.fromJSON = function(json) {
        return new Range(json.start, json.end, json.step);
    };
    return Range;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/resultset/ResultSet.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createResultSet": (()=>createResultSet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'ResultSet';
var dependencies = [];
var createResultSet = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, ()=>{
    /**
   * A ResultSet contains a list or results
   * @class ResultSet
   * @param {Array} entries
   * @constructor ResultSet
   */ function ResultSet(entries) {
        if (!(this instanceof ResultSet)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        this.entries = entries || [];
    }
    /**
   * Attach type information
   */ ResultSet.prototype.type = 'ResultSet';
    ResultSet.prototype.isResultSet = true;
    /**
   * Returns the array with results hold by this ResultSet
   * @memberof ResultSet
   * @returns {Array} entries
   */ ResultSet.prototype.valueOf = function() {
        return this.entries;
    };
    /**
   * Returns the stringified results of the ResultSet
   * @memberof ResultSet
   * @returns {string} string
   */ ResultSet.prototype.toString = function() {
        return '[' + this.entries.map(String).join(', ') + ']';
    };
    /**
   * Get a JSON representation of the ResultSet
   * @memberof ResultSet
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "ResultSet", "entries": [...]}`
   */ ResultSet.prototype.toJSON = function() {
        return {
            mathjs: 'ResultSet',
            entries: this.entries
        };
    };
    /**
   * Instantiate a ResultSet from a JSON object
   * @memberof ResultSet
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "ResultSet", "entries": [...]}`
   * @return {ResultSet}
   */ ResultSet.fromJSON = function(json) {
        return new ResultSet(json.entries);
    };
    return ResultSet;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deno-lint-ignore-file no-this-alias
__turbopack_context__.s({
    "createDenseMatrixClass": (()=>createDenseMatrixClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'DenseMatrix';
var dependencies = [
    'Matrix'
];
var createDenseMatrixClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { Matrix } = _ref;
    /**
   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
   * @class DenseMatrix
   * @enum {{ value, index: number[] }}
   */ function DenseMatrix(data, datatype) {
        if (!(this instanceof DenseMatrix)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(datatype)) {
            throw new Error('Invalid datatype: ' + datatype);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(data)) {
            // check data is a DenseMatrix
            if (data.type === 'DenseMatrix') {
                // clone data & size
                this._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(data._data);
                this._size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(data._size);
                this._datatype = datatype || data._datatype;
            } else {
                // build data from existing matrix
                this._data = data.toArray();
                this._size = data.size();
                this._datatype = datatype || data._datatype;
            }
        } else if (data && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.data) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.size)) {
            // initialize fields from JSON representation
            this._data = data.data;
            this._size = data.size;
            // verify the dimensions of the array
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(this._data, this._size);
            this._datatype = datatype || data.datatype;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data)) {
            // replace nested Matrices with Arrays
            this._data = preprocess(data);
            // get the dimensions of the array
            this._size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraySize"])(this._data);
            // verify the dimensions of the array, TODO: compute size while processing array
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(this._data, this._size);
            // data type unknown
            this._datatype = datatype;
        } else if (data) {
            // unsupported type
            throw new TypeError('Unsupported type of data (' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(data) + ')');
        } else {
            // nothing provided
            this._data = [];
            this._size = [
                0
            ];
            this._datatype = datatype;
        }
    }
    DenseMatrix.prototype = new Matrix();
    /**
   * Create a new DenseMatrix
   */ DenseMatrix.prototype.createDenseMatrix = function(data, datatype) {
        return new DenseMatrix(data, datatype);
    };
    /**
   * Attach type information
   */ Object.defineProperty(DenseMatrix, 'name', {
        value: 'DenseMatrix'
    });
    DenseMatrix.prototype.constructor = DenseMatrix;
    DenseMatrix.prototype.type = 'DenseMatrix';
    DenseMatrix.prototype.isDenseMatrix = true;
    /**
   * Get the matrix type
   *
   * Usage:
   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
   *
   * @memberOf DenseMatrix
   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
   */ DenseMatrix.prototype.getDataType = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getArrayDataType"])(this._data, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"]);
    };
    /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()  // retrieve storage format
   *
   * @memberof DenseMatrix
   * @return {string}           The storage format.
   */ DenseMatrix.prototype.storage = function() {
        return 'dense';
    };
    /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()   // retrieve matrix datatype
   *
   * @memberof DenseMatrix
   * @return {string}           The datatype.
   */ DenseMatrix.prototype.datatype = function() {
        return this._datatype;
    };
    /**
   * Create a new DenseMatrix
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */ DenseMatrix.prototype.create = function(data, datatype) {
        return new DenseMatrix(data, datatype);
    };
    /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof DenseMatrix
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */ DenseMatrix.prototype.subset = function(index, replacement, defaultValue) {
        switch(arguments.length){
            case 1:
                return _get(this, index);
            // intentional fall through
            case 2:
            case 3:
                return _set(this, index, replacement, defaultValue);
            default:
                throw new SyntaxError('Wrong number of arguments');
        }
    };
    /**
   * Get a single element from the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */ DenseMatrix.prototype.get = function(index) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["get"])(this._data, index);
    };
    /**
   * Replace a single element in the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {DenseMatrix} self
   */ DenseMatrix.prototype.set = function(index, value, defaultValue) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(index)) {
            throw new TypeError('Array expected');
        }
        if (index.length < this._size.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](index.length, this._size.length, '<');
        }
        var i, ii, indexI;
        // enlarge matrix when needed
        var size = index.map(function(i) {
            return i + 1;
        });
        _fit(this, size, defaultValue);
        // traverse over the dimensions
        var data = this._data;
        for(i = 0, ii = index.length - 1; i < ii; i++){
            indexI = index[i];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(indexI, data.length);
            data = data[indexI];
        }
        // set new value
        indexI = index[index.length - 1];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(indexI, data.length);
        data[indexI] = value;
        return this;
    };
    /**
   * Get a submatrix of this matrix
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index   Zero-based index
   * @private
   */ function _get(matrix, index) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndex"])(index)) {
            throw new TypeError('Invalid index');
        }
        var isScalar = index.isScalar();
        if (isScalar) {
            // return a scalar
            return matrix.get(index.min());
        } else {
            // validate dimensions
            var size = index.size();
            if (size.length !== matrix._size.length) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](size.length, matrix._size.length);
            }
            // validate if any of the ranges in the index is out of range
            var min = index.min();
            var max = index.max();
            for(var i = 0, ii = matrix._size.length; i < ii; i++){
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(min[i], matrix._size[i]);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(max[i], matrix._size[i]);
            }
            // retrieve submatrix
            var returnMatrix = new DenseMatrix([]);
            var submatrix = _getSubmatrix(matrix._data, index);
            returnMatrix._size = submatrix.size;
            returnMatrix._datatype = matrix._datatype;
            returnMatrix._data = submatrix.data;
            return returnMatrix;
        }
    }
    /**
   * Get a submatrix of a multi dimensional matrix.
   * Index is not checked for correct number or length of dimensions.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @return {Array} submatrix
   * @private
   */ function _getSubmatrix(data, index) {
        var maxDepth = index.size().length - 1;
        var size = Array(maxDepth);
        return {
            data: getSubmatrixRecursive(data),
            size
        };
        "TURBOPACK unreachable";
        function getSubmatrixRecursive(data) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var ranges = index.dimension(depth);
            size[depth] = ranges.size()[0];
            if (depth < maxDepth) {
                return ranges.map((rangeIndex)=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(rangeIndex, data.length);
                    return getSubmatrixRecursive(data[rangeIndex], depth + 1);
                }).valueOf();
            } else {
                return ranges.map((rangeIndex)=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(rangeIndex, data.length);
                    return data[rangeIndex];
                }).valueOf();
            }
        }
    }
    /**
   * Replace a submatrix in this matrix
   * Indexes are zero-based.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index
   * @param {DenseMatrix | Array | *} submatrix
   * @param {*} defaultValue          Default value, filled in on new entries when
   *                                  the matrix is resized.
   * @return {DenseMatrix} matrix
   * @private
   */ function _set(matrix, index, submatrix, defaultValue) {
        if (!index || index.isIndex !== true) {
            throw new TypeError('Invalid index');
        }
        // get index size and check whether the index contains a single value
        var iSize = index.size();
        var isScalar = index.isScalar();
        // calculate the size of the submatrix, and convert it into an Array if needed
        var sSize;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(submatrix)) {
            sSize = submatrix.size();
            submatrix = submatrix.valueOf();
        } else {
            sSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraySize"])(submatrix);
        }
        if (isScalar) {
            // set a scalar
            // check whether submatrix is a scalar
            if (sSize.length !== 0) {
                throw new TypeError('Scalar expected');
            }
            matrix.set(index.min(), submatrix, defaultValue);
        } else {
            // set a submatrix
            // broadcast submatrix
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepStrictEqual"])(sSize, iSize)) {
                try {
                    if (sSize.length === 0) {
                        submatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastTo"])([
                            submatrix
                        ], iSize);
                    } else {
                        submatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastTo"])(submatrix, iSize);
                    }
                    sSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraySize"])(submatrix);
                } catch (_unused) {}
            }
            // validate dimensions
            if (iSize.length < matrix._size.length) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](iSize.length, matrix._size.length, '<');
            }
            if (sSize.length < iSize.length) {
                // calculate number of missing outer dimensions
                var i = 0;
                var outer = 0;
                while(iSize[i] === 1 && sSize[i] === 1){
                    i++;
                }
                while(iSize[i] === 1){
                    outer++;
                    i++;
                }
                // unsqueeze both outer and inner dimensions
                submatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsqueeze"])(submatrix, iSize.length, outer, sSize);
            }
            // check whether the size of the submatrix matches the index size
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepStrictEqual"])(iSize, sSize)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](iSize, sSize, '>');
            }
            // enlarge matrix when needed
            var size = index.max().map(function(i) {
                return i + 1;
            });
            _fit(matrix, size, defaultValue);
            // insert the sub matrix
            _setSubmatrix(matrix._data, index, submatrix);
        }
        return matrix;
    }
    /**
   * Replace a submatrix of a multi dimensional matrix.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @param {Array} submatrix
   * @private
   */ function _setSubmatrix(data, index, submatrix) {
        var maxDepth = index.size().length - 1;
        setSubmatrixRecursive(data, submatrix);
        function setSubmatrixRecursive(data, submatrix) {
            var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var range = index.dimension(depth);
            if (depth < maxDepth) {
                range.forEach((rangeIndex, i)=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(rangeIndex, data.length);
                    setSubmatrixRecursive(data[rangeIndex], submatrix[i[0]], depth + 1);
                });
            } else {
                range.forEach((rangeIndex, i)=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(rangeIndex, data.length);
                    data[rangeIndex] = submatrix[i[0]];
                });
            }
        }
    }
    /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof DenseMatrix
   * @param {number[] || Matrix} size The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */ DenseMatrix.prototype.resize = function(size, defaultValue, copy) {
        // validate arguments
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCollection"])(size)) {
            throw new TypeError('Array or Matrix expected');
        }
        // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
        var sizeArray = size.valueOf().map((value)=>{
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        // matrix to resize
        var m = copy ? this.clone() : this;
        // resize matrix
        return _resize(m, sizeArray, defaultValue);
    };
    function _resize(matrix, size, defaultValue) {
        // check size
        if (size.length === 0) {
            // first value in matrix
            var v = matrix._data;
            // go deep
            while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(v)){
                v = v[0];
            }
            return v;
        }
        // resize matrix
        matrix._size = size.slice(0); // copy the array
        matrix._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resize"])(matrix._data, matrix._size, defaultValue);
        // return matrix
        return matrix;
    }
    /**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * NOTE: This might be better suited to copy by default, instead of modifying
   *       in place. For now, it operates in place to remain consistent with
   *       resize().
   *
   * @memberof DenseMatrix
   * @param {number[]} size           The new size the matrix should have.
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */ DenseMatrix.prototype.reshape = function(size, copy) {
        var m = copy ? this.clone() : this;
        m._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reshape"])(m._data, size);
        var currentLength = m._size.reduce((length, size)=>length * size);
        m._size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processSizesWildcard"])(size, currentLength);
        return m;
    };
    /**
   * Enlarge the matrix when it is smaller than given size.
   * If the matrix is larger or equal sized, nothing is done.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix           The matrix to be resized
   * @param {number[]} size
   * @param {*} defaultValue          Default value, filled in on new entries.
   * @private
   */ function _fit(matrix, size, defaultValue) {
        var // copy the array
        newSize = matrix._size.slice(0);
        var changed = false;
        // add dimensions when needed
        while(newSize.length < size.length){
            newSize.push(0);
            changed = true;
        }
        // enlarge size when needed
        for(var i = 0, ii = size.length; i < ii; i++){
            if (size[i] > newSize[i]) {
                newSize[i] = size[i];
                changed = true;
            }
        }
        if (changed) {
            // resize only when size is changed
            _resize(matrix, newSize, defaultValue);
        }
    }
    /**
   * Create a clone of the matrix
   * @memberof DenseMatrix
   * @return {DenseMatrix} clone
   */ DenseMatrix.prototype.clone = function() {
        var m = new DenseMatrix({
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._data),
            size: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._size),
            datatype: this._datatype
        });
        return m;
    };
    /**
   * Retrieve the size of the matrix.
   * @memberof DenseMatrix
   * @returns {number[]} size
   */ DenseMatrix.prototype.size = function() {
        return this._size.slice(0); // return a clone of _size
    };
    /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries
   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter
   *
   * @return {DenseMatrix} matrix
   */ DenseMatrix.prototype.map = function(callback) {
        var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var me = this;
        var maxDepth = me._size.length - 1;
        if (maxDepth < 0) return me.clone();
        var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, me, 'map', isUnary);
        var fastCallbackFn = fastCallback.fn;
        var result = me.create(undefined, me._datatype);
        result._size = me._size;
        if (isUnary || fastCallback.isUnary) {
            result._data = iterateUnary(me._data);
            return result;
        }
        if (maxDepth === 0) {
            var inputData = me.valueOf();
            var data = Array(inputData.length);
            for(var i = 0; i < inputData.length; i++){
                data[i] = fastCallbackFn(inputData[i], [
                    i
                ], me);
            }
            result._data = data;
            return result;
        }
        var index = [];
        result._data = iterate(me._data);
        return result;
        "TURBOPACK unreachable";
        function iterate(data) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var result = Array(data.length);
            if (depth < maxDepth) {
                for(var _i = 0; _i < data.length; _i++){
                    index[depth] = _i;
                    result[_i] = iterate(data[_i], depth + 1);
                }
            } else {
                for(var _i2 = 0; _i2 < data.length; _i2++){
                    index[depth] = _i2;
                    result[_i2] = fastCallbackFn(data[_i2], index.slice(), me);
                }
            }
            return result;
        }
        function iterateUnary(data) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var result = Array(data.length);
            if (depth < maxDepth) {
                for(var _i3 = 0; _i3 < data.length; _i3++){
                    result[_i3] = iterateUnary(data[_i3], depth + 1);
                }
            } else {
                for(var _i4 = 0; _i4 < data.length; _i4++){
                    result[_i4] = fastCallbackFn(data[_i4]);
                }
            }
            return result;
        }
    };
    /**
   * Execute a callback function on each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries
   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter
   */ DenseMatrix.prototype.forEach = function(callback) {
        var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var me = this;
        var maxDepth = me._size.length - 1;
        if (maxDepth < 0) return;
        var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, me, 'map', isUnary);
        var fastCallbackFn = fastCallback.fn;
        if (isUnary || fastCallback.isUnary) {
            iterateUnary(me._data);
            return;
        }
        if (maxDepth === 0) {
            for(var i = 0; i < me._data.length; i++){
                fastCallbackFn(me._data[i], [
                    i
                ], me);
            }
            return;
        }
        var index = [];
        iterate(me._data);
        function iterate(data) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (depth < maxDepth) {
                for(var _i5 = 0; _i5 < data.length; _i5++){
                    index[depth] = _i5;
                    iterate(data[_i5], depth + 1);
                }
            } else {
                for(var _i6 = 0; _i6 < data.length; _i6++){
                    index[depth] = _i6;
                    fastCallbackFn(data[_i6], index.slice(), me);
                }
            }
        }
        function iterateUnary(data) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (depth < maxDepth) {
                for(var _i7 = 0; _i7 < data.length; _i7++){
                    iterateUnary(data[_i7], depth + 1);
                }
            } else {
                for(var _i8 = 0; _i8 < data.length; _i8++){
                    fastCallbackFn(data[_i8]);
                }
            }
        }
    };
    /**
   * Iterate over the matrix elements
   * @return {Iterable<{ value, index: number[] }>}
   */ DenseMatrix.prototype[Symbol.iterator] = function*() {
        var maxDepth = this._size.length - 1;
        if (maxDepth < 0) {
            return;
        }
        if (maxDepth === 0) {
            for(var i = 0; i < this._data.length; i++){
                yield {
                    value: this._data[i],
                    index: [
                        i
                    ]
                };
            }
            return;
        }
        // Multi-dimensional matrix: iterate over all elements
        var index = Array(maxDepth + 1).fill(0);
        var totalElements = this._size.reduce((a, b)=>a * b, 1);
        for(var count = 0; count < totalElements; count++){
            // Traverse to the current element using indices
            var current = this._data;
            for(var d = 0; d < maxDepth; d++){
                current = current[index[d]];
            }
            yield {
                value: current[index[maxDepth]],
                index: index.slice()
            };
            // Increment indices for next element
            for(var _d = maxDepth; _d >= 0; _d--){
                index[_d]++;
                if (index[_d] < this._size[_d]) break;
                index[_d] = 0;
            }
        }
    };
    /**
   * Returns an array containing the rows of a 2D matrix
   * @returns {Array<Matrix>}
   */ DenseMatrix.prototype.rows = function() {
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
            throw new TypeError('Rows can only be returned for a 2D matrix.');
        }
        var data = this._data;
        for (var row of data){
            result.push(new DenseMatrix([
                row
            ], this._datatype));
        }
        return result;
    };
    /**
   * Returns an array containing the columns of a 2D matrix
   * @returns {Array<Matrix>}
   */ DenseMatrix.prototype.columns = function() {
        var _this = this;
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
            throw new TypeError('Rows can only be returned for a 2D matrix.');
        }
        var data = this._data;
        var _loop = function _loop(i) {
            var col = data.map((row)=>[
                    row[i]
                ]);
            result.push(new DenseMatrix(col, _this._datatype));
        };
        for(var i = 0; i < s[1]; i++){
            _loop(i);
        }
        return result;
    };
    /**
   * Create an Array with a copy of the data of the DenseMatrix
   * @memberof DenseMatrix
   * @returns {Array} array
   */ DenseMatrix.prototype.toArray = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._data);
    };
    /**
   * Get the primitive value of the DenseMatrix: a multidimensional array
   * @memberof DenseMatrix
   * @returns {Array} array
   */ DenseMatrix.prototype.valueOf = function() {
        return this._data;
    };
    /**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof DenseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */ DenseMatrix.prototype.format = function(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this._data, options);
    };
    /**
   * Get a string representation of the matrix
   * @memberof DenseMatrix
   * @returns {string} str
   */ DenseMatrix.prototype.toString = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this._data);
    };
    /**
   * Get a JSON representation of the matrix
   * @memberof DenseMatrix
   * @returns {Object}
   */ DenseMatrix.prototype.toJSON = function() {
        return {
            mathjs: 'DenseMatrix',
            data: this._data,
            size: this._size,
            datatype: this._datatype
        };
    };
    /**
   * Get the kth Matrix diagonal.
   *
   * @memberof DenseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Matrix}                     The matrix with the diagonal values.
   */ DenseMatrix.prototype.diagonal = function(k) {
        // validate k if any
        if (k) {
            // convert BigNumber to a number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(k)) {
                k = k.toNumber();
            }
            // is must be an integer
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(k) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(k)) {
                throw new TypeError('The parameter k must be an integer number');
            }
        } else {
            // default value
            k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        // rows & columns
        var rows = this._size[0];
        var columns = this._size[1];
        // number diagonal values
        var n = Math.min(rows - kSub, columns - kSuper);
        // x is a matrix get diagonal from matrix
        var data = [];
        // loop rows
        for(var i = 0; i < n; i++){
            data[i] = this._data[i + kSub][i + kSuper];
        }
        // create DenseMatrix
        return new DenseMatrix({
            data,
            size: [
                n
            ],
            datatype: this._datatype
        });
    };
    /**
   * Create a diagonal matrix.
   *
   * @memberof DenseMatrix
   * @param {Array} size                     The matrix size.
   * @param {number | Matrix | Array } value The values for the diagonal.
   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
   * @param {number} [defaultValue]          The default value for non-diagonal
   * @param {string} [datatype]              The datatype for the diagonal
   *
   * @returns {DenseMatrix}
   */ DenseMatrix.diagonal = function(size, value, k, defaultValue) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(size)) {
            throw new TypeError('Array expected, size parameter');
        }
        if (size.length !== 2) {
            throw new Error('Only two dimensions matrix are supported');
        }
        // map size & validate
        size = size.map(function(s) {
            // check it is a big number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(s)) {
                // convert it
                s = s.toNumber();
            }
            // validate arguments
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(s) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(s) || s < 1) {
                throw new Error('Size values must be positive integers');
            }
            return s;
        });
        // validate k if any
        if (k) {
            // convert BigNumber to a number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(k)) {
                k = k.toNumber();
            }
            // is must be an integer
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(k) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(k)) {
                throw new TypeError('The parameter k must be an integer number');
            }
        } else {
            // default value
            k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        // rows and columns
        var rows = size[0];
        var columns = size[1];
        // number of non-zero items
        var n = Math.min(rows - kSub, columns - kSuper);
        // value extraction function
        var _value;
        // check value
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(value)) {
            // validate array
            if (value.length !== n) {
                // number of values in array must be n
                throw new Error('Invalid value array length');
            }
            // define function
            _value = function _value(i) {
                // return value @ i
                return value[i];
            };
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(value)) {
            // matrix size
            var ms = value.size();
            // validate matrix
            if (ms.length !== 1 || ms[0] !== n) {
                // number of values in array must be n
                throw new Error('Invalid matrix length');
            }
            // define function
            _value = function _value(i) {
                // return value @ i
                return value.get([
                    i
                ]);
            };
        } else {
            // define function
            _value = function _value() {
                // return value
                return value;
            };
        }
        // discover default value if needed
        if (!defaultValue) {
            // check first value in array
            defaultValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
             : 0;
        }
        // empty array
        var data = [];
        // check we need to resize array
        if (size.length > 0) {
            // resize array
            data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resize"])(data, size, defaultValue);
            // fill diagonal
            for(var d = 0; d < n; d++){
                data[d + kSub][d + kSuper] = _value(d);
            }
        }
        // create DenseMatrix
        return new DenseMatrix({
            data,
            size: [
                rows,
                columns
            ]
        });
    };
    /**
   * Generate a matrix from a JSON object
   * @memberof DenseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {DenseMatrix}
   */ DenseMatrix.fromJSON = function(json) {
        return new DenseMatrix(json);
    };
    /**
   * Swap rows i and j in Matrix.
   *
   * @memberof DenseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */ DenseMatrix.prototype.swapRows = function(i, j) {
        // check index
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(i) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(i) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(j) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(j)) {
            throw new Error('Row index must be positive integers');
        }
        // check dimensions
        if (this._size.length !== 2) {
            throw new Error('Only two dimensional matrix is supported');
        }
        // validate index
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(i, this._size[0]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(j, this._size[0]);
        // swap rows
        DenseMatrix._swapRows(i, j, this._data);
        // return current instance
        return this;
    };
    /**
   * Swap rows i and j in Dense Matrix data structure.
   *
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   * @param {Array} data     Matrix data
   */ DenseMatrix._swapRows = function(i, j, data) {
        // swap values i <-> j
        var vi = data[i];
        data[i] = data[j];
        data[j] = vi;
    };
    /**
   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
   * Matrices. Clones all (nested) Arrays, and replaces all nested Matrices with Arrays
   * @memberof DenseMatrix
   * @param {Array | Matrix} data
   * @return {Array} data
   */ function preprocess(data) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(data)) {
            return preprocess(data.valueOf());
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data)) {
            return data.map(preprocess);
        }
        return data;
    }
    return DenseMatrix;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/bigint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBigint": (()=>createBigint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'bigint';
var dependencies = [
    'typed'
];
var createBigint = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Create a bigint or convert a string, boolean, or unit to a bigint.
   * When value is a matrix, all elements will be converted to bigint.
   *
   * Syntax:
   *
   *    math.bigint(value)
   *
   * Examples:
   *
   *    math.bigint(2)                         // returns 2n
   *    math.bigint('123')                     // returns 123n
   *    math.bigint(true)                      // returns 1n
   *    math.bigint([true, false, true, true]) // returns [1n, 0n, 1n, 1n]
   *
   * See also:
   *
   *    number, bignumber, boolean, complex, index, matrix, string, unit
   *
   * @param {string | number | BigNumber | bigint | Fraction | boolean | Array | Matrix | null} [value]  Value to be converted
   * @return {bigint | Array | Matrix} The created bigint
   */ var bigint = typed('bigint', {
        '': function _() {
            return 0n;
        },
        bigint: function bigint(x) {
            return x;
        },
        number: function number(x) {
            return BigInt(x.toFixed());
        },
        BigNumber: function BigNumber(x) {
            return BigInt(x.round().toString());
        },
        Fraction: function Fraction(x) {
            return BigInt(x.valueOf().toFixed());
        },
        'string | boolean': function string__boolean(x) {
            return BigInt(x);
        },
        null: function _null(x) {
            return 0n;
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
    // reviver function to parse a JSON object like:
    //
    //     {"mathjs":"bigint","value":"123"}
    //
    // into a bigint 123n
    bigint.fromJSON = function(json) {
        return BigInt(json.value);
    };
    return bigint;
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/boolean.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBoolean": (()=>createBoolean)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'boolean';
var dependencies = [
    'typed'
];
var createBoolean = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Create a boolean or convert a string or number to a boolean.
   * In case of a number, `true` is returned for non-zero numbers, and `false` in
   * case of zero.
   * Strings can be `'true'` or `'false'`, or can contain a number.
   * When value is a matrix, all elements will be converted to boolean.
   *
   * Syntax:
   *
   *    math.boolean(x)
   *
   * Examples:
   *
   *    math.boolean(0)     // returns false
   *    math.boolean(1)     // returns true
   *    math.boolean(-3)     // returns true
   *    math.boolean('true')     // returns true
   *    math.boolean('false')     // returns false
   *    math.boolean([1, 0, 1, 1])     // returns [true, false, true, true]
   *
   * See also:
   *
   *    bignumber, complex, index, matrix, string, unit
   *
   * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
   * @return {boolean | Array | Matrix} The boolean value
   */ return typed(name, {
        '': function _() {
            return false;
        },
        boolean: function boolean(x) {
            return x;
        },
        number: function number(x) {
            return !!x;
        },
        null: function _null(x) {
            return false;
        },
        BigNumber: function BigNumber(x) {
            return !x.isZero();
        },
        string: function string(x) {
            // try case insensitive
            var lcase = x.toLowerCase();
            if (lcase === 'true') {
                return true;
            } else if (lcase === 'false') {
                return false;
            }
            // test whether value is a valid number
            var num = Number(x);
            if (x !== '' && !isNaN(num)) {
                return !!num;
            }
            throw new Error('Cannot convert "' + x + '" to a boolean');
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/complex/function/complex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createComplex": (()=>createComplex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'complex';
var dependencies = [
    'typed',
    'Complex'
];
var createComplex = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Complex } = _ref;
    /**
   * Create a complex value or convert a value to a complex value.
   *
   * Syntax:
   *
   *     math.complex()                           // creates a complex value with zero
   *                                              // as real and imaginary part.
   *     math.complex(re : number, im : string)   // creates a complex value with provided
   *                                              // values for real and imaginary part.
   *     math.complex(re : number)                // creates a complex value with provided
   *                                              // real value and zero imaginary part.
   *     math.complex(complex : Complex)          // clones the provided complex value.
   *     math.complex(arg : string)               // parses a string into a complex value.
   *     math.complex(array : Array)              // converts the elements of the array
   *                                              // or matrix element wise into a
   *                                              // complex value.
   *     math.complex({re: number, im: number})   // creates a complex value with provided
   *                                              // values for real an imaginary part.
   *     math.complex({r: number, phi: number})   // creates a complex value with provided
   *                                              // polar coordinates
   *
   * Examples:
   *
   *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
   *    a.re = 5                          // a = Complex 5 - 4i
   *    const i = a.im                    // Number -4
   *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
   *    const c = math.complex()          // Complex 0 + 0i
   *    const d = math.add(a, b)          // Complex 5 + 2i
   *
   * See also:
   *
   *    bignumber, boolean, index, matrix, number, string, unit
   *
   * @param {* | Array | Matrix} [args]
   *            Arguments specifying the real and imaginary part of the complex number
   * @return {Complex | Array | Matrix} Returns a complex value
   */ return typed('complex', {
        '': function _() {
            return Complex.ZERO;
        },
        number: function number(x) {
            return new Complex(x, 0);
        },
        'number, number': function number_number(re, im) {
            return new Complex(re, im);
        },
        // TODO: this signature should be redundant
        'BigNumber, BigNumber': function BigNumber_BigNumber(re, im) {
            return new Complex(re.toNumber(), im.toNumber());
        },
        Fraction: function Fraction(x) {
            return new Complex(x.valueOf(), 0);
        },
        Complex: function Complex(x) {
            return x.clone();
        },
        string: function string(x) {
            return Complex(x); // for example '2 + 3i'
        },
        null: function _null(x) {
            return Complex(0);
        },
        Object: function Object(x) {
            if ('re' in x && 'im' in x) {
                return new Complex(x.re, x.im);
            }
            if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
                return new Complex(x);
            }
            throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/number.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNumber": (()=>createNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'number';
var dependencies = [
    'typed'
];
/**
 * Separates the radix, integer part, and fractional part of a non decimal number string
 * @param {string} input string to parse
 * @returns {object} the parts of the string or null if not a valid input
 */ function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
        var radix = {
            '0b': 2,
            '0o': 8,
            '0x': 16
        }[nonDecimalWithRadixMatch[1]];
        var integerPart = nonDecimalWithRadixMatch[2];
        var fractionalPart = nonDecimalWithRadixMatch[3];
        return {
            input,
            radix,
            integerPart,
            fractionalPart
        };
    } else {
        return null;
    }
}
/**
 * Makes a number from a radix, and integer part, and a fractional part
 * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
 * @returns {number} the number
 */ function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for(var i = 0; i < parts.fractionalPart.length; i++){
        var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
        f += digitValue / Math.pow(parts.radix, i + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
        throw new SyntaxError('String "' + parts.input + '" is not a valid number');
    }
    return result;
}
var createNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Create a number or convert a string, boolean, or unit to a number.
   * When value is a matrix, all elements will be converted to number.
   *
   * Syntax:
   *
   *    math.number(value)
   *    math.number(unit, valuelessUnit)
   *
   * Examples:
   *
   *    math.number(2)                         // returns number 2
   *    math.number('7.2')                     // returns number 7.2
   *    math.number(true)                      // returns number 1
   *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
   *    math.number(math.unit('52cm'), 'm')    // returns 0.52
   *
   * See also:
   *
   *    bignumber, bigint, boolean, numeric, complex, index, matrix, string, unit
   *
   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
   * @return {number | Array | Matrix} The created number
   */ var number = typed('number', {
        '': function _() {
            return 0;
        },
        number: function number(x) {
            return x;
        },
        string: function string(x) {
            if (x === 'NaN') return NaN;
            var nonDecimalNumberParts = getNonDecimalNumberParts(x);
            if (nonDecimalNumberParts) {
                return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
            }
            var size = 0;
            var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
                // x includes a size suffix like 0xffffi32, so we extract
                // the suffix and remove it from x
                size = Number(wordSizeSuffixMatch[2]);
                x = wordSizeSuffixMatch[1];
            }
            var num = Number(x);
            if (isNaN(num)) {
                throw new SyntaxError('String "' + x + '" is not a valid number');
            }
            if (wordSizeSuffixMatch) {
                // x is a signed bin, oct, or hex literal
                // num is the value of string x if x is interpreted as unsigned
                if (num > 2 ** size - 1) {
                    // literal is too large for size suffix
                    throw new SyntaxError("String \"".concat(x, "\" is out of range"));
                }
                // check if the bit at index size - 1 is set and if so do the twos complement
                if (num >= 2 ** (size - 1)) {
                    num = num - 2 ** size;
                }
            }
            return num;
        },
        BigNumber: function BigNumber(x) {
            return x.toNumber();
        },
        bigint: function bigint(x) {
            return Number(x);
        },
        Fraction: function Fraction(x) {
            return x.valueOf();
        },
        Unit: typed.referToSelf((self)=>(x)=>{
                var clone = x.clone();
                clone.value = self(x.value);
                return clone;
            }),
        null: function _null(x) {
            return 0;
        },
        'Unit, string | Unit': function Unit_string__Unit(unit, valuelessUnit) {
            return unit.toNumber(valuelessUnit);
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
    // reviver function to parse a JSON object like:
    //
    //     {"mathjs":"number","value":"2.3"}
    //
    // into a number 2.3
    number.fromJSON = function(json) {
        return parseFloat(json.value);
    };
    return number;
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSparseMatrixClass": (()=>createSparseMatrixClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/optimizeCallback.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'SparseMatrix';
var dependencies = [
    'typed',
    'equalScalar',
    'Matrix'
];
var createSparseMatrixClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar, Matrix } = _ref;
    /**
   * Sparse Matrix implementation. This type implements
   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
   * format for two-dimensional sparse matrices.
   * @class SparseMatrix
   */ function SparseMatrix(data, datatype) {
        if (!(this instanceof SparseMatrix)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(datatype)) {
            throw new Error('Invalid datatype: ' + datatype);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(data)) {
            // create from matrix
            _createFromMatrix(this, data, datatype);
        } else if (data && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.index) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.ptr) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.size)) {
            // initialize fields
            this._values = data.values;
            this._index = data.index;
            this._ptr = data.ptr;
            this._size = data.size;
            this._datatype = datatype || data.datatype;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data)) {
            // create from array
            _createFromArray(this, data, datatype);
        } else if (data) {
            // unsupported type
            throw new TypeError('Unsupported type of data (' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(data) + ')');
        } else {
            // nothing provided
            this._values = [];
            this._index = [];
            this._ptr = [
                0
            ];
            this._size = [
                0,
                0
            ];
            this._datatype = datatype;
        }
    }
    function _createFromMatrix(matrix, source, datatype) {
        // check matrix type
        if (source.type === 'SparseMatrix') {
            // clone arrays
            matrix._values = source._values ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(source._values) : undefined;
            matrix._index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(source._index);
            matrix._ptr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(source._ptr);
            matrix._size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(source._size);
            matrix._datatype = datatype || source._datatype;
        } else {
            // build from matrix data
            _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
        }
    }
    function _createFromArray(matrix, data, datatype) {
        // initialize fields
        matrix._values = [];
        matrix._index = [];
        matrix._ptr = [];
        matrix._datatype = datatype;
        // discover rows & columns, do not use math.size() to avoid looping array twice
        var rows = data.length;
        var columns = 0;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(datatype)) {
            // find signature that matches (datatype, datatype)
            eq = typed.find(equalScalar, [
                datatype,
                datatype
            ]) || equalScalar;
            // convert 0 to the same datatype
            zero = typed.convert(0, datatype);
        }
        // check we have rows (empty array)
        if (rows > 0) {
            // column index
            var j = 0;
            do {
                // store pointer to values index
                matrix._ptr.push(matrix._index.length);
                // loop rows
                for(var i = 0; i < rows; i++){
                    // current row
                    var row = data[i];
                    // check row is an array
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(row)) {
                        // update columns if needed (only on first column)
                        if (j === 0 && columns < row.length) {
                            columns = row.length;
                        }
                        // check row has column
                        if (j < row.length) {
                            // value
                            var v = row[j];
                            // check value != 0
                            if (!eq(v, zero)) {
                                // store value
                                matrix._values.push(v);
                                // index
                                matrix._index.push(i);
                            }
                        }
                    } else {
                        // update columns if needed (only on first column)
                        if (j === 0 && columns < 1) {
                            columns = 1;
                        }
                        // check value != 0 (row is a scalar)
                        if (!eq(row, zero)) {
                            // store value
                            matrix._values.push(row);
                            // index
                            matrix._index.push(i);
                        }
                    }
                }
                // increment index
                j++;
            }while (j < columns)
        }
        // store number of values in ptr
        matrix._ptr.push(matrix._index.length);
        // size
        matrix._size = [
            rows,
            columns
        ];
    }
    SparseMatrix.prototype = new Matrix();
    /**
   * Create a new SparseMatrix
   */ SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
        return new SparseMatrix(data, datatype);
    };
    /**
   * Attach type information
   */ Object.defineProperty(SparseMatrix, 'name', {
        value: 'SparseMatrix'
    });
    SparseMatrix.prototype.constructor = SparseMatrix;
    SparseMatrix.prototype.type = 'SparseMatrix';
    SparseMatrix.prototype.isSparseMatrix = true;
    /**
   * Get the matrix type
   *
   * Usage:
   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
   *
   * @memberOf SparseMatrix
   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
   */ SparseMatrix.prototype.getDataType = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getArrayDataType"])(this._values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"]);
    };
    /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()   // retrieve storage format
   *
   * @memberof SparseMatrix
   * @return {string}           The storage format.
   */ SparseMatrix.prototype.storage = function() {
        return 'sparse';
    };
    /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()    // retrieve matrix datatype
   *
   * @memberof SparseMatrix
   * @return {string}           The datatype.
   */ SparseMatrix.prototype.datatype = function() {
        return this._datatype;
    };
    /**
   * Create a new SparseMatrix
   * @memberof SparseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */ SparseMatrix.prototype.create = function(data, datatype) {
        return new SparseMatrix(data, datatype);
    };
    /**
   * Get the matrix density.
   *
   * Usage:
   *     const density = matrix.density()                   // retrieve matrix density
   *
   * @memberof SparseMatrix
   * @return {number}           The matrix density.
   */ SparseMatrix.prototype.density = function() {
        // rows & columns
        var rows = this._size[0];
        var columns = this._size[1];
        // calculate density
        return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof SparseMatrix
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */ SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
        // check it is a pattern matrix
        if (!this._values) {
            throw new Error('Cannot invoke subset on a Pattern only matrix');
        }
        // check arguments
        switch(arguments.length){
            case 1:
                return _getsubset(this, index);
            // intentional fall through
            case 2:
            case 3:
                return _setsubset(this, index, replacement, defaultValue);
            default:
                throw new SyntaxError('Wrong number of arguments');
        }
    };
    function _getsubset(matrix, idx) {
        // check idx
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndex"])(idx)) {
            throw new TypeError('Invalid index');
        }
        var isScalar = idx.isScalar();
        if (isScalar) {
            // return a scalar
            return matrix.get(idx.min());
        }
        // validate dimensions
        var size = idx.size();
        if (size.length !== matrix._size.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](size.length, matrix._size.length);
        }
        // vars
        var i, ii, k, kk;
        // validate if any of the ranges in the index is out of range
        var min = idx.min();
        var max = idx.max();
        for(i = 0, ii = matrix._size.length; i < ii; i++){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(min[i], matrix._size[i]);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(max[i], matrix._size[i]);
        }
        // matrix arrays
        var mvalues = matrix._values;
        var mindex = matrix._index;
        var mptr = matrix._ptr;
        // rows & columns dimensions for result matrix
        var rows = idx.dimension(0);
        var columns = idx.dimension(1);
        // workspace & permutation vector
        var w = [];
        var pv = [];
        // loop rows in resulting matrix
        rows.forEach(function(i, r) {
            // update permutation vector
            pv[i] = r[0];
            // mark i in workspace
            w[i] = true;
        });
        // result matrix arrays
        var values = mvalues ? [] : undefined;
        var index = [];
        var ptr = [];
        // loop columns in result matrix
        columns.forEach(function(j) {
            // update ptr
            ptr.push(index.length);
            // loop values in column j
            for(k = mptr[j], kk = mptr[j + 1]; k < kk; k++){
                // row
                i = mindex[k];
                // check row is in result matrix
                if (w[i] === true) {
                    // push index
                    index.push(pv[i]);
                    // check we need to process values
                    if (values) {
                        values.push(mvalues[k]);
                    }
                }
            }
        });
        // update ptr
        ptr.push(index.length);
        // return matrix
        return new SparseMatrix({
            values,
            index,
            ptr,
            size,
            datatype: matrix._datatype
        });
    }
    function _setsubset(matrix, index, submatrix, defaultValue) {
        // check index
        if (!index || index.isIndex !== true) {
            throw new TypeError('Invalid index');
        }
        // get index size and check whether the index contains a single value
        var iSize = index.size();
        var isScalar = index.isScalar();
        // calculate the size of the submatrix, and convert it into an Array if needed
        var sSize;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(submatrix)) {
            // submatrix size
            sSize = submatrix.size();
            // use array representation
            submatrix = submatrix.toArray();
        } else {
            // get submatrix size (array, scalar)
            sSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraySize"])(submatrix);
        }
        // check index is a scalar
        if (isScalar) {
            // verify submatrix is a scalar
            if (sSize.length !== 0) {
                throw new TypeError('Scalar expected');
            }
            // set value
            matrix.set(index.min(), submatrix, defaultValue);
        } else {
            // validate dimensions, index size must be one or two dimensions
            if (iSize.length !== 1 && iSize.length !== 2) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](iSize.length, matrix._size.length, '<');
            }
            // check submatrix and index have the same dimensions
            if (sSize.length < iSize.length) {
                // calculate number of missing outer dimensions
                var i = 0;
                var outer = 0;
                while(iSize[i] === 1 && sSize[i] === 1){
                    i++;
                }
                while(iSize[i] === 1){
                    outer++;
                    i++;
                }
                // unsqueeze both outer and inner dimensions
                submatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsqueeze"])(submatrix, iSize.length, outer, sSize);
            }
            // check whether the size of the submatrix matches the index size
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepStrictEqual"])(iSize, sSize)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](iSize, sSize, '>');
            }
            // insert the sub matrix
            if (iSize.length === 1) {
                // if the replacement index only has 1 dimension, go trough each one and set its value
                var range = index.dimension(0);
                range.forEach(function(dataIndex, subIndex) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(dataIndex);
                    matrix.set([
                        dataIndex,
                        0
                    ], submatrix[subIndex[0]], defaultValue);
                });
            } else {
                // if the replacement index has 2 dimensions, go through each one and set the value in the correct index
                var firstDimensionRange = index.dimension(0);
                var secondDimensionRange = index.dimension(1);
                firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(firstDataIndex);
                    secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(secondDataIndex);
                        matrix.set([
                            firstDataIndex,
                            secondDataIndex
                        ], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
                    });
                });
            }
        }
        return matrix;
    }
    /**
   * Get a single element from the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */ SparseMatrix.prototype.get = function(index) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(index)) {
            throw new TypeError('Array expected');
        }
        if (index.length !== this._size.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](index.length, this._size.length);
        }
        // check it is a pattern matrix
        if (!this._values) {
            throw new Error('Cannot invoke get on a Pattern only matrix');
        }
        // row and column
        var i = index[0];
        var j = index[1];
        // check i, j are valid
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(i, this._size[0]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(j, this._size[1]);
        // find value index
        var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        // check k is prior to next column k and it is in the correct row
        if (k < this._ptr[j + 1] && this._index[k] === i) {
            return this._values[k];
        }
        return 0;
    };
    /**
   * Replace a single element in the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} v
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be set to zero.
   * @return {SparseMatrix} self
   */ SparseMatrix.prototype.set = function(index, v, defaultValue) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(index)) {
            throw new TypeError('Array expected');
        }
        if (index.length !== this._size.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](index.length, this._size.length);
        }
        // check it is a pattern matrix
        if (!this._values) {
            throw new Error('Cannot invoke set on a Pattern only matrix');
        }
        // row and column
        var i = index[0];
        var j = index[1];
        // rows & columns
        var rows = this._size[0];
        var columns = this._size[1];
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(this._datatype)) {
            // find signature that matches (datatype, datatype)
            eq = typed.find(equalScalar, [
                this._datatype,
                this._datatype
            ]) || equalScalar;
            // convert 0 to the same datatype
            zero = typed.convert(0, this._datatype);
        }
        // check we need to resize matrix
        if (i > rows - 1 || j > columns - 1) {
            // resize matrix
            _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
            // update rows & columns
            rows = this._size[0];
            columns = this._size[1];
        }
        // check i, j are valid
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(i, rows);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(j, columns);
        // find value index
        var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        // check k is prior to next column k and it is in the correct row
        if (k < this._ptr[j + 1] && this._index[k] === i) {
            // check value != 0
            if (!eq(v, zero)) {
                // update value
                this._values[k] = v;
            } else {
                // remove value from matrix
                _remove(k, j, this._values, this._index, this._ptr);
            }
        } else {
            if (!eq(v, zero)) {
                // insert value @ (i, j)
                _insert(k, i, j, v, this._values, this._index, this._ptr);
            }
        }
        return this;
    };
    function _getValueIndex(i, top, bottom, index) {
        // check row is on the bottom side
        if (bottom - top === 0) {
            return bottom;
        }
        // loop rows [top, bottom[
        for(var r = top; r < bottom; r++){
            // check we found value index
            if (index[r] === i) {
                return r;
            }
        }
        // we did not find row
        return top;
    }
    function _remove(k, j, values, index, ptr) {
        // remove value @ k
        values.splice(k, 1);
        index.splice(k, 1);
        // update pointers
        for(var x = j + 1; x < ptr.length; x++){
            ptr[x]--;
        }
    }
    function _insert(k, i, j, v, values, index, ptr) {
        // insert value
        values.splice(k, 0, v);
        // update row for k
        index.splice(k, 0, i);
        // update column pointers
        for(var x = j + 1; x < ptr.length; x++){
            ptr[x]++;
        }
    }
    /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof SparseMatrix
   * @param {number[] | Matrix} size  The new size the matrix should have.
   *                                  Since sparse matrices are always two-dimensional,
   *                                  size must be two numbers in either an array or a matrix
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */ SparseMatrix.prototype.resize = function(size, defaultValue, copy) {
        // validate arguments
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCollection"])(size)) {
            throw new TypeError('Array or Matrix expected');
        }
        // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
        var sizeArray = size.valueOf().map((value)=>{
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        if (sizeArray.length !== 2) {
            throw new Error('Only two dimensions matrix are supported');
        }
        // check sizes
        sizeArray.forEach(function(value) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(value) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(value) || value < 0) {
                throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(sizeArray) + ')');
            }
        });
        // matrix to resize
        var m = copy ? this.clone() : this;
        // resize matrix
        return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize(matrix, rows, columns, defaultValue) {
        // value to insert at the time of growing matrix
        var value = defaultValue || 0;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(matrix._datatype)) {
            // find signature that matches (datatype, datatype)
            eq = typed.find(equalScalar, [
                matrix._datatype,
                matrix._datatype
            ]) || equalScalar;
            // convert 0 to the same datatype
            zero = typed.convert(0, matrix._datatype);
            // convert value to the same datatype
            value = typed.convert(value, matrix._datatype);
        }
        // should we insert the value?
        var ins = !eq(value, zero);
        // old columns and rows
        var r = matrix._size[0];
        var c = matrix._size[1];
        var i, j, k;
        // check we need to increase columns
        if (columns > c) {
            // loop new columns
            for(j = c; j < columns; j++){
                // update matrix._ptr for current column
                matrix._ptr[j] = matrix._values.length;
                // check we need to insert matrix._values
                if (ins) {
                    // loop rows
                    for(i = 0; i < r; i++){
                        // add new matrix._values
                        matrix._values.push(value);
                        // update matrix._index
                        matrix._index.push(i);
                    }
                }
            }
            // store number of matrix._values in matrix._ptr
            matrix._ptr[columns] = matrix._values.length;
        } else if (columns < c) {
            // truncate matrix._ptr
            matrix._ptr.splice(columns + 1, c - columns);
            // truncate matrix._values and matrix._index
            matrix._values.splice(matrix._ptr[columns], matrix._values.length);
            matrix._index.splice(matrix._ptr[columns], matrix._index.length);
        }
        // update columns
        c = columns;
        // check we need to increase rows
        if (rows > r) {
            // check we have to insert values
            if (ins) {
                // inserts
                var n = 0;
                // loop columns
                for(j = 0; j < c; j++){
                    // update matrix._ptr for current column
                    matrix._ptr[j] = matrix._ptr[j] + n;
                    // where to insert matrix._values
                    k = matrix._ptr[j + 1] + n;
                    // pointer
                    var p = 0;
                    // loop new rows, initialize pointer
                    for(i = r; i < rows; i++, p++){
                        // add value
                        matrix._values.splice(k + p, 0, value);
                        // update matrix._index
                        matrix._index.splice(k + p, 0, i);
                        // increment inserts
                        n++;
                    }
                }
                // store number of matrix._values in matrix._ptr
                matrix._ptr[c] = matrix._values.length;
            }
        } else if (rows < r) {
            // deletes
            var d = 0;
            // loop columns
            for(j = 0; j < c; j++){
                // update matrix._ptr for current column
                matrix._ptr[j] = matrix._ptr[j] - d;
                // where matrix._values start for next column
                var k0 = matrix._ptr[j];
                var k1 = matrix._ptr[j + 1] - d;
                // loop matrix._index
                for(k = k0; k < k1; k++){
                    // row
                    i = matrix._index[k];
                    // check we need to delete value and matrix._index
                    if (i > rows - 1) {
                        // remove value
                        matrix._values.splice(k, 1);
                        // remove item from matrix._index
                        matrix._index.splice(k, 1);
                        // increase deletes
                        d++;
                    }
                }
            }
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._values.length;
        }
        // update matrix._size
        matrix._size[0] = rows;
        matrix._size[1] = columns;
        // return matrix
        return matrix;
    }
    /**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * NOTE: This might be better suited to copy by default, instead of modifying
   *       in place. For now, it operates in place to remain consistent with
   *       resize().
   *
   * @memberof SparseMatrix
   * @param {number[]} sizes          The new size the matrix should have.
   *                                  Since sparse matrices are always two-dimensional,
   *                                  size must be two numbers in either an array or a matrix
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */ SparseMatrix.prototype.reshape = function(sizes, copy) {
        // validate arguments
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(sizes)) {
            throw new TypeError('Array expected');
        }
        if (sizes.length !== 2) {
            throw new Error('Sparse matrices can only be reshaped in two dimensions');
        }
        // check sizes
        sizes.forEach(function(value) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(value) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(value) || value <= -2 || value === 0) {
                throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(sizes) + ')');
            }
        });
        var currentLength = this._size[0] * this._size[1];
        sizes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processSizesWildcard"])(sizes, currentLength);
        var newLength = sizes[0] * sizes[1];
        // m * n must not change
        if (currentLength !== newLength) {
            throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
        }
        // matrix to reshape
        var m = copy ? this.clone() : this;
        // return unchanged if the same shape
        if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
            return m;
        }
        // Convert to COO format (generate a column index)
        var colIndex = [];
        for(var i = 0; i < m._ptr.length; i++){
            for(var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++){
                colIndex.push(i);
            }
        }
        // Clone the values array
        var values = m._values.slice();
        // Clone the row index array
        var rowIndex = m._index.slice();
        // Transform the (row, column) indices
        for(var _i = 0; _i < m._index.length; _i++){
            var r1 = rowIndex[_i];
            var c1 = colIndex[_i];
            var flat = r1 * m._size[1] + c1;
            colIndex[_i] = flat % sizes[1];
            rowIndex[_i] = Math.floor(flat / sizes[1]);
        }
        // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
        // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
        // sorting several arrays based on some other array.
        // OR, we could easily just:
        // 1. Remove all values from the matrix
        m._values.length = 0;
        m._index.length = 0;
        m._ptr.length = sizes[1] + 1;
        m._size = sizes.slice();
        for(var _i2 = 0; _i2 < m._ptr.length; _i2++){
            m._ptr[_i2] = 0;
        }
        // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
        // This step is probably the most time-consuming
        for(var h = 0; h < values.length; h++){
            var _i3 = rowIndex[h];
            var _j = colIndex[h];
            var v = values[h];
            var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
            _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
        }
        // The value indices are inserted out of order, but apparently that's... still OK?
        return m;
    };
    /**
   * Create a clone of the matrix
   * @memberof SparseMatrix
   * @return {SparseMatrix} clone
   */ SparseMatrix.prototype.clone = function() {
        var m = new SparseMatrix({
            values: this._values ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._values) : undefined,
            index: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._index),
            ptr: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._ptr),
            size: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._size),
            datatype: this._datatype
        });
        return m;
    };
    /**
   * Retrieve the size of the matrix.
   * @memberof SparseMatrix
   * @returns {number[]} size
   */ SparseMatrix.prototype.size = function() {
        return this._size.slice(0); // copy the Array
    };
    /**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {SparseMatrix} matrix
   */ SparseMatrix.prototype.map = function(callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) {
            throw new Error('Cannot invoke map on a Pattern only matrix');
        }
        // matrix instance
        var me = this;
        // rows and columns
        var rows = this._size[0];
        var columns = this._size[1];
        var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, me, 'map');
        // invoke callback
        var invoke = function invoke(v, i, j) {
            // invoke callback
            return fastCallback.fn(v, [
                i,
                j
            ], me);
        };
        // invoke _map
        return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    /**
   * Create a new matrix with the results of the callback function executed on the interval
   * [minRow..maxRow, minColumn..maxColumn].
   */ function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
        // result arrays
        var values = [];
        var index = [];
        var ptr = [];
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(matrix._datatype)) {
            // find signature that matches (datatype, datatype)
            eq = typed.find(equalScalar, [
                matrix._datatype,
                matrix._datatype
            ]) || equalScalar;
            // convert 0 to the same datatype
            zero = typed.convert(0, matrix._datatype);
        }
        // invoke callback
        var invoke = function invoke(v, x, y) {
            // invoke callback
            var value = callback(v, x, y);
            // check value != 0
            if (!eq(value, zero)) {
                // store value
                values.push(value);
                // index
                index.push(x);
            }
        };
        // loop columns
        for(var j = minColumn; j <= maxColumn; j++){
            // store pointer to values index
            ptr.push(values.length);
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = matrix._ptr[j];
            var k1 = matrix._ptr[j + 1];
            if (skipZeros) {
                // loop k within [k0, k1[
                for(var k = k0; k < k1; k++){
                    // row index
                    var i = matrix._index[k];
                    // check i is in range
                    if (i >= minRow && i <= maxRow) {
                        // value @ k
                        invoke(matrix._values[k], i - minRow, j - minColumn);
                    }
                }
            } else {
                // create a cache holding all defined values
                var _values = {};
                for(var _k = k0; _k < k1; _k++){
                    var _i4 = matrix._index[_k];
                    _values[_i4] = matrix._values[_k];
                }
                // loop over all rows (indexes can be unordered so we can't use that),
                // and either read the value or zero
                for(var _i5 = minRow; _i5 <= maxRow; _i5++){
                    var value = _i5 in _values ? _values[_i5] : 0;
                    invoke(value, _i5 - minRow, j - minColumn);
                }
            }
        }
        // store number of values in ptr
        ptr.push(values.length);
        // return sparse matrix
        return new SparseMatrix({
            values,
            index,
            ptr,
            size: [
                maxRow - minRow + 1,
                maxColumn - minColumn + 1
            ]
        });
    }
    /**
   * Execute a callback function on each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *                              If false, the indices are guaranteed to be in order,
   *                              if true, the indices can be unordered.
   */ SparseMatrix.prototype.forEach = function(callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) {
            throw new Error('Cannot invoke forEach on a Pattern only matrix');
        }
        // matrix instance
        var me = this;
        // rows and columns
        var rows = this._size[0];
        var columns = this._size[1];
        var fastCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$optimizeCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optimizeCallback"])(callback, me, 'forEach');
        // loop columns
        for(var j = 0; j < columns; j++){
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            if (skipZeros) {
                // loop k within [k0, k1[
                for(var k = k0; k < k1; k++){
                    // row index
                    var i = this._index[k];
                    // value @ k
                    // TODO apply a non indexed version of algorithm in case fastCallback is not optimized
                    fastCallback.fn(this._values[k], [
                        i,
                        j
                    ], me);
                }
            } else {
                // create a cache holding all defined values
                var values = {};
                for(var _k2 = k0; _k2 < k1; _k2++){
                    var _i6 = this._index[_k2];
                    values[_i6] = this._values[_k2];
                }
                // loop over all rows (indexes can be unordered so we can't use that),
                // and either read the value or zero
                for(var _i7 = 0; _i7 < rows; _i7++){
                    var value = _i7 in values ? values[_i7] : 0;
                    fastCallback.fn(value, [
                        _i7,
                        j
                    ], me);
                }
            }
        }
    };
    /**
   * Iterate over the matrix elements, skipping zeros
   * @return {Iterable<{ value, index: number[] }>}
   */ SparseMatrix.prototype[Symbol.iterator] = function*() {
        if (!this._values) {
            throw new Error('Cannot iterate a Pattern only matrix');
        }
        var columns = this._size[1];
        for(var j = 0; j < columns; j++){
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            for(var k = k0; k < k1; k++){
                // row index
                var i = this._index[k];
                yield {
                    value: this._values[k],
                    index: [
                        i,
                        j
                    ]
                };
            }
        }
    };
    /**
   * Create an Array with a copy of the data of the SparseMatrix
   * @memberof SparseMatrix
   * @returns {Array} array
   */ SparseMatrix.prototype.toArray = function() {
        return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    /**
   * Get the primitive value of the SparseMatrix: a two dimensions array
   * @memberof SparseMatrix
   * @returns {Array} array
   */ SparseMatrix.prototype.valueOf = function() {
        return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values, index, ptr, size, copy) {
        // rows and columns
        var rows = size[0];
        var columns = size[1];
        // result
        var a = [];
        // vars
        var i, j;
        // initialize array
        for(i = 0; i < rows; i++){
            a[i] = [];
            for(j = 0; j < columns; j++){
                a[i][j] = 0;
            }
        }
        // loop columns
        for(j = 0; j < columns; j++){
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            // loop k within [k0, k1[
            for(var k = k0; k < k1; k++){
                // row index
                i = index[k];
                // set value (use one for pattern matrix)
                a[i][j] = values ? copy ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(values[k]) : values[k] : 1;
            }
        }
        return a;
    }
    /**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof SparseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */ SparseMatrix.prototype.format = function(options) {
        // rows and columns
        var rows = this._size[0];
        var columns = this._size[1];
        // density
        var density = this.density();
        // rows & columns
        var str = 'Sparse Matrix [' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(rows, options) + ' x ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(columns, options) + '] density: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(density, options) + '\n';
        // loop columns
        for(var j = 0; j < columns; j++){
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            // loop k within [k0, k1[
            for(var k = k0; k < k1; k++){
                // row index
                var i = this._index[k];
                // append value
                str += '\n    (' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(i, options) + ', ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(j, options) + ') ==> ' + (this._values ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this._values[k], options) : 'X');
            }
        }
        return str;
    };
    /**
   * Get a string representation of the matrix
   * @memberof SparseMatrix
   * @returns {string} str
   */ SparseMatrix.prototype.toString = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.toArray());
    };
    /**
   * Get a JSON representation of the matrix
   * @memberof SparseMatrix
   * @returns {Object}
   */ SparseMatrix.prototype.toJSON = function() {
        return {
            mathjs: 'SparseMatrix',
            values: this._values,
            index: this._index,
            ptr: this._ptr,
            size: this._size,
            datatype: this._datatype
        };
    };
    /**
   * Get the kth Matrix diagonal.
   *
   * @memberof SparseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Matrix}                     The matrix vector with the diagonal values.
   */ SparseMatrix.prototype.diagonal = function(k) {
        // validate k if any
        if (k) {
            // convert BigNumber to a number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(k)) {
                k = k.toNumber();
            }
            // is must be an integer
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(k) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(k)) {
                throw new TypeError('The parameter k must be an integer number');
            }
        } else {
            // default value
            k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        // rows & columns
        var rows = this._size[0];
        var columns = this._size[1];
        // number diagonal values
        var n = Math.min(rows - kSub, columns - kSuper);
        // diagonal arrays
        var values = [];
        var index = [];
        var ptr = [];
        // initial ptr value
        ptr[0] = 0;
        // loop columns
        for(var j = kSuper; j < columns && values.length < n; j++){
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            // loop x within [k0, k1[
            for(var x = k0; x < k1; x++){
                // row index
                var i = this._index[x];
                // check row
                if (i === j - kSuper + kSub) {
                    // value on this column
                    values.push(this._values[x]);
                    // store row
                    index[values.length - 1] = i - kSub;
                    break;
                }
            }
        }
        // close ptr
        ptr.push(values.length);
        // return matrix
        return new SparseMatrix({
            values,
            index,
            ptr,
            size: [
                n,
                1
            ]
        });
    };
    /**
   * Generate a matrix from a JSON object
   * @memberof SparseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
   *                       where mathjs is optional
   * @returns {SparseMatrix}
   */ SparseMatrix.fromJSON = function(json) {
        return new SparseMatrix(json);
    };
    /**
   * Create a diagonal matrix.
   *
   * @memberof SparseMatrix
   * @param {Array} size                       The matrix size.
   * @param {number | Array | Matrix } value   The values for the diagonal.
   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
   * @param {number} [defaultValue]            The default value for non-diagonal
   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
   *
   * @returns {SparseMatrix}
   */ SparseMatrix.diagonal = function(size, value, k, defaultValue, datatype) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(size)) {
            throw new TypeError('Array expected, size parameter');
        }
        if (size.length !== 2) {
            throw new Error('Only two dimensions matrix are supported');
        }
        // map size & validate
        size = size.map(function(s) {
            // check it is a big number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(s)) {
                // convert it
                s = s.toNumber();
            }
            // validate arguments
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(s) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(s) || s < 1) {
                throw new Error('Size values must be positive integers');
            }
            return s;
        });
        // validate k if any
        if (k) {
            // convert BigNumber to a number
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(k)) {
                k = k.toNumber();
            }
            // is must be an integer
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(k) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(k)) {
                throw new TypeError('The parameter k must be an integer number');
            }
        } else {
            // default value
            k = 0;
        }
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(datatype)) {
            // find signature that matches (datatype, datatype)
            eq = typed.find(equalScalar, [
                datatype,
                datatype
            ]) || equalScalar;
            // convert 0 to the same datatype
            zero = typed.convert(0, datatype);
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        // rows and columns
        var rows = size[0];
        var columns = size[1];
        // number of non-zero items
        var n = Math.min(rows - kSub, columns - kSuper);
        // value extraction function
        var _value;
        // check value
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(value)) {
            // validate array
            if (value.length !== n) {
                // number of values in array must be n
                throw new Error('Invalid value array length');
            }
            // define function
            _value = function _value(i) {
                // return value @ i
                return value[i];
            };
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(value)) {
            // matrix size
            var ms = value.size();
            // validate matrix
            if (ms.length !== 1 || ms[0] !== n) {
                // number of values in array must be n
                throw new Error('Invalid matrix length');
            }
            // define function
            _value = function _value(i) {
                // return value @ i
                return value.get([
                    i
                ]);
            };
        } else {
            // define function
            _value = function _value() {
                // return value
                return value;
            };
        }
        // create arrays
        var values = [];
        var index = [];
        var ptr = [];
        // loop items
        for(var j = 0; j < columns; j++){
            // number of rows with value
            ptr.push(values.length);
            // diagonal index
            var i = j - kSuper;
            // check we need to set diagonal value
            if (i >= 0 && i < n) {
                // get value @ i
                var v = _value(i);
                // check for zero
                if (!eq(v, zero)) {
                    // column
                    index.push(i + kSub);
                    // add value
                    values.push(v);
                }
            }
        }
        // last value should be number of values
        ptr.push(values.length);
        // create SparseMatrix
        return new SparseMatrix({
            values,
            index,
            ptr,
            size: [
                rows,
                columns
            ]
        });
    };
    /**
   * Swap rows i and j in Matrix.
   *
   * @memberof SparseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */ SparseMatrix.prototype.swapRows = function(i, j) {
        // check index
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(i) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(i) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(j) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(j)) {
            throw new Error('Row index must be positive integers');
        }
        // check dimensions
        if (this._size.length !== 2) {
            throw new Error('Only two dimensional matrix is supported');
        }
        // validate index
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(i, this._size[0]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIndex"])(j, this._size[0]);
        // swap rows
        SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
        // return current instance
        return this;
    };
    /**
   * Loop rows with data in column j.
   *
   * @param {number} j            Column
   * @param {Array} values        Matrix values
   * @param {Array} index         Matrix row indeces
   * @param {Array} ptr           Matrix column pointers
   * @param {Function} callback   Callback function invoked for every row in column j
   */ SparseMatrix._forEachRow = function(j, values, index, ptr, callback) {
        // indeces for column j
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        // loop
        for(var k = k0; k < k1; k++){
            // invoke callback
            callback(index[k], values[k]);
        }
    };
    /**
   * Swap rows x and y in Sparse Matrix data structures.
   *
   * @param {number} x         Matrix row index 1
   * @param {number} y         Matrix row index 2
   * @param {number} columns   Number of columns in matrix
   * @param {Array} values     Matrix values
   * @param {Array} index      Matrix row indeces
   * @param {Array} ptr        Matrix column pointers
   */ SparseMatrix._swapRows = function(x, y, columns, values, index, ptr) {
        // loop columns
        for(var j = 0; j < columns; j++){
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            // find value index @ x
            var kx = _getValueIndex(x, k0, k1, index);
            // find value index @ x
            var ky = _getValueIndex(y, k0, k1, index);
            // check both rows exist in matrix
            if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
                // swap values (check for pattern matrix)
                if (values) {
                    var v = values[kx];
                    values[kx] = values[ky];
                    values[ky] = v;
                }
                continue;
            }
            // check x row exist & no y row
            if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
                // value @ x (check for pattern matrix)
                var vx = values ? values[kx] : undefined;
                // insert value @ y
                index.splice(ky, 0, y);
                if (values) {
                    values.splice(ky, 0, vx);
                }
                // remove value @ x (adjust array index if needed)
                index.splice(ky <= kx ? kx + 1 : kx, 1);
                if (values) {
                    values.splice(ky <= kx ? kx + 1 : kx, 1);
                }
                continue;
            }
            // check y row exist & no x row
            if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
                // value @ y (check for pattern matrix)
                var vy = values ? values[ky] : undefined;
                // insert value @ x
                index.splice(kx, 0, x);
                if (values) {
                    values.splice(kx, 0, vy);
                }
                // remove value @ y (adjust array index if needed)
                index.splice(kx <= ky ? ky + 1 : ky, 1);
                if (values) {
                    values.splice(kx <= ky ? ky + 1 : ky, 1);
                }
            }
        }
    };
    return SparseMatrix;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSplitUnit": (()=>createSplitUnit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'splitUnit';
var dependencies = [
    'typed'
];
var createSplitUnit = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Split a unit in an array of units whose sum is equal to the original unit.
   *
   * Syntax:
   *
   *     math.splitUnit(unit: Unit, parts: Array.<Unit>)
   *
   * Example:
   *
   *     math.splitUnit(new Unit(1, 'm'), ['feet', 'inch'])
   *     // [ 3 feet, 3.3700787401575 inch ]
   *
   * See also:
   *
   *     unit
   *
   * @param {Array} [parts] An array of strings or valueless units.
   * @return {Array} An array of units.
   */ return typed(name, {
        'Unit, Array': function Unit_Array(unit, parts) {
            return unit.splitUnit(parts);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createString": (()=>createString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
;
;
;
var name = 'string';
var dependencies = [
    'typed'
];
var createString = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Create a string or convert any object into a string.
   * Elements of Arrays and Matrices are processed element wise.
   *
   * Syntax:
   *
   *    math.string(value)
   *
   * Examples:
   *
   *    math.string(4.2)                // returns string '4.2'
   *    math.string(math.complex(3, 2)) // returns string '3 + 2i'
   *
   *    const u = math.unit(5, 'km')
   *    math.string(u.to('m'))          // returns string '5000 m'
   *
   *    math.string([true, false])      // returns ['true', 'false']
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, unit
   *
   * @param {* | Array | Matrix | null} [value]  A value to convert to a string
   * @return {string | Array | Matrix} The created string
   */ return typed(name, {
        '': function _() {
            return '';
        },
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"],
        null: function _null(x) {
            return 'null';
        },
        boolean: function boolean(x) {
            return x + '';
        },
        string: function string(x) {
            return x;
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self)),
        any: function any(x) {
            return String(x);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBignumber": (()=>createBignumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'bignumber';
var dependencies = [
    'typed',
    'BigNumber'
];
var createBignumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber } = _ref;
    /**
   * Create a BigNumber, which can store numbers with arbitrary precision.
   * When a matrix is provided, all elements will be converted to BigNumber.
   *
   * Syntax:
   *
   *    math.bignumber(x)
   *
   * Examples:
   *
   *    0.1 + 0.2                                  // returns number 0.30000000000000004
   *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
   *
   *
   *    7.2e500                                    // returns number Infinity
   *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
   *
   * See also:
   *
   *    number, bigint, boolean, complex, index, matrix, string, unit
   *
   * @param {number | string | Fraction | BigNumber | bigint | Array | Matrix | boolean | null} [value]  Value for the big number,
   *                                                    0 by default.
   * @returns {BigNumber} The created bignumber
   */ return typed('bignumber', {
        '': function _() {
            return new BigNumber(0);
        },
        number: function number(x) {
            // convert to string to prevent errors in case of >15 digits
            return new BigNumber(x + '');
        },
        string: function string(x) {
            var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
                // x has a word size suffix
                var size = wordSizeSuffixMatch[2];
                var n = BigNumber(wordSizeSuffixMatch[1]);
                var twoPowSize = new BigNumber(2).pow(Number(size));
                if (n.gt(twoPowSize.sub(1))) {
                    throw new SyntaxError("String \"".concat(x, "\" is out of range"));
                }
                var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
                if (n.gte(twoPowSizeSubOne)) {
                    return n.sub(twoPowSize);
                } else {
                    return n;
                }
            }
            return new BigNumber(x);
        },
        BigNumber: function BigNumber(x) {
            // we assume a BigNumber is immutable
            return x;
        },
        bigint: function bigint(x) {
            return new BigNumber(x.toString());
        },
        Unit: typed.referToSelf((self)=>(x)=>{
                var clone = x.clone();
                clone.value = self(x.value);
                return clone;
            }),
        Fraction: function Fraction(x) {
            return new BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
        },
        null: function _null(_x) {
            return new BigNumber(0);
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/function/matrix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrix": (()=>createMatrix)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'matrix';
var dependencies = [
    'typed',
    'Matrix',
    'DenseMatrix',
    'SparseMatrix'
];
var createMatrix = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Matrix, DenseMatrix, SparseMatrix } = _ref;
    /**
   * Create a Matrix. The function creates a new `math.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Supported storage formats are 'dense' and 'sparse'.
   *
   * Syntax:
   *
   *    math.matrix()                         // creates an empty matrix using default storage format (dense).
   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
   *
   * Examples:
   *
   *    let m = math.matrix([[1, 2], [3, 4]])
   *    m.size()                        // Array [2, 2]
   *    m.resize([3, 2], 5)
   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, sparse
   *
   * @param {Array | Matrix} [data]    A multi dimensional array
   * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
   * @param {string} [datatype]        Type of the values
   *
   * @return {Matrix} The created matrix
   */ return typed(name, {
        '': function _() {
            return _create([]);
        },
        string: function string(format) {
            return _create([], format);
        },
        'string, string': function string_string(format, datatype) {
            return _create([], format, datatype);
        },
        Array: function Array(data) {
            return _create(data);
        },
        Matrix: function Matrix(data) {
            return _create(data, data.storage());
        },
        'Array | Matrix, string': _create,
        'Array | Matrix, string, string': _create
    });
    "TURBOPACK unreachable";
    /**
   * Create a new Matrix with given storage format
   * @param {Array} data
   * @param {string} [format]
   * @param {string} [datatype]
   * @returns {Matrix} Returns a new Matrix
   * @private
   */ function _create(data, format, datatype) {
        // get storage format constructor
        if (format === 'dense' || format === 'default' || format === undefined) {
            return new DenseMatrix(data, datatype);
        }
        if (format === 'sparse') {
            return new SparseMatrix(data, datatype);
        }
        throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/function/sparse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSparse": (()=>createSparse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'sparse';
var dependencies = [
    'typed',
    'SparseMatrix'
];
var createSparse = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, SparseMatrix } = _ref;
    /**
   * Create a Sparse Matrix. The function creates a new `math.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Note that a Sparse Matrix is always 2-dimensional, so for example if
   * you create one from a plain array of _n_ numbers, you get an _n_ by 1
   * Sparse "column vector".
   *
   * Syntax:
   *
   *    math.sparse()               // creates an empty sparse matrix.
   *    math.sparse(data)           // creates a sparse matrix with initial data.
   *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.
   *
   * Examples:
   *
   *    let m = math.sparse([[1, 2], [3, 4]])
   *    m.size()                        // Array [2, 2]
   *    m.resize([3, 2], 5)
   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *    let v = math.sparse([0, 0, 1])
   *    v.size()                        // Array [3, 1]
   *    v.get([2, 0])                   // number 1
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, matrix
   *
   * @param {Array | Matrix} [data]    A two dimensional array
   *
   * @return {Matrix} The created matrix
   */ return typed(name, {
        '': function _() {
            return new SparseMatrix([]);
        },
        string: function string(datatype) {
            return new SparseMatrix([], datatype);
        },
        'Array | Matrix': function Array__Matrix(data) {
            return new SparseMatrix(data);
        },
        'Array | Matrix, string': function Array__Matrix_string(data, datatype) {
            return new SparseMatrix(data, datatype);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo02xDS0": (()=>createMatAlgo02xDS0)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo02xDS0';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo02xDS0 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */ return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype || denseMatrix.getDataType();
        // sparse matrix arrays
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // sparse matrix cannot be a Pattern matrix
        if (!bvalues) {
            throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result (SparseMatrix)
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // loop columns in b
        for(var j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // values in column j
            for(var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                // row
                var i = bindex[k];
                // update C(i,j)
                var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
                // check for nonzero
                if (!eq(cij, zero)) {
                    // push i & v
                    cindex.push(i);
                    cvalues.push(cij);
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return sparseMatrix.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo09xS0Sf": (()=>createMatAlgo09xS0Sf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo09xS0Sf';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo09xS0Sf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij).
   * Callback function invoked NZA times, number of nonzero elements in A.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */ return function matAlgo09xS0Sf(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // sparse matrix arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // workspaces
        var x = cvalues ? [] : undefined;
        // marks indicating we have a value in x for a given column
        var w = [];
        // vars
        var i, j, k, k0, k1;
        // loop columns
        for(j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // column mark
            var mark = j + 1;
            // check we need to process values
            if (x) {
                // loop B(:,j)
                for(k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                    // row
                    i = bindex[k];
                    // update workspace
                    w[i] = mark;
                    x[i] = bvalues[k];
                }
            }
            // loop A(:,j)
            for(k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                i = aindex[k];
                // check we need to process values
                if (x) {
                    // b value @ i,j
                    var vb = w[i] === mark ? x[i] : zero;
                    // invoke f
                    var vc = cf(avalues[k], vb);
                    // check zero value
                    if (!eq(vc, zero)) {
                        // push index
                        cindex.push(i);
                        // push value
                        cvalues.push(vc);
                    }
                } else {
                    // push index
                    cindex.push(i);
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo11xS0s": (()=>createMatAlgo11xS0s)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'matAlgo11xS0s';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo11xS0s = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  0          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */ return function matAlgo11xS0s(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        // sparse matrix cannot be a Pattern matrix
        if (!avalues) {
            throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // convert b to the same datatype
            b = typed.convert(b, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            // initialize ptr
            cptr[j] = cindex.length;
            // values in j
            for(var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                var i = aindex[k];
                // invoke callback
                var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
                // check value is zero
                if (!eq(v, zero)) {
                    // push index & value
                    cindex.push(i);
                    cvalues.push(v);
                }
            }
        }
        // update ptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return s.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: dt
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo13xDD": (()=>createMatAlgo13xDD)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo13xDD';
var dependencies = [
    'typed'
];
var createMatAlgo13xDD = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, Bij..z)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Matrix}   b                 The DenseMatrix instance (B)
   * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
   */ return function matAlgo13xDD(a, b, callback) {
        // a arrays
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        // b arrays
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype;
        // c arrays
        var csize = [];
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // validate each one of the dimension sizes
        for(var s = 0; s < asize.length; s++){
            // must match
            if (asize[s] !== bsize[s]) {
                throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
            }
            // update dimension in c
            csize[s] = asize[s];
        }
        // datatype
        var dt;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt) {
            // datatype
            dt = adt;
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // populate cdata, iterate through dimensions
        var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
        // c matrix
        return a.createDenseMatrix({
            data: cdata,
            size: csize,
            datatype: dt
        });
    };
    "TURBOPACK unreachable";
    // recursive function
    function _iterate(f, level, s, n, av, bv) {
        // initialize array for this level
        var cv = [];
        // check we reach the last level
        if (level === s.length - 1) {
            // loop arrays in last level
            for(var i = 0; i < n; i++){
                // invoke callback and store value
                cv[i] = f(av[i], bv[i]);
            }
        } else {
            // iterate current level
            for(var j = 0; j < n; j++){
                // iterate next level
                cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
            }
        }
        return cv;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo14xDs": (()=>createMatAlgo14xDs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo14xDs';
var dependencies = [
    'typed'
];
var createMatAlgo14xDs = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, b)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij..z,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
   */ return function matAlgo14xDs(a, b, callback, inverse) {
        // a arrays
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        // datatype
        var dt;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string') {
            // datatype
            dt = adt;
            // convert b to the same datatype
            b = typed.convert(b, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // populate cdata, iterate through dimensions
        var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
        // c matrix
        return a.createDenseMatrix({
            data: cdata,
            size: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(asize),
            datatype: dt
        });
    };
    "TURBOPACK unreachable";
    // recursive function
    function _iterate(f, level, s, n, av, bv, inverse) {
        // initialize array for this level
        var cv = [];
        // check we reach the last level
        if (level === s.length - 1) {
            // loop arrays in last level
            for(var i = 0; i < n; i++){
                // invoke callback and store value
                cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
            }
        } else {
            // iterate current level
            for(var j = 0; j < n; j++){
                // iterate next level
                cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
            }
        }
        return cv;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "broadcast": (()=>broadcast)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
;
;
function broadcast(A, B) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepStrictEqual"])(A.size(), B.size())) {
        // If matrices have the same size return them
        return [
            A,
            B
        ];
    }
    // calculate the broadcasted sizes
    var newSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastSizes"])(A.size(), B.size());
    // return the array with the two broadcasted matrices
    return [
        A,
        B
    ].map((M)=>_broadcastTo(M, newSize));
}
/**
 * Broadcasts a matrix to the given size.
 *
 * @param {Matrix} M - The matrix to be broadcasted.
 * @param {number[]} size - The desired size of the broadcasted matrix.
 * @returns {Matrix} The broadcasted matrix.
 * @throws {Error} If the size parameter is not an array of numbers.
 */ function _broadcastTo(M, size) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepStrictEqual"])(M.size(), size)) {
        return M;
    }
    return M.create((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastTo"])(M.valueOf(), size), M.datatype());
}
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatrixAlgorithmSuite": (()=>createMatrixAlgorithmSuite)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo13xDD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js [app-client] (ecmascript)");
;
;
;
;
;
var name = 'matrixAlgorithmSuite';
var dependencies = [
    'typed',
    'matrix'
];
var createMatrixAlgorithmSuite = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix } = _ref;
    var matAlgo13xDD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo13xDD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMatAlgo13xDD"])({
        typed
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    /**
   * Return a signatures object with the usual boilerplate of
   * matrix algorithms, based on a plain options object with the
   * following properties:
   *   elop: function -- the elementwise operation to use, defaults to self
   *   SS: function -- the algorithm to apply for two sparse matrices
   *   DS: function -- the algorithm to apply for a dense and a sparse matrix
   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped
   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar
   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped
   *   scalar: string -- typed-function type for scalars, defaults to 'any'
   *
   * If Ss is not specified, no matrix-scalar signatures are generated.
   *
   * @param {object} options
   * @return {Object<string, function>} signatures
   */ return function matrixAlgorithmSuite(options) {
        var elop = options.elop;
        var SD = options.SD || options.DS;
        var matrixSignatures;
        if (elop) {
            // First the dense ones
            matrixSignatures = {
                'DenseMatrix, DenseMatrix': (x, y)=>matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), elop),
                'Array, Array': (x, y)=>matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), matrix(y)), elop).valueOf(),
                'Array, DenseMatrix': (x, y)=>matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), y), elop),
                'DenseMatrix, Array': (x, y)=>matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, matrix(y)), elop)
            };
            // Now incorporate sparse matrices
            if (options.SS) {
                matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y)=>options.SS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), elop, false);
            }
            if (options.DS) {
                matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y)=>options.DS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), elop, false);
                matrixSignatures['Array, SparseMatrix'] = (x, y)=>options.DS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), y), elop, false);
            }
            if (SD) {
                matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y)=>SD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(y, x), elop, true);
                matrixSignatures['SparseMatrix, Array'] = (x, y)=>SD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(y), x), elop, true);
            }
        } else {
            // No elop, use this
            // First the dense ones
            matrixSignatures = {
                'DenseMatrix, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), self);
                    }),
                'Array, Array': typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), matrix(y)), self).valueOf();
                    }),
                'Array, DenseMatrix': typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), y), self);
                    }),
                'DenseMatrix, Array': typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo13xDD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, matrix(y)), self);
                    })
            };
            // Now incorporate sparse matrices
            if (options.SS) {
                matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return options.SS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), self, false);
                    });
            }
            if (options.DS) {
                matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return options.DS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(x, y), self, false);
                    });
                matrixSignatures['Array, SparseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return options.DS(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(x), y), self, false);
                    });
            }
            if (SD) {
                matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return SD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(y, x), self, true);
                    });
                matrixSignatures['SparseMatrix, Array'] = typed.referToSelf((self)=>(x, y)=>{
                        return SD(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$broadcast$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcast"])(matrix(y), x), self, true);
                    });
            }
        }
        // Now add the scalars
        var scalar = options.scalar || 'any';
        var Ds = options.Ds || options.Ss;
        if (Ds) {
            if (elop) {
                matrixSignatures['DenseMatrix,' + scalar] = (x, y)=>matAlgo14xDs(x, y, elop, false);
                matrixSignatures[scalar + ', DenseMatrix'] = (x, y)=>matAlgo14xDs(y, x, elop, true);
                matrixSignatures['Array,' + scalar] = (x, y)=>matAlgo14xDs(matrix(x), y, elop, false).valueOf();
                matrixSignatures[scalar + ', Array'] = (x, y)=>matAlgo14xDs(matrix(y), x, elop, true).valueOf();
            } else {
                matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo14xDs(x, y, self, false);
                    });
                matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo14xDs(y, x, self, true);
                    });
                matrixSignatures['Array,' + scalar] = typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo14xDs(matrix(x), y, self, false).valueOf();
                    });
                matrixSignatures[scalar + ', Array'] = typed.referToSelf((self)=>(x, y)=>{
                        return matAlgo14xDs(matrix(y), x, self, true).valueOf();
                    });
            }
        }
        var sS = options.sS !== undefined ? options.sS : options.Ss;
        if (elop) {
            if (options.Ss) {
                matrixSignatures['SparseMatrix,' + scalar] = (x, y)=>options.Ss(x, y, elop, false);
            }
            if (sS) {
                matrixSignatures[scalar + ', SparseMatrix'] = (x, y)=>sS(y, x, elop, true);
            }
        } else {
            if (options.Ss) {
                matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf((self)=>(x, y)=>{
                        return options.Ss(x, y, self, false);
                    });
            }
            if (sS) {
                matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf((self)=>(x, y)=>{
                        return sS(y, x, self, true);
                    });
            }
        }
        // Also pull in the scalar signatures if the operator is a typed function
        if (elop && elop.signatures) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extend"])(matrixSignatures, elop.signatures);
        }
        return matrixSignatures;
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo03xDSf": (()=>createMatAlgo03xDSf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo03xDSf';
var dependencies = [
    'typed'
];
var createMatAlgo03xDSf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
   * Callback function invoked M*N times.
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  f(Dij, 0)    ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */ return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype || denseMatrix.getDataType();
        // sparse matrix arrays
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // sparse matrix cannot be a Pattern matrix
        if (!bvalues) {
            throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result (DenseMatrix)
        var cdata = [];
        // initialize dense matrix
        for(var z = 0; z < rows; z++){
            // initialize row
            cdata[z] = [];
        }
        // workspace
        var x = [];
        // marks indicating we have a value in x for a given column
        var w = [];
        // loop columns in b
        for(var j = 0; j < columns; j++){
            // column mark
            var mark = j + 1;
            // values in column j
            for(var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                // row
                var i = bindex[k];
                // update workspace
                x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
                w[i] = mark;
            }
            // process workspace
            for(var y = 0; y < rows; y++){
                // check we have a calculated value for current row
                if (w[y] === mark) {
                    // use calculated value
                    cdata[y][j] = x[y];
                } else {
                    // calculate value
                    cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
                }
            }
        }
        // return dense matrix
        return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [
                rows,
                columns
            ],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo07xSSf": (()=>createMatAlgo07xSSf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo07xSSf';
var dependencies = [
    'typed',
    'SparseMatrix'
];
var createMatAlgo07xSSf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, SparseMatrix } = _ref;
    /**
  * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
  * Callback function invoked MxN times.
  *
  * C(i,j) = f(Aij, Bij)
  *
  * @param {Matrix}   a                 The SparseMatrix instance (A)
  * @param {Matrix}   b                 The SparseMatrix instance (B)
  * @param {Function} callback          The f(Aij,Bij) operation to invoke
  *
  * @return {Matrix}                    SparseMatrix (C)
  *
  * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
  */ return function matAlgo07xSSf(a, b, callback) {
        // sparse matrix arrays
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        var zero = 0;
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            dt = adt;
            zero = typed.convert(0, dt);
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays for sparse format
        var cvalues = [];
        var cindex = [];
        var cptr = new Array(columns + 1).fill(0); // Start with column pointer array
        // workspaces
        var xa = [];
        var xb = [];
        var wa = [];
        var wb = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            var mark = j + 1;
            var nonZeroCount = 0;
            _scatter(a, j, wa, xa, mark);
            _scatter(b, j, wb, xb, mark);
            // loop rows
            for(var i = 0; i < rows; i++){
                var va = wa[i] === mark ? xa[i] : zero;
                var vb = wb[i] === mark ? xb[i] : zero;
                // invoke callback
                var cij = cf(va, vb);
                // Store all non zero and true values
                if (cij !== 0 && cij !== false) {
                    cindex.push(i); // row index
                    cvalues.push(cij); // computed value
                    nonZeroCount++;
                }
            }
            // Update column pointer with cumulative count of non-zero values
            cptr[j + 1] = cptr[j] + nonZeroCount;
        }
        // Return the result as a sparse matrix
        return new SparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
    "TURBOPACK unreachable";
    function _scatter(m, j, w, x, mark) {
        // a arrays
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // loop values in column j
        for(var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++){
            // row
            var i = index[k];
            // update workspace
            w[i] = mark;
            x[i] = values[k];
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo12xSfs": (()=>createMatAlgo12xSfs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'matAlgo12xSfs';
var dependencies = [
    'typed',
    'DenseMatrix'
];
var createMatAlgo12xSfs = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, DenseMatrix } = _ref;
    /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked MxN times.
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  f(0, b)    ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */ return function matAlgo12xSfs(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        // sparse matrix cannot be a Pattern matrix
        if (!avalues) {
            throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string') {
            // datatype
            dt = adt;
            // convert b to the same datatype
            b = typed.convert(b, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cdata = [];
        // workspaces
        var x = [];
        // marks indicating we have a value in x for a given column
        var w = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            // columns mark
            var mark = j + 1;
            // values in j
            for(var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                var r = aindex[k];
                // update workspace
                x[r] = avalues[k];
                w[r] = mark;
            }
            // loop rows
            for(var i = 0; i < rows; i++){
                // initialize C on first column
                if (j === 0) {
                    // create row array
                    cdata[i] = [];
                }
                // check sparse matrix has a value @ i,j
                if (w[i] === mark) {
                    // invoke callback, update C
                    cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
                } else {
                    // dense matrix value @ i, j
                    cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
                }
            }
        }
        // return dense matrix
        return new DenseMatrix({
            data: cdata,
            size: [
                rows,
                columns
            ],
            datatype: dt
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/fraction/function/fraction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFraction": (()=>createFraction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'fraction';
var dependencies = [
    'typed',
    'Fraction'
];
var createFraction = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Fraction } = _ref;
    /**
   * Create a fraction or convert a value to a fraction.
   *
   * With one numeric argument, produces the closest rational approximation to the
   * input.
   * With two arguments, the first is the numerator and the second is the denominator,
   * and creates the corresponding fraction. Both numerator and denominator must be
   * integers.
   * With one object argument, looks for the integer numerator as the value of property
   * 'n' and the integer denominator as the value of property 'd'.
   * With a matrix argument, creates a matrix of the same shape with entries
   * converted into fractions.
   *
   * Syntax:
   *     math.fraction(value)
   *     math.fraction(numerator, denominator)
   *     math.fraction({n: numerator, d: denominator})
   *     math.fraction(matrix: Array | Matrix)
   *
   * Examples:
   *
   *     math.fraction(6.283)             // returns Fraction 6283/1000
   *     math.fraction(1, 3)              // returns Fraction 1/3
   *     math.fraction('2/3')             // returns Fraction 2/3
   *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
   *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
   *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
   *
   * See also:
   *
   *    bignumber, number, string, unit
   *
   * @param {number | string | Fraction | BigNumber | bigint | Unit | Array | Matrix} [args]
   *            Arguments specifying the value, or numerator and denominator of
   *            the fraction
   * @return {Fraction | Array | Matrix} Returns a fraction
   */ return typed('fraction', {
        number: function number(x) {
            if (!isFinite(x) || isNaN(x)) {
                throw new Error(x + ' cannot be represented as a fraction');
            }
            return new Fraction(x);
        },
        string: function string(x) {
            return new Fraction(x);
        },
        'number, number': function number_number(numerator, denominator) {
            return new Fraction(numerator, denominator);
        },
        'bigint, bigint': function bigint_bigint(numerator, denominator) {
            return new Fraction(numerator, denominator);
        },
        null: function _null(x) {
            return new Fraction(0);
        },
        BigNumber: function BigNumber(x) {
            return new Fraction(x.toString());
        },
        bigint: function bigint(x) {
            return new Fraction(x.toString());
        },
        Fraction: function Fraction(x) {
            return x; // fractions are immutable
        },
        Unit: typed.referToSelf((self)=>(x)=>{
                var clone = x.clone();
                clone.value = self(x.value);
                return clone;
            }),
        Object: function Object(x) {
            return new Fraction(x);
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo01xDSid": (()=>createMatAlgo01xDSid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo01xDSid';
var dependencies = [
    'typed'
];
var createMatAlgo01xDSid = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  Dij          ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */ return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype || denseMatrix.getDataType();
        // sparse matrix arrays
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // sparse matrix cannot be a Pattern matrix
        if (!bvalues) {
            throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // process data types
        var dt = typeof adt === 'string' && adt !== 'mixed' && adt === bdt ? adt : undefined;
        // callback function
        var cf = dt ? typed.find(callback, [
            dt,
            dt
        ]) : callback;
        // vars
        var i, j;
        // result (DenseMatrix)
        var cdata = [];
        // initialize c
        for(i = 0; i < rows; i++){
            cdata[i] = [];
        }
        // workspace
        var x = [];
        // marks indicating we have a value in x for a given column
        var w = [];
        // loop columns in b
        for(j = 0; j < columns; j++){
            // column mark
            var mark = j + 1;
            // values in column j
            for(var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                // row
                i = bindex[k];
                // update workspace
                x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
                // mark i as updated
                w[i] = mark;
            }
            // loop rows
            for(i = 0; i < rows; i++){
                // check row is in workspace
                if (w[i] === mark) {
                    // c[i][j] was already calculated
                    cdata[i][j] = x[i];
                } else {
                    // item does not exist in S
                    cdata[i][j] = adata[i][j];
                }
            }
        }
        // return dense matrix
        return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [
                rows,
                columns
            ],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo10xSids": (()=>createMatAlgo10xSids)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'matAlgo10xSids';
var dependencies = [
    'typed',
    'DenseMatrix'
];
var createMatAlgo10xSids = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, DenseMatrix } = _ref;
    /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  b          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */ return function matAlgo10xSids(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        // sparse matrix cannot be a Pattern matrix
        if (!avalues) {
            throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string') {
            // datatype
            dt = adt;
            // convert b to the same datatype
            b = typed.convert(b, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cdata = [];
        // workspaces
        var x = [];
        // marks indicating we have a value in x for a given column
        var w = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            // columns mark
            var mark = j + 1;
            // values in j
            for(var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                var r = aindex[k];
                // update workspace
                x[r] = avalues[k];
                w[r] = mark;
            }
            // loop rows
            for(var i = 0; i < rows; i++){
                // initialize C on first column
                if (j === 0) {
                    // create row array
                    cdata[i] = [];
                }
                // check sparse matrix has a value @ i,j
                if (w[i] === mark) {
                    // invoke callback, update C
                    cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
                } else {
                    // dense matrix value @ i, j
                    cdata[i][j] = b;
                }
            }
        }
        // return dense matrix
        return new DenseMatrix({
            data: cdata,
            size: [
                rows,
                columns
            ],
            datatype: dt
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo08xS0Sid": (()=>createMatAlgo08xS0Sid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo08xS0Sid';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo08xS0Sid = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */ return function matAlgo08xS0Sid(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // sparse matrix arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // sparse matrix cannot be a Pattern matrix
        if (!avalues || !bvalues) {
            throw new Error('Cannot perform operation on Pattern Sparse Matrices');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // workspace
        var x = [];
        // marks indicating we have a value in x for a given column
        var w = [];
        // vars
        var k, k0, k1, i;
        // loop columns
        for(var j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // columns mark
            var mark = j + 1;
            // loop values in a
            for(k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                i = aindex[k];
                // mark workspace
                w[i] = mark;
                // set value
                x[i] = avalues[k];
                // add index
                cindex.push(i);
            }
            // loop values in b
            for(k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                // row
                i = bindex[k];
                // check value exists in workspace
                if (w[i] === mark) {
                    // evaluate callback
                    x[i] = cf(x[i], bvalues[k]);
                }
            }
            // initialize first index in j
            k = cptr[j];
            // loop index in j
            while(k < cindex.length){
                // row
                i = cindex[k];
                // value @ i
                var v = x[i];
                // check for zero value
                if (!eq(v, zero)) {
                    // push value
                    cvalues.push(v);
                    // increment pointer
                    k++;
                } else {
                    // remove value @ i, do not increment pointer
                    cindex.splice(k, 1);
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo06xS0S0": (()=>createMatAlgo06xS0S0)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
;
var name = 'matAlgo06xS0S0';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo06xS0S0 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */ return function matAlgo06xS0S0(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // sparse matrix arrays
        var bvalues = b._values;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // workspaces
        var x = cvalues ? [] : undefined;
        // marks indicating we have a value in x for a given column
        var w = [];
        // marks indicating value in a given row has been updated
        var u = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // columns mark
            var mark = j + 1;
            // scatter the values of A(:,j) into workspace
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scatter"])(a, j, w, x, u, mark, cindex, cf);
            // scatter the values of B(:,j) into workspace
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scatter"])(b, j, w, x, u, mark, cindex, cf);
            // check we need to process values (non pattern matrix)
            if (x) {
                // initialize first index in j
                var k = cptr[j];
                // loop index in j
                while(k < cindex.length){
                    // row
                    var i = cindex[k];
                    // check function was invoked on current row (Aij !=0 && Bij != 0)
                    if (u[i] === mark) {
                        // value @ i
                        var v = x[i];
                        // check for zero value
                        if (!eq(v, zero)) {
                            // push value
                            cvalues.push(v);
                            // increment pointer
                            k++;
                        } else {
                            // remove value @ i, do not increment pointer
                            cindex.splice(k, 1);
                        }
                    } else {
                        // remove value @ i, do not increment pointer
                        cindex.splice(k, 1);
                    }
                }
            } else {
                // initialize first index in j
                var p = cptr[j];
                // loop index in j
                while(p < cindex.length){
                    // row
                    var r = cindex[p];
                    // check function was invoked on current row (Aij !=0 && Bij != 0)
                    if (u[r] !== mark) {
                        // remove value @ i, do not increment pointer
                        cindex.splice(p, 1);
                    } else {
                        // increment pointer
                        p++;
                    }
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo04xSidSid": (()=>createMatAlgo04xSidSid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo04xSidSid';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo04xSidSid = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
   *          └  B(i,j)       ; A(i,j) === 0
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */ return function matAlgo04xSidSid(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // sparse matrix arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // workspace
        var xa = avalues && bvalues ? [] : undefined;
        var xb = avalues && bvalues ? [] : undefined;
        // marks indicating we have a value in x for a given column
        var wa = [];
        var wb = [];
        // vars
        var i, j, k, k0, k1;
        // loop columns
        for(j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // columns mark
            var mark = j + 1;
            // loop A(:,j)
            for(k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++){
                // row
                i = aindex[k];
                // update c
                cindex.push(i);
                // update workspace
                wa[i] = mark;
                // check we need to process values
                if (xa) {
                    xa[i] = avalues[k];
                }
            }
            // loop B(:,j)
            for(k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++){
                // row
                i = bindex[k];
                // check row exists in A
                if (wa[i] === mark) {
                    // update record in xa @ i
                    if (xa) {
                        // invoke callback
                        var v = cf(xa[i], bvalues[k]);
                        // check for zero
                        if (!eq(v, zero)) {
                            // update workspace
                            xa[i] = v;
                        } else {
                            // remove mark (index will be removed later)
                            wa[i] = null;
                        }
                    }
                } else {
                    // update c
                    cindex.push(i);
                    // update workspace
                    wb[i] = mark;
                    // check we need to process values
                    if (xb) {
                        xb[i] = bvalues[k];
                    }
                }
            }
            // check we need to process values (non pattern matrix)
            if (xa && xb) {
                // initialize first index in j
                k = cptr[j];
                // loop index in j
                while(k < cindex.length){
                    // row
                    i = cindex[k];
                    // check workspace has value @ i
                    if (wa[i] === mark) {
                        // push value (Aij != 0 || (Aij != 0 && Bij != 0))
                        cvalues[k] = xa[i];
                        // increment pointer
                        k++;
                    } else if (wb[i] === mark) {
                        // push value (bij != 0)
                        cvalues[k] = xb[i];
                        // increment pointer
                        k++;
                    } else {
                        // remove index @ k
                        cindex.splice(k, 1);
                    }
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMatAlgo05xSfSf": (()=>createMatAlgo05xSfSf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/DimensionError.js [app-client] (ecmascript)");
;
;
var name = 'matAlgo05xSfSf';
var dependencies = [
    'typed',
    'equalScalar'
];
var createMatAlgo05xSfSf = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar } = _ref;
    /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */ return function matAlgo05xSfSf(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // sparse matrix arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate dimensions
        if (asize.length !== bsize.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$DimensionError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DimensionError"](asize.length, bsize.length);
        }
        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        }
        // rows & columns
        var rows = asize[0];
        var columns = asize[1];
        // datatype
        var dt;
        // equal signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // callback signature to use
        var cf = callback;
        // process data types
        if (typeof adt === 'string' && adt === bdt && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signature that matches (dt, dt)
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
            // callback
            cf = typed.find(callback, [
                dt,
                dt
            ]);
        }
        // result arrays
        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // workspaces
        var xa = cvalues ? [] : undefined;
        var xb = cvalues ? [] : undefined;
        // marks indicating we have a value in x for a given column
        var wa = [];
        var wb = [];
        // vars
        var i, j, k, k1;
        // loop columns
        for(j = 0; j < columns; j++){
            // update cptr
            cptr[j] = cindex.length;
            // columns mark
            var mark = j + 1;
            // loop values A(:,j)
            for(k = aptr[j], k1 = aptr[j + 1]; k < k1; k++){
                // row
                i = aindex[k];
                // push index
                cindex.push(i);
                // update workspace
                wa[i] = mark;
                // check we need to process values
                if (xa) {
                    xa[i] = avalues[k];
                }
            }
            // loop values B(:,j)
            for(k = bptr[j], k1 = bptr[j + 1]; k < k1; k++){
                // row
                i = bindex[k];
                // check row existed in A
                if (wa[i] !== mark) {
                    // push index
                    cindex.push(i);
                }
                // update workspace
                wb[i] = mark;
                // check we need to process values
                if (xb) {
                    xb[i] = bvalues[k];
                }
            }
            // check we need to process values (non pattern matrix)
            if (cvalues) {
                // initialize first index in j
                k = cptr[j];
                // loop index in j
                while(k < cindex.length){
                    // row
                    i = cindex[k];
                    // marks
                    var wai = wa[i];
                    var wbi = wb[i];
                    // check Aij or Bij are nonzero
                    if (wai === mark || wbi === mark) {
                        // matrix values @ i,j
                        var va = wai === mark ? xa[i] : zero;
                        var vb = wbi === mark ? xb[i] : zero;
                        // Cij
                        var vc = cf(va, vb);
                        // check for zero
                        if (!eq(vc, zero)) {
                            // push value
                            cvalues.push(vc);
                            // increment pointer
                            k++;
                        } else {
                            // remove value @ i, do not increment pointer
                            cindex.splice(k, 1);
                        }
                    }
                }
            }
        }
        // update cptr
        cptr[columns] = cindex.length;
        // return sparse matrix
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                rows,
                columns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createImmutableDenseMatrixClass": (()=>createImmutableDenseMatrixClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
var name = 'ImmutableDenseMatrix';
var dependencies = [
    'smaller',
    'DenseMatrix'
];
var createImmutableDenseMatrixClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { smaller, DenseMatrix } = _ref;
    function ImmutableDenseMatrix(data, datatype) {
        if (!(this instanceof ImmutableDenseMatrix)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(datatype)) {
            throw new Error('Invalid datatype: ' + datatype);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(data) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data)) {
            // use DenseMatrix implementation
            var matrix = new DenseMatrix(data, datatype);
            // internal structures
            this._data = matrix._data;
            this._size = matrix._size;
            this._datatype = matrix._datatype;
            this._min = null;
            this._max = null;
        } else if (data && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.data) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data.size)) {
            // initialize fields from JSON representation
            this._data = data.data;
            this._size = data.size;
            this._datatype = data.datatype;
            this._min = typeof data.min !== 'undefined' ? data.min : null;
            this._max = typeof data.max !== 'undefined' ? data.max : null;
        } else if (data) {
            // unsupported type
            throw new TypeError('Unsupported type of data (' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(data) + ')');
        } else {
            // nothing provided
            this._data = [];
            this._size = [
                0
            ];
            this._datatype = datatype;
            this._min = null;
            this._max = null;
        }
    }
    ImmutableDenseMatrix.prototype = new DenseMatrix();
    /**
   * Attach type information
   */ ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | ImmutableDenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */ ImmutableDenseMatrix.prototype.subset = function(index) {
        switch(arguments.length){
            case 1:
                {
                    // use base implementation
                    var m = DenseMatrix.prototype.subset.call(this, index);
                    // check result is a matrix
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(m)) {
                        // return immutable matrix
                        return new ImmutableDenseMatrix({
                            data: m._data,
                            size: m._size,
                            datatype: m._datatype
                        });
                    }
                    return m;
                }
            // intentional fall through
            case 2:
            case 3:
                throw new Error('Cannot invoke set subset on an Immutable Matrix instance');
            default:
                throw new SyntaxError('Wrong number of arguments');
        }
    };
    /**
   * Replace a single element in the matrix.
   * @param {Number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {ImmutableDenseMatrix} self
   */ ImmutableDenseMatrix.prototype.set = function() {
        throw new Error('Cannot invoke set on an Immutable Matrix instance');
    };
    /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {Number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */ ImmutableDenseMatrix.prototype.resize = function() {
        throw new Error('Cannot invoke resize on an Immutable Matrix instance');
    };
    /**
   * Disallows reshaping in favor of immutability.
   *
   * @throws {Error} Operation not allowed
   */ ImmutableDenseMatrix.prototype.reshape = function() {
        throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
    };
    /**
   * Create a clone of the matrix
   * @return {ImmutableDenseMatrix} clone
   */ ImmutableDenseMatrix.prototype.clone = function() {
        return new ImmutableDenseMatrix({
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._data),
            size: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._size),
            datatype: this._datatype
        });
    };
    /**
   * Get a JSON representation of the matrix
   * @returns {Object}
   */ ImmutableDenseMatrix.prototype.toJSON = function() {
        return {
            mathjs: 'ImmutableDenseMatrix',
            data: this._data,
            size: this._size,
            datatype: this._datatype
        };
    };
    /**
   * Generate a matrix from a JSON object
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {ImmutableDenseMatrix}
   */ ImmutableDenseMatrix.fromJSON = function(json) {
        return new ImmutableDenseMatrix(json);
    };
    /**
   * Swap rows i and j in Matrix.
   *
   * @param {Number} i       Matrix row index 1
   * @param {Number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */ ImmutableDenseMatrix.prototype.swapRows = function() {
        throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
    };
    /**
   * Calculate the minimum value in the set
   * @return {Number | undefined} min
   */ ImmutableDenseMatrix.prototype.min = function() {
        // check min has been calculated before
        if (this._min === null) {
            // minimum
            var m = null;
            // compute min
            this.forEach(function(v) {
                if (m === null || smaller(v, m)) {
                    m = v;
                }
            });
            this._min = m !== null ? m : undefined;
        }
        return this._min;
    };
    /**
   * Calculate the maximum value in the set
   * @return {Number | undefined} max
   */ ImmutableDenseMatrix.prototype.max = function() {
        // check max has been calculated before
        if (this._max === null) {
            // maximum
            var m = null;
            // compute max
            this.forEach(function(v) {
                if (m === null || smaller(m, v)) {
                    m = v;
                }
            });
            this._max = m !== null ? m : undefined;
        }
        return this._max;
    };
    return ImmutableDenseMatrix;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIndexClass": (()=>createIndexClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
;
var name = 'Index';
var dependencies = [
    'ImmutableDenseMatrix',
    'getMatrixDataType'
];
var createIndexClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { ImmutableDenseMatrix, getMatrixDataType } = _ref;
    /**
   * Create an index. An Index can store ranges and sets for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Usage:
   *     const index = new Index(range1, range2, matrix1, array1, ...)
   *
   * Where each parameter can be any of:
   *     A number
   *     A string (containing a name of an object property)
   *     An instance of Range
   *     An Array with the Set values
   *     An Array with Booleans
   *     A Matrix with the Set values
   *     A Matrix with Booleans
   *
   * The parameters start, end, and step must be integer numbers.
   *
   * @class Index
   * @Constructor Index
   * @param {...*} ranges
   */ function Index(ranges) {
        if (!(this instanceof Index)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        this._dimensions = [];
        this._sourceSize = [];
        this._isScalar = true;
        for(var i = 0, ii = arguments.length; i < ii; i++){
            var arg = arguments[i];
            var argIsArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(arg);
            var argIsMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(arg);
            var argType = typeof arg;
            var sourceSize = null;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRange"])(arg)) {
                this._dimensions.push(arg);
                this._isScalar = false;
            } else if (argIsArray || argIsMatrix) {
                // create matrix
                var m = void 0;
                if (getMatrixDataType(arg) === 'boolean') {
                    if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());
                    if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());
                    sourceSize = arg.valueOf().length;
                } else {
                    m = _createImmutableMatrix(arg.valueOf());
                }
                this._dimensions.push(m);
                // size
                var size = m.size();
                // scalar
                if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {
                    this._isScalar = false;
                }
            } else if (argType === 'number') {
                this._dimensions.push(_createImmutableMatrix([
                    arg
                ]));
            } else if (argType === 'bigint') {
                this._dimensions.push(_createImmutableMatrix([
                    Number(arg)
                ]));
            } else if (argType === 'string') {
                // object property (arguments.count should be 1)
                this._dimensions.push(arg);
            } else {
                throw new TypeError('Dimension must be an Array, Matrix, number, bigint, string, or Range');
            }
            this._sourceSize.push(sourceSize);
        // TODO: implement support for wildcard '*'
        }
    }
    /**
   * Attach type information
   */ Index.prototype.type = 'Index';
    Index.prototype.isIndex = true;
    function _createImmutableMatrix(arg) {
        // loop array elements
        for(var i = 0, l = arg.length; i < l; i++){
            if (typeof arg[i] !== 'number' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(arg[i])) {
                throw new TypeError('Index parameters must be positive integer numbers');
            }
        }
        // create matrix
        return new ImmutableDenseMatrix(arg);
    }
    /**
   * Create a clone of the index
   * @memberof Index
   * @return {Index} clone
   */ Index.prototype.clone = function() {
        var index = new Index();
        index._dimensions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this._dimensions);
        index._isScalar = this._isScalar;
        index._sourceSize = this._sourceSize;
        return index;
    };
    /**
   * Create an index from an array with ranges/numbers
   * @memberof Index
   * @param {Array.<Array | number>} ranges
   * @return {Index} index
   * @private
   */ Index.create = function(ranges) {
        var index = new Index();
        Index.apply(index, ranges);
        return index;
    };
    /**
   * Retrieve the size of the index, the number of elements for each dimension.
   * @memberof Index
   * @returns {number[]} size
   */ Index.prototype.size = function() {
        var size = [];
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            var d = this._dimensions[i];
            size[i] = typeof d === 'string' ? 1 : d.size()[0];
        }
        return size;
    };
    /**
   * Get the maximum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} max
   */ Index.prototype.max = function() {
        var values = [];
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            var range = this._dimensions[i];
            values[i] = typeof range === 'string' ? range : range.max();
        }
        return values;
    };
    /**
   * Get the minimum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} min
   */ Index.prototype.min = function() {
        var values = [];
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            var range = this._dimensions[i];
            values[i] = typeof range === 'string' ? range : range.min();
        }
        return values;
    };
    /**
   * Loop over each of the ranges of the index
   * @memberof Index
   * @param {Function} callback   Called for each range with a Range as first
   *                              argument, the dimension as second, and the
   *                              index object as third.
   */ Index.prototype.forEach = function(callback) {
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            callback(this._dimensions[i], i, this);
        }
    };
    /**
   * Retrieve the dimension for the given index
   * @memberof Index
   * @param {Number} dim                  Number of the dimension
   * @returns {Range | null} range
   */ Index.prototype.dimension = function(dim) {
        if (typeof dim !== 'number') {
            return null;
        }
        return this._dimensions[dim] || null;
    };
    /**
   * Test whether this index contains an object property
   * @returns {boolean} Returns true if the index is an object property
   */ Index.prototype.isObjectProperty = function() {
        return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
    };
    /**
   * Returns the object property name when the Index holds a single object property,
   * else returns null
   * @returns {string | null}
   */ Index.prototype.getObjectProperty = function() {
        return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    /**
   * Test whether this index contains only a single value.
   *
   * This is the case when the index is created with only scalar values as ranges,
   * not for ranges resolving into a single value.
   * @memberof Index
   * @return {boolean} isScalar
   */ Index.prototype.isScalar = function() {
        return this._isScalar;
    };
    /**
   * Expand the Index into an array.
   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
   * @memberof Index
   * @returns {Array} array
   */ Index.prototype.toArray = function() {
        var array = [];
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            var dimension = this._dimensions[i];
            array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
        }
        return array;
    };
    /**
   * Get the primitive value of the Index, a two dimensional array.
   * Equivalent to Index.toArray().
   * @memberof Index
   * @returns {Array} array
   */ Index.prototype.valueOf = Index.prototype.toArray;
    /**
   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
   * @memberof Index
   * @returns {String} str
   */ Index.prototype.toString = function() {
        var strings = [];
        for(var i = 0, ii = this._dimensions.length; i < ii; i++){
            var dimension = this._dimensions[i];
            if (typeof dimension === 'string') {
                strings.push(JSON.stringify(dimension));
            } else {
                strings.push(dimension.toString());
            }
        }
        return '[' + strings.join(', ') + ']';
    };
    /**
   * Get a JSON representation of the Index
   * @memberof Index
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   */ Index.prototype.toJSON = function() {
        return {
            mathjs: 'Index',
            dimensions: this._dimensions
        };
    };
    /**
   * Instantiate an Index from a JSON object
   * @memberof Index
   * @param {Object} json A JSON object structured as:
   *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   * @return {Index}
   */ Index.fromJSON = function(json) {
        return Index.create(json.dimensions);
    };
    return Index;
}, {
    isClass: true
});
/**
 * Receives an array of booleans and returns an array of Numbers for Index
 * @param {Array} booleanArrayIndex An array of booleans
 * @return {Array} A set of numbers ready for index
 */ function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
    // gets an array of booleans and returns an array of numbers
    var indexOfNumbers = [];
    booleanArrayIndex.forEach((bool, idx)=>{
        if (bool) {
            indexOfNumbers.push(idx);
        }
    });
    return indexOfNumbers;
}
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFibonacciHeapClass": (()=>createFibonacciHeapClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'FibonacciHeap';
var dependencies = [
    'smaller',
    'larger'
];
var createFibonacciHeapClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { smaller, larger } = _ref;
    var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);
    /**
   * Fibonacci Heap implementation, used interally for Matrix math.
   * @class FibonacciHeap
   * @constructor FibonacciHeap
   */ function FibonacciHeap() {
        if (!(this instanceof FibonacciHeap)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        // initialize fields
        this._minimum = null;
        this._size = 0;
    }
    /**
   * Attach type information
   */ FibonacciHeap.prototype.type = 'FibonacciHeap';
    FibonacciHeap.prototype.isFibonacciHeap = true;
    /**
   * Inserts a new data element into the heap. No heap consolidation is
   * performed at this time, the new node is simply inserted into the root
   * list of this heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.insert = function(key, value) {
        // create node
        var node = {
            key,
            value,
            degree: 0
        };
        // check we have a node in the minimum
        if (this._minimum) {
            // minimum node
            var minimum = this._minimum;
            // update left & right of node
            node.left = minimum;
            node.right = minimum.right;
            minimum.right = node;
            node.right.left = node;
            // update minimum node in heap if needed
            if (smaller(key, minimum.key)) {
                // node has a smaller key, use it as minimum
                this._minimum = node;
            }
        } else {
            // set left & right
            node.left = node;
            node.right = node;
            // this is the first node
            this._minimum = node;
        }
        // increment number of nodes in heap
        this._size++;
        // return node
        return node;
    };
    /**
   * Returns the number of nodes in heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.size = function() {
        return this._size;
    };
    /**
   * Removes all elements from this heap.
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.clear = function() {
        this._minimum = null;
        this._size = 0;
    };
    /**
   * Returns true if the heap is empty, otherwise false.
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.isEmpty = function() {
        return this._size === 0;
    };
    /**
   * Extracts the node with minimum key from heap. Amortized running
   * time: O(log n).
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.extractMinimum = function() {
        // node to remove
        var node = this._minimum;
        // check we have a minimum
        if (node === null) {
            return node;
        }
        // current minimum
        var minimum = this._minimum;
        // get number of children
        var numberOfChildren = node.degree;
        // pointer to the first child
        var x = node.child;
        // for each child of node do...
        while(numberOfChildren > 0){
            // store node in right side
            var tempRight = x.right;
            // remove x from child list
            x.left.right = x.right;
            x.right.left = x.left;
            // add x to root list of heap
            x.left = minimum;
            x.right = minimum.right;
            minimum.right = x;
            x.right.left = x;
            // set Parent[x] to null
            x.parent = null;
            x = tempRight;
            numberOfChildren--;
        }
        // remove node from root list of heap
        node.left.right = node.right;
        node.right.left = node.left;
        // update minimum
        if (node === node.right) {
            // empty
            minimum = null;
        } else {
            // update minimum
            minimum = node.right;
            // we need to update the pointer to the root with minimum key
            minimum = _findMinimumNode(minimum, this._size);
        }
        // decrement size of heap
        this._size--;
        // update minimum
        this._minimum = minimum;
        // return node
        return node;
    };
    /**
   * Removes a node from the heap given the reference to the node. The trees
   * in the heap will be consolidated, if necessary. This operation may fail
   * to remove the correct element if there are nodes with key value -Infinity.
   * Running time: O(log n) amortized.
   * @memberof FibonacciHeap
   */ FibonacciHeap.prototype.remove = function(node) {
        // decrease key value
        this._minimum = _decreaseKey(this._minimum, node, -1);
        // remove the smallest
        this.extractMinimum();
    };
    /**
   * Decreases the key value for a heap node, given the new value to take on.
   * The structure of the heap may be changed and will not be consolidated.
   * Running time: O(1) amortized.
   * @memberof FibonacciHeap
   */ function _decreaseKey(minimum, node, key) {
        // set node key
        node.key = key;
        // get parent node
        var parent = node.parent;
        if (parent && smaller(node.key, parent.key)) {
            // remove node from parent
            _cut(minimum, node, parent);
            // remove all nodes from parent to the root parent
            _cascadingCut(minimum, parent);
        }
        // update minimum node if needed
        if (smaller(node.key, minimum.key)) {
            minimum = node;
        }
        // return minimum
        return minimum;
    }
    /**
   * The reverse of the link operation: removes node from the child list of parent.
   * This method assumes that min is non-null. Running time: O(1).
   * @memberof FibonacciHeap
   */ function _cut(minimum, node, parent) {
        // remove node from parent children and decrement Degree[parent]
        node.left.right = node.right;
        node.right.left = node.left;
        parent.degree--;
        // reset y.child if necessary
        if (parent.child === node) {
            parent.child = node.right;
        }
        // remove child if degree is 0
        if (parent.degree === 0) {
            parent.child = null;
        }
        // add node to root list of heap
        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node;
        // set parent[node] to null
        node.parent = null;
        // set mark[node] to false
        node.mark = false;
    }
    /**
   * Performs a cascading cut operation. This cuts node from its parent and then
   * does the same for its parent, and so on up the tree.
   * Running time: O(log n); O(1) excluding the recursion.
   * @memberof FibonacciHeap
   */ function _cascadingCut(minimum, node) {
        // store parent node
        var parent = node.parent;
        // if there's a parent...
        if (!parent) {
            return;
        }
        // if node is unmarked, set it marked
        if (!node.mark) {
            node.mark = true;
        } else {
            // it's marked, cut it from parent
            _cut(minimum, node, parent);
            // cut its parent as well
            _cascadingCut(parent);
        }
    }
    /**
   * Make the first node a child of the second one. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */ var _linkNodes = function _linkNodes(node, parent) {
        // remove node from root list of heap
        node.left.right = node.right;
        node.right.left = node.left;
        // make node a Child of parent
        node.parent = parent;
        if (!parent.child) {
            parent.child = node;
            node.right = node;
            node.left = node;
        } else {
            node.left = parent.child;
            node.right = parent.child.right;
            parent.child.right = node;
            node.right.left = node;
        }
        // increase degree[parent]
        parent.degree++;
        // set mark[node] false
        node.mark = false;
    };
    function _findMinimumNode(minimum, size) {
        // to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree
        var arraySize = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
        // create list with initial capacity
        var array = new Array(arraySize);
        // find the number of root nodes.
        var numRoots = 0;
        var x = minimum;
        if (x) {
            numRoots++;
            x = x.right;
            while(x !== minimum){
                numRoots++;
                x = x.right;
            }
        }
        // vars
        var y;
        // For each node in root list do...
        while(numRoots > 0){
            // access this node's degree..
            var d = x.degree;
            // get next node
            var next = x.right;
            // check if there is a node already in array with the same degree
            while(true){
                // get node with the same degree is any
                y = array[d];
                if (!y) {
                    break;
                }
                // make one node with the same degree a child of the other, do this based on the key value.
                if (larger(x.key, y.key)) {
                    var temp = y;
                    y = x;
                    x = temp;
                }
                // make y a child of x
                _linkNodes(y, x);
                // we have handled this degree, go to next one.
                array[d] = null;
                d++;
            }
            // save this node for later when we might encounter another of the same degree.
            array[d] = x;
            // move forward through list.
            x = next;
            numRoots--;
        }
        // Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].
        minimum = null;
        // loop nodes in array
        for(var i = 0; i < arraySize; i++){
            // get current node
            y = array[i];
            if (!y) {
                continue;
            }
            // check if we have a linked list
            if (minimum) {
                // First remove node from root list.
                y.left.right = y.right;
                y.right.left = y.left;
                // now add to root list, again.
                y.left = minimum;
                y.right = minimum.right;
                minimum.right = y;
                y.right.left = y;
                // check if this is a new min.
                if (smaller(y.key, minimum.key)) {
                    minimum = y;
                }
            } else {
                minimum = y;
            }
        }
        return minimum;
    }
    return FibonacciHeap;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/function/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createIndex": (()=>createIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'index';
var dependencies = [
    'typed',
    'Index'
];
var createIndex = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Index } = _ref;
    /**
   * Create an index. An Index can store ranges having start, step, and end
   * for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Syntax:
   *
   *     math.index(range1, range2, ...)
   *
   * Where each range can be any of:
   *
   * - A number
   * - A string for getting/setting an object property
   * - An instance of `Range`
   * - A one-dimensional Array or a Matrix with numbers or booleans
   *
   * Indexes must be zero-based, integer numbers.
   *
   * Examples:
   *
   *    const b = [1, 2, 3, 4, 5]
   *    math.subset(b, math.index([1, 2, 3]))                         // returns [2, 3, 4]
   *    math.subset(b, math.index([false, true, true, true, false]))  // returns [2, 3, 4]
   *
   *    const a = math.matrix([[1, 2], [3, 4]])
   *    a.subset(math.index(0, 1))             // returns 2
   *    a.subset(math.index(0, [false, true])) // returns 2
   *
   * See also:
   *
   *    bignumber, boolean, complex, matrix, number, string, unit
   *
   * @param {...*} ranges   Zero or more ranges or numbers.
   * @return {Index}        Returns the created index
   */ return typed(name, {
        '...number | string | BigNumber | Range | Array | Matrix': function number__string__BigNumber__Range__Array__Matrix(args) {
            var ranges = args.map(function(arg) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(arg)) {
                    return arg.toNumber(); // convert BigNumber to Number
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(arg) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(arg)) {
                    return arg.map(function(elem) {
                        // convert BigNumber to Number
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBigNumber"])(elem) ? elem.toNumber() : elem;
                    });
                } else {
                    return arg;
                }
            });
            var res = new Index();
            Index.apply(res, ranges);
            return res;
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/matrix/Spa.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSpaClass": (()=>createSpaClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'Spa';
var dependencies = [
    'addScalar',
    'equalScalar',
    'FibonacciHeap'
];
var createSpaClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { addScalar, equalScalar, FibonacciHeap } = _ref;
    /**
   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array
   * of the vector elements and an ordered list of non-zero elements.
   */ function Spa() {
        if (!(this instanceof Spa)) {
            throw new SyntaxError('Constructor must be called with the new operator');
        }
        // allocate vector, TODO use typed arrays
        this._values = [];
        this._heap = new FibonacciHeap();
    }
    /**
   * Attach type information
   */ Spa.prototype.type = 'Spa';
    Spa.prototype.isSpa = true;
    /**
   * Set the value for index i.
   *
   * @param {number} i                       The index
   * @param {number | BigNumber | Complex}   The value at index i
   */ Spa.prototype.set = function(i, v) {
        // check we have a value @ i
        if (!this._values[i]) {
            // insert in heap
            var node = this._heap.insert(i, v);
            // set the value @ i
            this._values[i] = node;
        } else {
            // update the value @ i
            this._values[i].value = v;
        }
    };
    Spa.prototype.get = function(i) {
        var node = this._values[i];
        if (node) {
            return node.value;
        }
        return 0;
    };
    Spa.prototype.accumulate = function(i, v) {
        // node @ i
        var node = this._values[i];
        if (!node) {
            // insert in heap
            node = this._heap.insert(i, v);
            // initialize value
            this._values[i] = node;
        } else {
            // accumulate value
            node.value = addScalar(node.value, v);
        }
    };
    Spa.prototype.forEach = function(from, to, callback) {
        // references
        var heap = this._heap;
        var values = this._values;
        // nodes
        var nodes = [];
        // node with minimum key, save it
        var node = heap.extractMinimum();
        if (node) {
            nodes.push(node);
        }
        // extract nodes from heap (ordered)
        while(node && node.key <= to){
            // check it is in range
            if (node.key >= from) {
                // check value is not zero
                if (!equalScalar(node.value, 0)) {
                    // invoke callback
                    callback(node.key, node.value, this);
                }
            }
            // extract next node, save it
            node = heap.extractMinimum();
            if (node) {
                nodes.push(node);
            }
        }
        // reinsert all nodes in heap
        for(var i = 0; i < nodes.length; i++){
            // current node
            var n = nodes[i];
            // insert node in heap
            node = heap.insert(n.key, n.value);
            // update values
            values[node.key] = node;
        }
    };
    Spa.prototype.swap = function(i, j) {
        // node @ i and j
        var nodei = this._values[i];
        var nodej = this._values[j];
        // check we need to insert indeces
        if (!nodei && nodej) {
            // insert in heap
            nodei = this._heap.insert(i, nodej.value);
            // remove from heap
            this._heap.remove(nodej);
            // set values
            this._values[i] = nodei;
            this._values[j] = undefined;
        } else if (nodei && !nodej) {
            // insert in heap
            nodej = this._heap.insert(j, nodei.value);
            // remove from heap
            this._heap.remove(nodei);
            // set values
            this._values[j] = nodej;
            this._values[i] = undefined;
        } else if (nodei && nodej) {
            // swap values
            var v = nodei.value;
            nodei.value = nodej.value;
            nodej.value = v;
        }
    };
    return Spa;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/unit/Unit.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnitClass": (()=>createUnitClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/defineProperty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/function.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/constants.js [app-client] (ecmascript)");
;
;
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
;
;
;
;
;
;
var name = 'Unit';
var dependencies = [
    '?on',
    'config',
    'addScalar',
    'subtractScalar',
    'multiplyScalar',
    'divideScalar',
    'pow',
    'abs',
    'fix',
    'round',
    'equal',
    'isNumeric',
    'format',
    'toBest',
    'number',
    'Complex',
    'BigNumber',
    'Fraction'
];
var createUnitClass = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { on, config, addScalar, subtractScalar, multiplyScalar, divideScalar, pow, abs, fix, round, equal, isNumeric, format, toBest, number: _number, Complex, BigNumber: _BigNumber, Fraction: _Fraction } = _ref;
    var toNumber = _number;
    /**
   * A unit can be constructed in the following ways:
   *
   *     const a = new Unit(value, valuelessUnit)
   *     const b = new Unit(null, valuelessUnit)
   *     const c = Unit.parse(str)
   *
   * Example usage:
   *
   *     const a = new Unit(5, 'cm')               // 50 mm
   *     const b = Unit.parse('23 kg')             // 23 kg
   *     const c = math.in(a, new Unit(null, 'm')  // 0.05 m
   *     const d = new Unit(9.81, "m/s^2")         // 9.81 m/s^2
   *
   * @class Unit
   * @constructor Unit
   * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   */ function Unit(value, valuelessUnit) {
        if (!(this instanceof Unit)) {
            throw new Error('Constructor must be called with the new operator');
        }
        if (!(value === null || value === undefined || isNumeric(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isComplex"])(value))) {
            throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
        }
        this.fixPrefix = false; // if true, function format will not search for the
        // best prefix but leave it as initially provided.
        // fixPrefix is set true by the method Unit.to
        // The justification behind this is that if the constructor is explicitly called,
        // the caller wishes the units to be returned exactly as supplied.
        this.skipAutomaticSimplification = true;
        if (valuelessUnit === undefined) {
            this.units = [];
            this.dimensions = BASE_DIMENSIONS.map((x)=>0);
        } else if (typeof valuelessUnit === 'string') {
            var u = Unit.parse(valuelessUnit);
            this.units = u.units;
            this.dimensions = u.dimensions;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(valuelessUnit) && valuelessUnit.value === null) {
            // clone from valuelessUnit
            this.fixPrefix = valuelessUnit.fixPrefix;
            this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
            this.dimensions = valuelessUnit.dimensions.slice(0);
            this.units = valuelessUnit.units.map((u)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, u));
        } else {
            throw new TypeError('Second parameter in Unit constructor must be a string or valueless Unit');
        }
        this.value = this._normalize(value);
    }
    /**
   * Attach type information
   */ Object.defineProperty(Unit, 'name', {
        value: 'Unit'
    });
    Unit.prototype.constructor = Unit;
    Unit.prototype.type = 'Unit';
    Unit.prototype.isUnit = true;
    // private variables and functions for the Unit parser
    var text, index, c;
    function skipWhitespace() {
        while(c === ' ' || c === '\t'){
            next();
        }
    }
    function isDigitDot(c) {
        return c >= '0' && c <= '9' || c === '.';
    }
    function isDigit(c) {
        return c >= '0' && c <= '9';
    }
    function next() {
        index++;
        c = text.charAt(index);
    }
    function revert(oldIndex) {
        index = oldIndex;
        c = text.charAt(index);
    }
    function parseNumber() {
        var number = '';
        var oldIndex = index;
        if (c === '+') {
            next();
        } else if (c === '-') {
            number += c;
            next();
        }
        if (!isDigitDot(c)) {
            // a + or - must be followed by a digit
            revert(oldIndex);
            return null;
        }
        // get number, can have a single dot
        if (c === '.') {
            number += c;
            next();
            if (!isDigit(c)) {
                // this is no legal number, it is just a dot
                revert(oldIndex);
                return null;
            }
        } else {
            while(isDigit(c)){
                number += c;
                next();
            }
            if (c === '.') {
                number += c;
                next();
            }
        }
        while(isDigit(c)){
            number += c;
            next();
        }
        // check for exponential notation like "2.3e-4" or "1.23e50"
        if (c === 'E' || c === 'e') {
            // The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"
            var tentativeNumber = '';
            var tentativeIndex = index;
            tentativeNumber += c;
            next();
            if (c === '+' || c === '-') {
                tentativeNumber += c;
                next();
            }
            // Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)
            if (!isDigit(c)) {
                // The e or E must belong to something else, so return the number without the e or E.
                revert(tentativeIndex);
                return number;
            }
            // We can now safely say that this is scientific notation.
            number = number + tentativeNumber;
            while(isDigit(c)){
                number += c;
                next();
            }
        }
        return number;
    }
    function parseUnit() {
        var unitName = '';
        // Alphanumeric characters only; matches [a-zA-Z0-9]
        while(isDigit(c) || Unit.isValidAlpha(c)){
            unitName += c;
            next();
        }
        // Must begin with [a-zA-Z]
        var firstC = unitName.charAt(0);
        if (Unit.isValidAlpha(firstC)) {
            return unitName;
        } else {
            return null;
        }
    }
    function parseCharacter(toFind) {
        if (c === toFind) {
            next();
            return toFind;
        } else {
            return null;
        }
    }
    /**
   * Parse a string into a unit. The value of the unit is parsed as number,
   * BigNumber, or Fraction depending on the math.js config setting `number`.
   *
   * Throws an exception if the provided string does not contain a valid unit or
   * cannot be parsed.
   * @memberof Unit
   * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
   * @return {Unit} unit
   */ Unit.parse = function(str, options) {
        options = options || {};
        text = str;
        index = -1;
        c = '';
        if (typeof text !== 'string') {
            throw new TypeError('Invalid argument in Unit.parse, string expected');
        }
        var unit = new Unit();
        unit.units = [];
        var powerMultiplierCurrent = 1;
        var expectingUnit = false;
        // A unit should follow this pattern:
        // [number] ...[ [*/] unit[^number] ]
        // unit[^number] ... [ [*/] unit[^number] ]
        // Rules:
        // number is any floating point number.
        // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
        // The string may optionally begin with a number.
        // Each unit may optionally be followed by ^number.
        // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
        //   2m^2kg/s^2
        // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
        //   4erg
        next();
        skipWhitespace();
        // Optional number at the start of the string
        var valueStr = parseNumber();
        var value = null;
        if (valueStr) {
            if (config.number === 'BigNumber') {
                value = new _BigNumber(valueStr);
            } else if (config.number === 'Fraction') {
                try {
                    // not all numbers can be turned in Fractions, for example very small numbers not
                    value = new _Fraction(valueStr);
                } catch (err) {
                    value = parseFloat(valueStr);
                }
            } else {
                // number
                value = parseFloat(valueStr);
            }
            skipWhitespace(); // Whitespace is not required here
            // handle multiplication or division right after the value, like '1/s'
            if (parseCharacter('*')) {
                powerMultiplierCurrent = 1;
                expectingUnit = true;
            } else if (parseCharacter('/')) {
                powerMultiplierCurrent = -1;
                expectingUnit = true;
            }
        }
        // Stack to keep track of powerMultipliers applied to each parentheses group
        var powerMultiplierStack = [];
        // Running product of all elements in powerMultiplierStack
        var powerMultiplierStackProduct = 1;
        while(true){
            skipWhitespace();
            // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
            // A '(' will always appear directly before a unit.
            while(c === '('){
                powerMultiplierStack.push(powerMultiplierCurrent);
                powerMultiplierStackProduct *= powerMultiplierCurrent;
                powerMultiplierCurrent = 1;
                next();
                skipWhitespace();
            }
            // Is there something here?
            var uStr = void 0;
            if (c) {
                var oldC = c;
                uStr = parseUnit();
                if (uStr === null) {
                    throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
                }
            } else {
                break;
            }
            // Verify the unit exists and get the prefix (if any)
            var res = _findUnit(uStr);
            if (res === null) {
                // Unit not found.
                throw new SyntaxError('Unit "' + uStr + '" not found.');
            }
            var power = powerMultiplierCurrent * powerMultiplierStackProduct;
            // Is there a "^ number"?
            skipWhitespace();
            if (parseCharacter('^')) {
                skipWhitespace();
                var p = parseNumber();
                if (p === null) {
                    // No valid number found for the power!
                    throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
                }
                power *= p;
            }
            // Add the unit to the list
            unit.units.push({
                unit: res.unit,
                prefix: res.prefix,
                power
            });
            for(var i = 0; i < BASE_DIMENSIONS.length; i++){
                unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
            }
            // Check for and consume closing parentheses, popping from the stack.
            // A ')' will always follow a unit.
            skipWhitespace();
            while(c === ')'){
                if (powerMultiplierStack.length === 0) {
                    throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
                }
                powerMultiplierStackProduct /= powerMultiplierStack.pop();
                next();
                skipWhitespace();
            }
            // "*" and "/" should mean we are expecting something to come next.
            // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
            expectingUnit = false;
            if (parseCharacter('*')) {
                // explicit multiplication
                powerMultiplierCurrent = 1;
                expectingUnit = true;
            } else if (parseCharacter('/')) {
                // division
                powerMultiplierCurrent = -1;
                expectingUnit = true;
            } else {
                // implicit multiplication
                powerMultiplierCurrent = 1;
            }
            // Replace the unit into the auto unit system
            if (res.unit.base) {
                var baseDim = res.unit.base.key;
                UNIT_SYSTEMS.auto[baseDim] = {
                    unit: res.unit,
                    prefix: res.prefix
                };
            }
        }
        // Has the string been entirely consumed?
        skipWhitespace();
        if (c) {
            throw new SyntaxError('Could not parse: "' + str + '"');
        }
        // Is there a trailing slash?
        if (expectingUnit) {
            throw new SyntaxError('Trailing characters: "' + str + '"');
        }
        // Is the parentheses stack empty?
        if (powerMultiplierStack.length !== 0) {
            throw new SyntaxError('Unmatched "(" in "' + text + '"');
        }
        // Are there any units at all?
        if (unit.units.length === 0 && !options.allowNoUnits) {
            throw new SyntaxError('"' + str + '" contains no units');
        }
        unit.value = value !== undefined ? unit._normalize(value) : null;
        return unit;
    };
    /**
   * create a copy of this unit
   * @memberof Unit
   * @return {Unit} Returns a cloned version of the unit
   */ Unit.prototype.clone = function() {
        var unit = new Unit();
        unit.fixPrefix = this.fixPrefix;
        unit.skipAutomaticSimplification = this.skipAutomaticSimplification;
        unit.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.value);
        unit.dimensions = this.dimensions.slice(0);
        unit.units = [];
        for(var i = 0; i < this.units.length; i++){
            unit.units[i] = {};
            for(var p in this.units[i]){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(this.units[i], p)) {
                    unit.units[i][p] = this.units[i][p];
                }
            }
        }
        return unit;
    };
    /**
   * Return the type of the value of this unit
   *
   * @memberof Unit
   * @return {string} type of the value of the unit
   */ Unit.prototype.valueType = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(this.value);
    };
    /**
   * Return whether the unit is derived (such as m/s, or cm^2, but not N)
   * @memberof Unit
   * @return {boolean} True if the unit is derived
   * @private
   */ Unit.prototype._isDerived = function() {
        if (this.units.length === 0) {
            return false;
        }
        return this.units.length > 1 || Math.abs(this.units[0].power - 1.0) > 1e-15;
    };
    /**
   * Normalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number | BigNumber | Fraction | boolean} value
   * @return {number | BigNumber | Fraction | boolean} normalized value
   * @private
   */ Unit.prototype._normalize = function(value) {
        if (value === null || value === undefined || this.units.length === 0) {
            return value;
        }
        var res = value;
        var convert = Unit._getNumberConverter((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(value)); // convert to Fraction or BigNumber if needed
        for(var i = 0; i < this.units.length; i++){
            var unitValue = convert(this.units[i].unit.value);
            var unitPrefixValue = convert(this.units[i].prefix.value);
            var unitPower = convert(this.units[i].power);
            res = multiplyScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }
        return res;
    };
    /**
   * Denormalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number} value
   * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
   * @return {number} denormalized value
   * @private
   */ Unit.prototype._denormalize = function(value, prefixValue) {
        if (value === null || value === undefined || this.units.length === 0) {
            return value;
        }
        var res = value;
        var convert = Unit._getNumberConverter((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(value)); // convert to Fraction or BigNumber if needed
        for(var i = 0; i < this.units.length; i++){
            var unitValue = convert(this.units[i].unit.value);
            var unitPrefixValue = convert(this.units[i].prefix.value);
            var unitPower = convert(this.units[i].power);
            res = divideScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }
        return res;
    };
    /**
   * Find a unit from a string
   * @memberof Unit
   * @param {string} str              A string like 'cm' or 'inch'
   * @returns {Object | null} result  When found, an object with fields unit and
   *                                  prefix is returned. Else, null is returned.
   * @private
   */ var _findUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memoize"])((str)=>{
        // First, match units names exactly. For example, a user could define 'mm' as 10^-4 m, which is silly, but then we would want 'mm' to match the user-defined unit.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNITS, str)) {
            var unit = UNITS[str];
            var prefix = unit.prefixes[''];
            return {
                unit,
                prefix
            };
        }
        for(var _name in UNITS){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNITS, _name)) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endsWith"])(str, _name)) {
                    var _unit = UNITS[_name];
                    var prefixLen = str.length - _name.length;
                    var prefixName = str.substring(0, prefixLen);
                    var _prefix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : undefined;
                    if (_prefix !== undefined) {
                        // store unit, prefix, and value
                        return {
                            unit: _unit,
                            prefix: _prefix
                        };
                    }
                }
            }
        }
        return null;
    }, {
        hasher: (args)=>args[0],
        limit: 100
    });
    /**
   * Test if the given expression is a unit.
   * The unit can have a prefix but cannot have a value.
   * @memberof Unit
   * @param {string} name   A string to be tested whether it is a value less unit.
   *                        The unit can have prefix, like "cm"
   * @return {boolean}      true if the given string is a unit
   */ Unit.isValuelessUnit = function(name) {
        return _findUnit(name) !== null;
    };
    /**
   * check if this unit has given base unit
   * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
   * @memberof Unit
   * @param {BASE_UNIT | string | undefined} base
   */ Unit.prototype.hasBase = function(base) {
        if (typeof base === 'string') {
            base = BASE_UNITS[base];
        }
        if (!base) {
            return false;
        }
        // All dimensions must be the same
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
                return false;
            }
        }
        return true;
    };
    /**
   * Check if this unit has a base or bases equal to another base or bases
   * For derived units, the exponent on each base also must match
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if equal base
   */ Unit.prototype.equalBase = function(other) {
        // All dimensions must be the same
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
                return false;
            }
        }
        return true;
    };
    /**
   * Check if this unit equals another unit
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if both units are equal
   */ Unit.prototype.equals = function(other) {
        return this.equalBase(other) && equal(this.value, other.value);
    };
    /**
   * Multiply this unit with another one or with a scalar
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} product of this unit and the other unit
   */ Unit.prototype.multiply = function(_other) {
        var res = this.clone();
        var other = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(_other) ? _other : new Unit(_other);
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            // Dimensions arrays may be of different lengths. Default to 0.
            res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
        }
        // Append other's units list onto res
        for(var _i = 0; _i < other.units.length; _i++){
            // Make a shallow copy of every unit
            var inverted = _objectSpread({}, other.units[_i]);
            res.units.push(inverted);
        }
        // If at least one operand has a value, then the result should also have a value
        if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(one(other.value)) : this.value;
            var valOther = other.value === null ? other._normalize(one(this.value)) : other.value;
            res.value = multiplyScalar(valThis, valOther);
        } else {
            res.value = null;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(_other)) {
            res.skipAutomaticSimplification = false;
        }
        return getNumericIfUnitless(res);
    };
    /**
   * Divide a number by this unit
   *
   * @memberof Unit
   * @param {numeric} numerator
   * @param {unit} result of dividing numerator by this unit
   */ Unit.prototype.divideInto = function(numerator) {
        return new Unit(numerator).divide(this);
    };
    /**
   * Divide this unit by another one
   * @memberof Unit
   * @param {Unit | numeric} other
   * @return {Unit} result of dividing this unit by the other unit
   */ Unit.prototype.divide = function(_other) {
        var res = this.clone();
        var other = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(_other) ? _other : new Unit(_other);
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            // Dimensions arrays may be of different lengths. Default to 0.
            res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
        }
        // Invert and append other's units list onto res
        for(var _i2 = 0; _i2 < other.units.length; _i2++){
            // Make a shallow copy of every unit
            var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
                power: -other.units[_i2].power
            });
            res.units.push(inverted);
        }
        // If at least one operand has a value, the result should have a value
        if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(one(other.value)) : this.value;
            var valOther = other.value === null ? other._normalize(one(this.value)) : other.value;
            res.value = divideScalar(valThis, valOther);
        } else {
            res.value = null;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(_other)) {
            res.skipAutomaticSimplification = false;
        }
        return getNumericIfUnitless(res);
    };
    /**
   * Calculate the power of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} p
   * @returns {Unit}      The result: this^p
   */ Unit.prototype.pow = function(p) {
        var res = this.clone();
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            // Dimensions arrays may be of different lengths. Default to 0.
            res.dimensions[i] = (this.dimensions[i] || 0) * p;
        }
        // Adjust the power of each unit in the list
        for(var _i3 = 0; _i3 < res.units.length; _i3++){
            res.units[_i3].power *= p;
        }
        if (res.value !== null) {
            res.value = pow(res.value, p);
        // only allow numeric output, we don't want to return a Complex number
        // if (!isNumeric(res.value)) {
        //  res.value = NaN
        // }
        // Update: Complex supported now
        } else {
            res.value = null;
        }
        res.skipAutomaticSimplification = false;
        return getNumericIfUnitless(res);
    };
    /**
   * Return the numeric value of this unit if it is dimensionless, has a value, and config.predictable == false; or the original unit otherwise
   * @param {Unit} unit
   * @returns {number | Fraction | BigNumber | Unit}  The numeric value of the unit if conditions are met, or the original unit otherwise
   */ function getNumericIfUnitless(unit) {
        if (unit.equalBase(BASE_UNITS.NONE) && unit.value !== null && !config.predictable) {
            return unit.value;
        } else {
            return unit;
        }
    }
    /**
   * Create a value one with the numeric type of `typeOfValue`.
   * For example, `one(new BigNumber(3))` returns `BigNumber(1)`
   * @param {number | Fraction | BigNumber} typeOfValue
   * @returns {number | Fraction | BigNumber}
   */ function one(typeOfValue) {
        // TODO: this is a workaround to prevent the following BigNumber conversion error from throwing:
        //  "TypeError: Cannot implicitly convert a number with >15 significant digits to BigNumber"
        //  see https://github.com/josdejong/mathjs/issues/3450
        //      https://github.com/josdejong/mathjs/pull/3375
        var convert = Unit._getNumberConverter((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(typeOfValue));
        return convert(1);
    }
    /**
   * Calculate the absolute value of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} x
   * @returns {Unit}      The result: |x|, absolute value of x
   */ Unit.prototype.abs = function() {
        var ret = this.clone();
        if (ret.value !== null) {
            if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
                ret.value = abs(ret.value);
            } else {
                // To give the correct, but unexpected, results for units with an offset.
                // For example, abs(-283.15 degC) = -263.15 degC !!!
                // We must take the offset into consideration here
                var convert = ret._numberConverter(); // convert to Fraction or BigNumber if needed
                var unitValue = convert(ret.units[0].unit.value);
                var nominalOffset = convert(ret.units[0].unit.offset);
                var unitOffset = multiplyScalar(unitValue, nominalOffset);
                ret.value = subtractScalar(abs(addScalar(ret.value, unitOffset)), unitOffset);
            }
        }
        for(var i in ret.units){
            if (ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
                ret.units[i].unit = UNITS.W;
            }
        }
        return ret;
    };
    /**
   * Convert the unit to a specific unit name.
   * @memberof Unit
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
   */ Unit.prototype.to = function(valuelessUnit) {
        var value = this.value === null ? this._normalize(1) : this.value;
        var other;
        if (typeof valuelessUnit === 'string') {
            other = Unit.parse(valuelessUnit);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(valuelessUnit)) {
            other = valuelessUnit.clone();
        } else {
            throw new Error('String or Unit expected as parameter');
        }
        if (!this.equalBase(other)) {
            throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
        }
        if (other.value !== null) {
            throw new Error('Cannot convert to a unit with a value');
        }
        if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
            other.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(value);
        } else {
            /* Need to adjust value by difference in offset to convert */ var convert = Unit._getNumberConverter((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(value)); // convert to Fraction or BigNumber if needed
            var thisUnitValue = this.units[0].unit.value;
            var thisNominalOffset = this.units[0].unit.offset;
            var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
            var otherUnitValue = other.units[0].unit.value;
            var otherNominalOffset = other.units[0].unit.offset;
            var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
            other.value = addScalar(value, convert(subtractScalar(thisUnitOffset, otherUnitOffset)));
        }
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
    };
    /**
   * Return the value of the unit when represented with given valueless unit
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number} Returns the unit value as number.
   */ // TODO: deprecate Unit.toNumber? It's always better to use toNumeric
    Unit.prototype.toNumber = function(valuelessUnit) {
        return toNumber(this.toNumeric(valuelessUnit));
    };
    /**
   * Return the value of the unit in the original numeric type
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number | BigNumber | Fraction} Returns the unit value
   */ Unit.prototype.toNumeric = function(valuelessUnit) {
        var other;
        if (valuelessUnit) {
            // Allow getting the numeric value without converting to a different unit
            other = this.to(valuelessUnit);
        } else {
            other = this.clone();
        }
        if (other._isDerived() || other.units.length === 0) {
            return other._denormalize(other.value);
        } else {
            return other._denormalize(other.value, other.units[0].prefix.value);
        }
    };
    /**
   * Get a string representation of the unit.
   * @memberof Unit
   * @return {string}
   */ Unit.prototype.toString = function() {
        return this.format();
    };
    /**
   * Get a JSON representation of the unit
   * @memberof Unit
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   */ Unit.prototype.toJSON = function() {
        return {
            mathjs: 'Unit',
            value: this._denormalize(this.value),
            unit: this.units.length > 0 ? this.formatUnits() : null,
            fixPrefix: this.fixPrefix
        };
    };
    /**
   * Instantiate a Unit from a JSON object
   * @memberof Unit
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   * @return {Unit}
   */ Unit.fromJSON = function(json) {
        var _json$unit;
        var unit = new Unit(json.value, (_json$unit = json.unit) !== null && _json$unit !== void 0 ? _json$unit : undefined);
        unit.fixPrefix = json.fixPrefix || false;
        return unit;
    };
    /**
   * Returns the string representation of the unit.
   * @memberof Unit
   * @return {string}
   */ Unit.prototype.valueOf = Unit.prototype.toString;
    /**
   * Simplify this Unit's unit list and return a new Unit with the simplified list.
   * The returned Unit will contain a list of the "best" units for formatting.
   */ Unit.prototype.simplify = function() {
        var ret = this.clone();
        var proposedUnitList = [];
        // Search for a matching base
        var matchingBase;
        for(var key in currentUnitSystem){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(currentUnitSystem, key)) {
                if (ret.hasBase(BASE_UNITS[key])) {
                    matchingBase = key;
                    break;
                }
            }
        }
        if (matchingBase === 'NONE') {
            ret.units = [];
        } else {
            var matchingUnit;
            if (matchingBase) {
                // Does the unit system have a matching unit?
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(currentUnitSystem, matchingBase)) {
                    matchingUnit = currentUnitSystem[matchingBase];
                }
            }
            if (matchingUnit) {
                ret.units = [
                    {
                        unit: matchingUnit.unit,
                        prefix: matchingUnit.prefix,
                        power: 1.0
                    }
                ];
            } else {
                // Multiple units or units with powers are formatted like this:
                // 5 (kg m^2) / (s^3 mol)
                // Build an representation from the base units of the current unit system
                var missingBaseDim = false;
                for(var i = 0; i < BASE_DIMENSIONS.length; i++){
                    var baseDim = BASE_DIMENSIONS[i];
                    if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(currentUnitSystem, baseDim)) {
                            proposedUnitList.push({
                                unit: currentUnitSystem[baseDim].unit,
                                prefix: currentUnitSystem[baseDim].prefix,
                                power: ret.dimensions[i] || 0
                            });
                        } else {
                            missingBaseDim = true;
                        }
                    }
                }
                // Is the proposed unit list "simpler" than the existing one?
                if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
                    // Replace this unit list with the proposed list
                    ret.units = proposedUnitList;
                }
            }
        }
        return ret;
    };
    /**
   * Returns a new Unit in the SI system with the same value as this one
   */ Unit.prototype.toSI = function() {
        var ret = this.clone();
        var proposedUnitList = [];
        // Multiple units or units with powers are formatted like this:
        // 5 (kg m^2) / (s^3 mol)
        // Build an representation from the base units of the SI unit system
        for(var i = 0; i < BASE_DIMENSIONS.length; i++){
            var baseDim = BASE_DIMENSIONS[i];
            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNIT_SYSTEMS.si, baseDim)) {
                    proposedUnitList.push({
                        unit: UNIT_SYSTEMS.si[baseDim].unit,
                        prefix: UNIT_SYSTEMS.si[baseDim].prefix,
                        power: ret.dimensions[i] || 0
                    });
                } else {
                    throw new Error('Cannot express custom unit ' + baseDim + ' in SI units');
                }
            }
        }
        // Replace this unit list with the proposed list
        ret.units = proposedUnitList;
        ret.fixPrefix = true;
        ret.skipAutomaticSimplification = true;
        if (this.value !== null) {
            ret.value = null;
            return this.to(ret);
        }
        return ret;
    };
    /**
   * Get a string representation of the units of this Unit, without the value. The unit list is formatted as-is without first being simplified.
   * @memberof Unit
   * @return {string}
   */ Unit.prototype.formatUnits = function() {
        var strNum = '';
        var strDen = '';
        var nNum = 0;
        var nDen = 0;
        for(var i = 0; i < this.units.length; i++){
            if (this.units[i].power > 0) {
                nNum++;
                strNum += ' ' + this.units[i].prefix.name + this.units[i].unit.name;
                if (Math.abs(this.units[i].power - 1.0) > 1e-15) {
                    strNum += '^' + this.units[i].power;
                }
            } else if (this.units[i].power < 0) {
                nDen++;
            }
        }
        if (nDen > 0) {
            for(var _i4 = 0; _i4 < this.units.length; _i4++){
                if (this.units[_i4].power < 0) {
                    if (nNum > 0) {
                        strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                        if (Math.abs(this.units[_i4].power + 1.0) > 1e-15) {
                            strDen += '^' + -this.units[_i4].power;
                        }
                    } else {
                        strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                        strDen += '^' + this.units[_i4].power;
                    }
                }
            }
        }
        // Remove leading " "
        strNum = strNum.substr(1);
        strDen = strDen.substr(1);
        // Add parans for better copy/paste back into evaluate, for example, or for better pretty print formatting
        if (nNum > 1 && nDen > 0) {
            strNum = '(' + strNum + ')';
        }
        if (nDen > 1 && nNum > 0) {
            strDen = '(' + strDen + ')';
        }
        var str = strNum;
        if (nNum > 0 && nDen > 0) {
            str += ' / ';
        }
        str += strDen;
        return str;
    };
    /**
   * Get a unit, with optional formatting options.
   * @memberof Unit
   * @param {string[] | Unit[]} [units]  Array of units strings or valueLess Unit objects in wich choose the best one
   * @param {Object} [options]  Options for parsing the unit. See parseUnit for details.
   *
   * @return {Unit} Returns a new Unit with the given value and unit.
   */ Unit.prototype.toBest = function() {
        var unitList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (unitList && !Array.isArray(unitList)) {
            throw new Error('Invalid unit type. Expected string or Unit.');
        }
        var startPrefixes = this.units[0].unit.prefixes;
        if (unitList && unitList.length > 0) {
            var unitObjects = unitList.map((u)=>{
                var unit = null;
                if (typeof u === 'string') {
                    unit = Unit.parse(u);
                    if (!unit) {
                        throw new Error('Invalid unit type. Expected compatible string or Unit.');
                    }
                } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnit"])(u)) {
                    throw new Error('Invalid unit type. Expected compatible string or Unit.');
                }
                if (unit === null) {
                    unit = u.clone();
                }
                try {
                    this.to(unit.formatUnits());
                    return unit;
                } catch (e) {
                    throw new Error('Invalid unit type. Expected compatible string or Unit.');
                }
            });
            var prefixes = unitObjects.map((el)=>el.units[0].prefix);
            this.units[0].unit.prefixes = prefixes.reduce((acc, prefix)=>{
                acc[prefix.name] = prefix;
                return acc;
            }, {});
            this.units[0].prefix = prefixes[0];
        }
        var result = formatBest(this, options).simp;
        this.units[0].unit.prefixes = startPrefixes;
        result.fixPrefix = true;
        return result;
    };
    /**
   * Get a string representation of the Unit, with optional formatting options.
   * @memberof Unit
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string}
   */ Unit.prototype.format = function(options) {
        var { simp, valueStr, unitStr } = formatBest(this, options);
        var str = valueStr;
        if (simp.value && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isComplex"])(simp.value)) {
            str = '(' + str + ')'; // Surround complex values with ( ) to enable better parsing
        }
        if (unitStr.length > 0 && str.length > 0) {
            str += ' ';
        }
        str += unitStr;
        return str;
    };
    /**
  * Helper function to normalize a unit for conversion and formatting
  * @param {Unit} unit The unit to be normalized
  * @return {Object} Object with normalized unit and value
  * @private
  */ function formatBest(unit) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // Simplfy the unit list, unless it is valueless or was created directly in the
        // constructor or as the result of to or toSI
        var simp = unit.skipAutomaticSimplification || unit.value === null ? unit.clone() : unit.simplify();
        // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible. Otherwise, use a real-valued unit instead of a complex-valued one.
        handleVAandVARUnits(simp);
        // Now apply the best prefix
        // Units must have only one unit and not have the fixPrefix flag set
        applyBestPrefixIfNeeded(simp, options.offset);
        var value = simp._denormalize(simp.value);
        var valueStr = simp.value !== null ? format(value, options || {}) : '';
        var unitStr = simp.formatUnits();
        return {
            simp,
            valueStr,
            unitStr
        };
    }
    /**
   * Helper to handle VA and VAR units
   * @param {Unit} simp The unit to be normalized
   */ function handleVAandVARUnits(simp) {
        var isImaginary = false;
        if (typeof simp.value !== 'undefined' && simp.value !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isComplex"])(simp.value)) {
            // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
            isImaginary = Math.abs(simp.value.re) < 1e-14;
        }
        for(var i in simp.units){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(simp.units, i)) {
                if (simp.units[i].unit) {
                    if (simp.units[i].unit.name === 'VA' && isImaginary) {
                        simp.units[i].unit = UNITS.VAR;
                    } else if (simp.units[i].unit.name === 'VAR' && !isImaginary) {
                        simp.units[i].unit = UNITS.VA;
                    }
                }
            }
        }
    }
    /**
   * Helper to apply the best prefix if needed
   * @param {Unit} simp The unit to be normalized
   */ function applyBestPrefixIfNeeded(simp, offset) {
        if (simp.units.length === 1 && !simp.fixPrefix) {
            // Units must have integer powers, otherwise the prefix will change the
            // outputted value by not-an-integer-power-of-ten
            if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
                // Apply the best prefix
                simp.units[0].prefix = simp._bestPrefix(offset);
            }
        }
    }
    /**
   * Calculate the best prefix using current value.
   * @memberof Unit
   * @returns {Object} prefix
   * @param {number} [offset]  Optional offset for the best prefix calculation (default 1.2)
   * @private
   */ Unit.prototype._bestPrefix = function() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.2;
        if (this.units.length !== 1) {
            throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
        }
        if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
            throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
        }
        // find the best prefix value (resulting in the value of which
        // the absolute value of the log10 is closest to zero,
        // though with a little offset of 1.2 for nicer values: you get a
        // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...
        // Note: the units value can be any numeric type, but to find the best
        // prefix it's enough to work with limited precision of a regular number
        // Update: using mathjs abs since we also allow complex numbers
        var absValue = this.value !== null ? abs(this.value) : 0;
        var absUnitValue = abs(this.units[0].unit.value);
        var bestPrefix = this.units[0].prefix;
        if (absValue === 0) {
            return bestPrefix;
        }
        var power = this.units[0].power;
        var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - offset;
        if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix; // Allow the original prefix
        bestDiff = Math.abs(bestDiff);
        var prefixes = this.units[0].unit.prefixes;
        for(var p in prefixes){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(prefixes, p)) {
                var prefix = prefixes[p];
                if (prefix.scientific) {
                    var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - offset);
                    if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
                        // choose the prefix with the smallest diff, or if equal, choose the one
                        // with the shortest name (can happen with SHORTLONG for example)
                        bestPrefix = prefix;
                        bestDiff = diff;
                    }
                }
            }
        }
        return bestPrefix;
    };
    /**
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   const u = new Unit(1, 'm')
   *   u.splitUnit(['feet', 'inch'])
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */ Unit.prototype.splitUnit = function(parts) {
        var x = this.clone();
        var ret = [];
        for(var i = 0; i < parts.length; i++){
            // Convert x to the requested unit
            x = x.to(parts[i]);
            if (i === parts.length - 1) break;
            // Get the numeric value of this unit
            var xNumeric = x.toNumeric();
            // Check to see if xNumeric is nearly equal to an integer,
            // since fix can incorrectly round down if there is round-off error
            var xRounded = round(xNumeric);
            var xFixed = void 0;
            var isNearlyEqual = equal(xRounded, xNumeric);
            if (isNearlyEqual) {
                xFixed = xRounded;
            } else {
                xFixed = fix(x.toNumeric());
            }
            var y = new Unit(xFixed, parts[i].toString());
            ret.push(y);
            x = subtractScalar(x, y);
        }
        // This little bit fixes a bug where the remainder should be 0 but is a little bit off.
        // But instead of comparing x, the remainder, with zero--we will compare the sum of
        // all the parts so far with the original value. If they are nearly equal,
        // we set the remainder to 0.
        var testSum = 0;
        for(var _i5 = 0; _i5 < ret.length; _i5++){
            testSum = addScalar(testSum, ret[_i5].value);
        }
        if (equal(testSum, this.value)) {
            x.value = 0;
        }
        ret.push(x);
        return ret;
    };
    var PREFIXES = {
        NONE: {
            '': {
                name: '',
                value: 1,
                scientific: true
            }
        },
        SHORT: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            da: {
                name: 'da',
                value: 1e1,
                scientific: false
            },
            h: {
                name: 'h',
                value: 1e2,
                scientific: false
            },
            k: {
                name: 'k',
                value: 1e3,
                scientific: true
            },
            M: {
                name: 'M',
                value: 1e6,
                scientific: true
            },
            G: {
                name: 'G',
                value: 1e9,
                scientific: true
            },
            T: {
                name: 'T',
                value: 1e12,
                scientific: true
            },
            P: {
                name: 'P',
                value: 1e15,
                scientific: true
            },
            E: {
                name: 'E',
                value: 1e18,
                scientific: true
            },
            Z: {
                name: 'Z',
                value: 1e21,
                scientific: true
            },
            Y: {
                name: 'Y',
                value: 1e24,
                scientific: true
            },
            R: {
                name: 'R',
                value: 1e27,
                scientific: true
            },
            Q: {
                name: 'Q',
                value: 1e30,
                scientific: true
            },
            d: {
                name: 'd',
                value: 1e-1,
                scientific: false
            },
            c: {
                name: 'c',
                value: 1e-2,
                scientific: false
            },
            m: {
                name: 'm',
                value: 1e-3,
                scientific: true
            },
            u: {
                name: 'u',
                value: 1e-6,
                scientific: true
            },
            n: {
                name: 'n',
                value: 1e-9,
                scientific: true
            },
            p: {
                name: 'p',
                value: 1e-12,
                scientific: true
            },
            f: {
                name: 'f',
                value: 1e-15,
                scientific: true
            },
            a: {
                name: 'a',
                value: 1e-18,
                scientific: true
            },
            z: {
                name: 'z',
                value: 1e-21,
                scientific: true
            },
            y: {
                name: 'y',
                value: 1e-24,
                scientific: true
            },
            r: {
                name: 'r',
                value: 1e-27,
                scientific: true
            },
            q: {
                name: 'q',
                value: 1e-30,
                scientific: true
            }
        },
        LONG: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            deca: {
                name: 'deca',
                value: 1e1,
                scientific: false
            },
            hecto: {
                name: 'hecto',
                value: 1e2,
                scientific: false
            },
            kilo: {
                name: 'kilo',
                value: 1e3,
                scientific: true
            },
            mega: {
                name: 'mega',
                value: 1e6,
                scientific: true
            },
            giga: {
                name: 'giga',
                value: 1e9,
                scientific: true
            },
            tera: {
                name: 'tera',
                value: 1e12,
                scientific: true
            },
            peta: {
                name: 'peta',
                value: 1e15,
                scientific: true
            },
            exa: {
                name: 'exa',
                value: 1e18,
                scientific: true
            },
            zetta: {
                name: 'zetta',
                value: 1e21,
                scientific: true
            },
            yotta: {
                name: 'yotta',
                value: 1e24,
                scientific: true
            },
            ronna: {
                name: 'ronna',
                value: 1e27,
                scientific: true
            },
            quetta: {
                name: 'quetta',
                value: 1e30,
                scientific: true
            },
            deci: {
                name: 'deci',
                value: 1e-1,
                scientific: false
            },
            centi: {
                name: 'centi',
                value: 1e-2,
                scientific: false
            },
            milli: {
                name: 'milli',
                value: 1e-3,
                scientific: true
            },
            micro: {
                name: 'micro',
                value: 1e-6,
                scientific: true
            },
            nano: {
                name: 'nano',
                value: 1e-9,
                scientific: true
            },
            pico: {
                name: 'pico',
                value: 1e-12,
                scientific: true
            },
            femto: {
                name: 'femto',
                value: 1e-15,
                scientific: true
            },
            atto: {
                name: 'atto',
                value: 1e-18,
                scientific: true
            },
            zepto: {
                name: 'zepto',
                value: 1e-21,
                scientific: true
            },
            yocto: {
                name: 'yocto',
                value: 1e-24,
                scientific: true
            },
            ronto: {
                name: 'ronto',
                value: 1e-27,
                scientific: true
            },
            quecto: {
                name: 'quecto',
                value: 1e-30,
                scientific: true
            }
        },
        SQUARED: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            da: {
                name: 'da',
                value: 1e2,
                scientific: false
            },
            h: {
                name: 'h',
                value: 1e4,
                scientific: false
            },
            k: {
                name: 'k',
                value: 1e6,
                scientific: true
            },
            M: {
                name: 'M',
                value: 1e12,
                scientific: true
            },
            G: {
                name: 'G',
                value: 1e18,
                scientific: true
            },
            T: {
                name: 'T',
                value: 1e24,
                scientific: true
            },
            P: {
                name: 'P',
                value: 1e30,
                scientific: true
            },
            E: {
                name: 'E',
                value: 1e36,
                scientific: true
            },
            Z: {
                name: 'Z',
                value: 1e42,
                scientific: true
            },
            Y: {
                name: 'Y',
                value: 1e48,
                scientific: true
            },
            R: {
                name: 'R',
                value: 1e54,
                scientific: true
            },
            Q: {
                name: 'Q',
                value: 1e60,
                scientific: true
            },
            d: {
                name: 'd',
                value: 1e-2,
                scientific: false
            },
            c: {
                name: 'c',
                value: 1e-4,
                scientific: false
            },
            m: {
                name: 'm',
                value: 1e-6,
                scientific: true
            },
            u: {
                name: 'u',
                value: 1e-12,
                scientific: true
            },
            n: {
                name: 'n',
                value: 1e-18,
                scientific: true
            },
            p: {
                name: 'p',
                value: 1e-24,
                scientific: true
            },
            f: {
                name: 'f',
                value: 1e-30,
                scientific: true
            },
            a: {
                name: 'a',
                value: 1e-36,
                scientific: true
            },
            z: {
                name: 'z',
                value: 1e-42,
                scientific: true
            },
            y: {
                name: 'y',
                value: 1e-48,
                scientific: true
            },
            r: {
                name: 'r',
                value: 1e-54,
                scientific: true
            },
            q: {
                name: 'q',
                value: 1e-60,
                scientific: true
            }
        },
        CUBIC: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            da: {
                name: 'da',
                value: 1e3,
                scientific: false
            },
            h: {
                name: 'h',
                value: 1e6,
                scientific: false
            },
            k: {
                name: 'k',
                value: 1e9,
                scientific: true
            },
            M: {
                name: 'M',
                value: 1e18,
                scientific: true
            },
            G: {
                name: 'G',
                value: 1e27,
                scientific: true
            },
            T: {
                name: 'T',
                value: 1e36,
                scientific: true
            },
            P: {
                name: 'P',
                value: 1e45,
                scientific: true
            },
            E: {
                name: 'E',
                value: 1e54,
                scientific: true
            },
            Z: {
                name: 'Z',
                value: 1e63,
                scientific: true
            },
            Y: {
                name: 'Y',
                value: 1e72,
                scientific: true
            },
            R: {
                name: 'R',
                value: 1e81,
                scientific: true
            },
            Q: {
                name: 'Q',
                value: 1e90,
                scientific: true
            },
            d: {
                name: 'd',
                value: 1e-3,
                scientific: false
            },
            c: {
                name: 'c',
                value: 1e-6,
                scientific: false
            },
            m: {
                name: 'm',
                value: 1e-9,
                scientific: true
            },
            u: {
                name: 'u',
                value: 1e-18,
                scientific: true
            },
            n: {
                name: 'n',
                value: 1e-27,
                scientific: true
            },
            p: {
                name: 'p',
                value: 1e-36,
                scientific: true
            },
            f: {
                name: 'f',
                value: 1e-45,
                scientific: true
            },
            a: {
                name: 'a',
                value: 1e-54,
                scientific: true
            },
            z: {
                name: 'z',
                value: 1e-63,
                scientific: true
            },
            y: {
                name: 'y',
                value: 1e-72,
                scientific: true
            },
            r: {
                name: 'r',
                value: 1e-81,
                scientific: true
            },
            q: {
                name: 'q',
                value: 1e-90,
                scientific: true
            }
        },
        BINARY_SHORT_SI: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            k: {
                name: 'k',
                value: 1e3,
                scientific: true
            },
            M: {
                name: 'M',
                value: 1e6,
                scientific: true
            },
            G: {
                name: 'G',
                value: 1e9,
                scientific: true
            },
            T: {
                name: 'T',
                value: 1e12,
                scientific: true
            },
            P: {
                name: 'P',
                value: 1e15,
                scientific: true
            },
            E: {
                name: 'E',
                value: 1e18,
                scientific: true
            },
            Z: {
                name: 'Z',
                value: 1e21,
                scientific: true
            },
            Y: {
                name: 'Y',
                value: 1e24,
                scientific: true
            }
        },
        BINARY_SHORT_IEC: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            Ki: {
                name: 'Ki',
                value: 1024,
                scientific: true
            },
            Mi: {
                name: 'Mi',
                value: Math.pow(1024, 2),
                scientific: true
            },
            Gi: {
                name: 'Gi',
                value: Math.pow(1024, 3),
                scientific: true
            },
            Ti: {
                name: 'Ti',
                value: Math.pow(1024, 4),
                scientific: true
            },
            Pi: {
                name: 'Pi',
                value: Math.pow(1024, 5),
                scientific: true
            },
            Ei: {
                name: 'Ei',
                value: Math.pow(1024, 6),
                scientific: true
            },
            Zi: {
                name: 'Zi',
                value: Math.pow(1024, 7),
                scientific: true
            },
            Yi: {
                name: 'Yi',
                value: Math.pow(1024, 8),
                scientific: true
            }
        },
        BINARY_LONG_SI: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            kilo: {
                name: 'kilo',
                value: 1e3,
                scientific: true
            },
            mega: {
                name: 'mega',
                value: 1e6,
                scientific: true
            },
            giga: {
                name: 'giga',
                value: 1e9,
                scientific: true
            },
            tera: {
                name: 'tera',
                value: 1e12,
                scientific: true
            },
            peta: {
                name: 'peta',
                value: 1e15,
                scientific: true
            },
            exa: {
                name: 'exa',
                value: 1e18,
                scientific: true
            },
            zetta: {
                name: 'zetta',
                value: 1e21,
                scientific: true
            },
            yotta: {
                name: 'yotta',
                value: 1e24,
                scientific: true
            }
        },
        BINARY_LONG_IEC: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            kibi: {
                name: 'kibi',
                value: 1024,
                scientific: true
            },
            mebi: {
                name: 'mebi',
                value: Math.pow(1024, 2),
                scientific: true
            },
            gibi: {
                name: 'gibi',
                value: Math.pow(1024, 3),
                scientific: true
            },
            tebi: {
                name: 'tebi',
                value: Math.pow(1024, 4),
                scientific: true
            },
            pebi: {
                name: 'pebi',
                value: Math.pow(1024, 5),
                scientific: true
            },
            exi: {
                name: 'exi',
                value: Math.pow(1024, 6),
                scientific: true
            },
            zebi: {
                name: 'zebi',
                value: Math.pow(1024, 7),
                scientific: true
            },
            yobi: {
                name: 'yobi',
                value: Math.pow(1024, 8),
                scientific: true
            }
        },
        BTU: {
            '': {
                name: '',
                value: 1,
                scientific: true
            },
            MM: {
                name: 'MM',
                value: 1e6,
                scientific: true
            }
        }
    };
    PREFIXES.SHORTLONG = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
    PREFIXES.BINARY_LONG = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
    /* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
   * Index  Dimension
   * -----  ---------
   *   0    Length
   *   1    Mass
   *   2    Time
   *   3    Current
   *   4    Temperature
   *   5    Luminous intensity
   *   6    Amount of substance
   *   7    Angle
   *   8    Bit (digital)
   * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm °C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
   *
   */ var BASE_DIMENSIONS = [
        'MASS',
        'LENGTH',
        'TIME',
        'CURRENT',
        'TEMPERATURE',
        'LUMINOUS_INTENSITY',
        'AMOUNT_OF_SUBSTANCE',
        'ANGLE',
        'BIT'
    ];
    var BASE_UNITS = {
        NONE: {
            dimensions: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        MASS: {
            dimensions: [
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        LENGTH: {
            dimensions: [
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        TIME: {
            dimensions: [
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        CURRENT: {
            dimensions: [
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0
            ]
        },
        TEMPERATURE: {
            dimensions: [
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0
            ]
        },
        LUMINOUS_INTENSITY: {
            dimensions: [
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0
            ]
        },
        AMOUNT_OF_SUBSTANCE: {
            dimensions: [
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0
            ]
        },
        FORCE: {
            dimensions: [
                1,
                1,
                -2,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        SURFACE: {
            dimensions: [
                0,
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        VOLUME: {
            dimensions: [
                0,
                3,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ENERGY: {
            dimensions: [
                1,
                2,
                -2,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        POWER: {
            dimensions: [
                1,
                2,
                -3,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        PRESSURE: {
            dimensions: [
                1,
                -1,
                -2,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_CHARGE: {
            dimensions: [
                0,
                0,
                1,
                1,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_CAPACITANCE: {
            dimensions: [
                -1,
                -2,
                4,
                2,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_POTENTIAL: {
            dimensions: [
                1,
                2,
                -3,
                -1,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_RESISTANCE: {
            dimensions: [
                1,
                2,
                -3,
                -2,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_INDUCTANCE: {
            dimensions: [
                1,
                2,
                -2,
                -2,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ELECTRIC_CONDUCTANCE: {
            dimensions: [
                -1,
                -2,
                3,
                2,
                0,
                0,
                0,
                0,
                0
            ]
        },
        MAGNETIC_FLUX: {
            dimensions: [
                1,
                2,
                -2,
                -1,
                0,
                0,
                0,
                0,
                0
            ]
        },
        MAGNETIC_FLUX_DENSITY: {
            dimensions: [
                1,
                0,
                -2,
                -1,
                0,
                0,
                0,
                0,
                0
            ]
        },
        FREQUENCY: {
            dimensions: [
                0,
                0,
                -1,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        ANGLE: {
            dimensions: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0
            ]
        },
        BIT: {
            dimensions: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1
            ]
        }
    };
    for(var key in BASE_UNITS){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(BASE_UNITS, key)) {
            BASE_UNITS[key].key = key;
        }
    }
    var BASE_UNIT_NONE = {};
    var UNIT_NONE = {
        name: '',
        base: BASE_UNIT_NONE,
        value: 1,
        offset: 0,
        dimensions: BASE_DIMENSIONS.map((x)=>0)
    };
    var UNITS = {
        // length
        meter: {
            name: 'meter',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        inch: {
            name: 'inch',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
        },
        foot: {
            name: 'foot',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
        },
        yard: {
            name: 'yard',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
        },
        mile: {
            name: 'mile',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
        },
        link: {
            name: 'link',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
        },
        rod: {
            name: 'rod',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.0292,
            offset: 0
        },
        chain: {
            name: 'chain',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
        },
        angstrom: {
            name: 'angstrom',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1e-10,
            offset: 0
        },
        m: {
            name: 'm',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        in: {
            name: 'in',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
        },
        ft: {
            name: 'ft',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
        },
        yd: {
            name: 'yd',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
        },
        mi: {
            name: 'mi',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
        },
        li: {
            name: 'li',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
        },
        rd: {
            name: 'rd',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.029210,
            offset: 0
        },
        ch: {
            name: 'ch',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
        },
        mil: {
            name: 'mil',
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0000254,
            offset: 0
        },
        // 1/1000 inch
        // Surface
        m2: {
            name: 'm2',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.SQUARED,
            value: 1,
            offset: 0
        },
        sqin: {
            name: 'sqin',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.00064516,
            offset: 0
        },
        // 645.16 mm2
        sqft: {
            name: 'sqft',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.09290304,
            offset: 0
        },
        // 0.09290304 m2
        sqyd: {
            name: 'sqyd',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.83612736,
            offset: 0
        },
        // 0.83612736 m2
        sqmi: {
            name: 'sqmi',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 2589988.110336,
            offset: 0
        },
        // 2.589988110336 km2
        sqrd: {
            name: 'sqrd',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 25.29295,
            offset: 0
        },
        // 25.29295 m2
        sqch: {
            name: 'sqch',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 404.6873,
            offset: 0
        },
        // 404.6873 m2
        sqmil: {
            name: 'sqmil',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 6.4516e-10,
            offset: 0
        },
        // 6.4516 * 10^-10 m2
        acre: {
            name: 'acre',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 4046.86,
            offset: 0
        },
        // 4046.86 m2
        hectare: {
            name: 'hectare',
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 10000,
            offset: 0
        },
        // 10000 m2
        // Volume
        m3: {
            name: 'm3',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.CUBIC,
            value: 1,
            offset: 0
        },
        L: {
            name: 'L',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 0.001,
            offset: 0
        },
        // litre
        l: {
            name: 'l',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 0.001,
            offset: 0
        },
        // litre
        litre: {
            name: 'litre',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.LONG,
            value: 0.001,
            offset: 0
        },
        cuin: {
            name: 'cuin',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1.6387064e-5,
            offset: 0
        },
        // 1.6387064e-5 m3
        cuft: {
            name: 'cuft',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.028316846592,
            offset: 0
        },
        // 28.316 846 592 L
        cuyd: {
            name: 'cuyd',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.764554857984,
            offset: 0
        },
        // 764.554 857 984 L
        teaspoon: {
            name: 'teaspoon',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.000005,
            offset: 0
        },
        // 5 mL
        tablespoon: {
            name: 'tablespoon',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.000015,
            offset: 0
        },
        // 15 mL
        // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
        drop: {
            name: 'drop',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
        },
        // 0.05 mL = 5e-8 m3
        gtt: {
            name: 'gtt',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
        },
        // 0.05 mL = 5e-8 m3
        // Liquid volume
        minim: {
            name: 'minim',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.000000061611519921875,
            offset: 0
        },
        // 1/61440 gallons
        fluiddram: {
            name: 'fluiddram',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.0000036966911953125,
            offset: 0
        },
        // 1/1024 gallons
        fluidounce: {
            name: 'fluidounce',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.0000295735295625,
            offset: 0
        },
        // 1/128 gallons
        gill: {
            name: 'gill',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.00011829411825,
            offset: 0
        },
        // 1/32 gallons
        cc: {
            name: 'cc',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1e-6,
            offset: 0
        },
        // 1e-6 L
        cup: {
            name: 'cup',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.0002365882365,
            offset: 0
        },
        // 1/16 gallons
        pint: {
            name: 'pint',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.000473176473,
            offset: 0
        },
        // 1/8 gallons
        quart: {
            name: 'quart',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.000946352946,
            offset: 0
        },
        // 1/4 gallons
        gallon: {
            name: 'gallon',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.003785411784,
            offset: 0
        },
        // 3.785411784 L
        beerbarrel: {
            name: 'beerbarrel',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.117347765304,
            offset: 0
        },
        // 31 gallons
        oilbarrel: {
            name: 'oilbarrel',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.158987294928,
            offset: 0
        },
        // 42 gallons
        hogshead: {
            name: 'hogshead',
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.238480942392,
            offset: 0
        },
        // 63 gallons
        // Mass
        g: {
            name: 'g',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 0.001,
            offset: 0
        },
        gram: {
            name: 'gram',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 0.001,
            offset: 0
        },
        ton: {
            name: 'ton',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 907.18474,
            offset: 0
        },
        t: {
            name: 't',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 1000,
            offset: 0
        },
        tonne: {
            name: 'tonne',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 1000,
            offset: 0
        },
        grain: {
            name: 'grain',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 64.79891e-6,
            offset: 0
        },
        dram: {
            name: 'dram',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 1.7718451953125e-3,
            offset: 0
        },
        ounce: {
            name: 'ounce',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 28.349523125e-3,
            offset: 0
        },
        poundmass: {
            name: 'poundmass',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 453.59237e-3,
            offset: 0
        },
        hundredweight: {
            name: 'hundredweight',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
        },
        stick: {
            name: 'stick',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 115e-3,
            offset: 0
        },
        stone: {
            name: 'stone',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6.35029318,
            offset: 0
        },
        gr: {
            name: 'gr',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 64.79891e-6,
            offset: 0
        },
        dr: {
            name: 'dr',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 1.7718451953125e-3,
            offset: 0
        },
        oz: {
            name: 'oz',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 28.349523125e-3,
            offset: 0
        },
        lbm: {
            name: 'lbm',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 453.59237e-3,
            offset: 0
        },
        cwt: {
            name: 'cwt',
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
        },
        // Time
        s: {
            name: 's',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        min: {
            name: 'min',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
        },
        h: {
            name: 'h',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
        },
        second: {
            name: 'second',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        sec: {
            name: 'sec',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        minute: {
            name: 'minute',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
        },
        hour: {
            name: 'hour',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
        },
        day: {
            name: 'day',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 86400,
            offset: 0
        },
        week: {
            name: 'week',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 7 * 86400,
            offset: 0
        },
        month: {
            name: 'month',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 2629800,
            // 1/12th of Julian year
            offset: 0
        },
        year: {
            name: 'year',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 31557600,
            // Julian year
            offset: 0
        },
        decade: {
            name: 'decade',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576000,
            // Julian decade
            offset: 0
        },
        century: {
            name: 'century',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3155760000,
            // Julian century
            offset: 0
        },
        millennium: {
            name: 'millennium',
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 31557600000,
            // Julian millennium
            offset: 0
        },
        // Frequency
        hertz: {
            name: 'Hertz',
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0,
            reciprocal: true
        },
        Hz: {
            name: 'Hz',
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0,
            reciprocal: true
        },
        // Angle
        rad: {
            name: 'rad',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        radian: {
            name: 'radian',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
        deg: {
            name: 'deg',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        degree: {
            name: 'degree',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
        grad: {
            name: 'grad',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        gradian: {
            name: 'gradian',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
        cycle: {
            name: 'cycle',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
        arcsec: {
            name: 'arcsec',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
        arcmin: {
            name: 'arcmin',
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
        },
        // Electric current
        A: {
            name: 'A',
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        ampere: {
            name: 'ampere',
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        // Temperature
        // K(C) = °C + 273.15
        // K(F) = (°F + 459.67) * (5 / 9)
        // K(R) = °R * (5 / 9)
        K: {
            name: 'K',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        degC: {
            name: 'degC',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 273.15
        },
        degF: {
            name: 'degF',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 459.67
        },
        degR: {
            name: 'degR',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 0
        },
        kelvin: {
            name: 'kelvin',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        celsius: {
            name: 'celsius',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 273.15
        },
        fahrenheit: {
            name: 'fahrenheit',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 459.67
        },
        rankine: {
            name: 'rankine',
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 0
        },
        // amount of substance
        mol: {
            name: 'mol',
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        mole: {
            name: 'mole',
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        // luminous intensity
        cd: {
            name: 'cd',
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        candela: {
            name: 'candela',
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        // TODO: units STERADIAN
        // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
        // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
        // Force
        N: {
            name: 'N',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        newton: {
            name: 'newton',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        dyn: {
            name: 'dyn',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 0.00001,
            offset: 0
        },
        dyne: {
            name: 'dyne',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 0.00001,
            offset: 0
        },
        lbf: {
            name: 'lbf',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
        },
        poundforce: {
            name: 'poundforce',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
        },
        kip: {
            name: 'kip',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 4448.2216,
            offset: 0
        },
        kilogramforce: {
            name: 'kilogramforce',
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
        },
        // Energy
        J: {
            name: 'J',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        joule: {
            name: 'joule',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        erg: {
            name: 'erg',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORTLONG,
            // Both kiloerg and kerg are acceptable
            value: 1e-7,
            offset: 0
        },
        Wh: {
            name: 'Wh',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 3600,
            offset: 0
        },
        BTU: {
            name: 'BTU',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.BTU,
            value: 1055.05585262,
            offset: 0
        },
        eV: {
            name: 'eV',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1.602176565e-19,
            offset: 0
        },
        electronvolt: {
            name: 'electronvolt',
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.LONG,
            value: 1.602176565e-19,
            offset: 0
        },
        // Power
        W: {
            name: 'W',
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        watt: {
            name: 'watt',
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        hp: {
            name: 'hp',
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.NONE,
            value: 745.6998715386,
            offset: 0
        },
        // Electrical power units
        VAR: {
            name: 'VAR',
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: Complex.I,
            offset: 0
        },
        VA: {
            name: 'VA',
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Pressure
        Pa: {
            name: 'Pa',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        psi: {
            name: 'psi',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 6894.75729276459,
            offset: 0
        },
        atm: {
            name: 'atm',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 101325,
            offset: 0
        },
        bar: {
            name: 'bar',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORTLONG,
            value: 100000,
            offset: 0
        },
        torr: {
            name: 'torr',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
        },
        mmHg: {
            name: 'mmHg',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
        },
        mmH2O: {
            name: 'mmH2O',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
        },
        cmH2O: {
            name: 'cmH2O',
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 98.0665,
            offset: 0
        },
        // Electric charge
        coulomb: {
            name: 'coulomb',
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        C: {
            name: 'C',
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Electric capacitance
        farad: {
            name: 'farad',
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        F: {
            name: 'F',
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Electric potential
        volt: {
            name: 'volt',
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        V: {
            name: 'V',
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Electric resistance
        ohm: {
            name: 'ohm',
            base: BASE_UNITS.ELECTRIC_RESISTANCE,
            prefixes: PREFIXES.SHORTLONG,
            // Both Mohm and megaohm are acceptable
            value: 1,
            offset: 0
        },
        /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */ // Electric inductance
        henry: {
            name: 'henry',
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        H: {
            name: 'H',
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Electric conductance
        siemens: {
            name: 'siemens',
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        S: {
            name: 'S',
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Magnetic flux
        weber: {
            name: 'weber',
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        Wb: {
            name: 'Wb',
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Magnetic flux density
        tesla: {
            name: 'tesla',
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
        },
        T: {
            name: 'T',
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
        },
        // Binary
        b: {
            name: 'b',
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 1,
            offset: 0
        },
        bits: {
            name: 'bits',
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 1,
            offset: 0
        },
        B: {
            name: 'B',
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 8,
            offset: 0
        },
        bytes: {
            name: 'bytes',
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 8,
            offset: 0
        }
    };
    // aliases (formerly plurals)
    // note that ALIASES is only used at creation to create more entries in UNITS by copying the aliased units
    var ALIASES = {
        meters: 'meter',
        inches: 'inch',
        feet: 'foot',
        yards: 'yard',
        miles: 'mile',
        links: 'link',
        rods: 'rod',
        chains: 'chain',
        angstroms: 'angstrom',
        lt: 'l',
        litres: 'litre',
        liter: 'litre',
        liters: 'litre',
        teaspoons: 'teaspoon',
        tablespoons: 'tablespoon',
        minims: 'minim',
        fldr: 'fluiddram',
        fluiddrams: 'fluiddram',
        floz: 'fluidounce',
        fluidounces: 'fluidounce',
        gi: 'gill',
        gills: 'gill',
        cp: 'cup',
        cups: 'cup',
        pt: 'pint',
        pints: 'pint',
        qt: 'quart',
        quarts: 'quart',
        gal: 'gallon',
        gallons: 'gallon',
        bbl: 'beerbarrel',
        beerbarrels: 'beerbarrel',
        obl: 'oilbarrel',
        oilbarrels: 'oilbarrel',
        hogsheads: 'hogshead',
        gtts: 'gtt',
        grams: 'gram',
        tons: 'ton',
        tonnes: 'tonne',
        grains: 'grain',
        drams: 'dram',
        ounces: 'ounce',
        poundmasses: 'poundmass',
        hundredweights: 'hundredweight',
        sticks: 'stick',
        lb: 'lbm',
        lbs: 'lbm',
        kips: 'kip',
        kgf: 'kilogramforce',
        acres: 'acre',
        hectares: 'hectare',
        sqfeet: 'sqft',
        sqyard: 'sqyd',
        sqmile: 'sqmi',
        sqmiles: 'sqmi',
        mmhg: 'mmHg',
        mmh2o: 'mmH2O',
        cmh2o: 'cmH2O',
        seconds: 'second',
        secs: 'second',
        minutes: 'minute',
        mins: 'minute',
        hours: 'hour',
        hr: 'hour',
        hrs: 'hour',
        days: 'day',
        weeks: 'week',
        months: 'month',
        years: 'year',
        decades: 'decade',
        centuries: 'century',
        millennia: 'millennium',
        hertz: 'hertz',
        radians: 'radian',
        degrees: 'degree',
        gradians: 'gradian',
        cycles: 'cycle',
        arcsecond: 'arcsec',
        arcseconds: 'arcsec',
        arcminute: 'arcmin',
        arcminutes: 'arcmin',
        BTUs: 'BTU',
        watts: 'watt',
        joules: 'joule',
        amperes: 'ampere',
        amps: 'ampere',
        amp: 'ampere',
        coulombs: 'coulomb',
        volts: 'volt',
        ohms: 'ohm',
        farads: 'farad',
        webers: 'weber',
        teslas: 'tesla',
        electronvolts: 'electronvolt',
        moles: 'mole',
        bit: 'bits',
        byte: 'bytes'
    };
    /**
   * Calculate the values for the angle units.
   * Value is calculated as number or BigNumber depending on the configuration
   * @param {{number: 'number' | 'BigNumber'}} config
   */ function calculateAngleValues(config) {
        if (config.number === 'BigNumber') {
            var pi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBigNumberPi"])(_BigNumber);
            UNITS.rad.value = new _BigNumber(1);
            UNITS.deg.value = pi.div(180); // 2 * pi / 360
            UNITS.grad.value = pi.div(200); // 2 * pi / 400
            UNITS.cycle.value = pi.times(2); // 2 * pi
            UNITS.arcsec.value = pi.div(648000); // 2 * pi / 360 / 3600
            UNITS.arcmin.value = pi.div(10800); // 2 * pi / 360 / 60
        } else {
            // number
            UNITS.rad.value = 1;
            UNITS.deg.value = Math.PI / 180; // 2 * pi / 360
            UNITS.grad.value = Math.PI / 200; // 2 * pi / 400
            UNITS.cycle.value = Math.PI * 2; // 2 * pi
            UNITS.arcsec.value = Math.PI / 648000; // 2 * pi / 360 / 3600
            UNITS.arcmin.value = Math.PI / 10800; // 2 * pi / 360 / 60
        }
        // copy to the full names of the angles
        UNITS.radian.value = UNITS.rad.value;
        UNITS.degree.value = UNITS.deg.value;
        UNITS.gradian.value = UNITS.grad.value;
    }
    // apply the angle values now
    calculateAngleValues(config);
    if (on) {
        // recalculate the values on change of configuration
        on('config', function(curr, prev) {
            if (curr.number !== prev.number) {
                calculateAngleValues(curr);
            }
        });
    }
    /**
   * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
   * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
   * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
   */ var UNIT_SYSTEMS = {
        si: {
            // Base units
            NONE: {
                unit: UNIT_NONE,
                prefix: PREFIXES.NONE['']
            },
            LENGTH: {
                unit: UNITS.m,
                prefix: PREFIXES.SHORT['']
            },
            MASS: {
                unit: UNITS.g,
                prefix: PREFIXES.SHORT.k
            },
            TIME: {
                unit: UNITS.s,
                prefix: PREFIXES.SHORT['']
            },
            CURRENT: {
                unit: UNITS.A,
                prefix: PREFIXES.SHORT['']
            },
            TEMPERATURE: {
                unit: UNITS.K,
                prefix: PREFIXES.SHORT['']
            },
            LUMINOUS_INTENSITY: {
                unit: UNITS.cd,
                prefix: PREFIXES.SHORT['']
            },
            AMOUNT_OF_SUBSTANCE: {
                unit: UNITS.mol,
                prefix: PREFIXES.SHORT['']
            },
            ANGLE: {
                unit: UNITS.rad,
                prefix: PREFIXES.SHORT['']
            },
            BIT: {
                unit: UNITS.bits,
                prefix: PREFIXES.SHORT['']
            },
            // Derived units
            FORCE: {
                unit: UNITS.N,
                prefix: PREFIXES.SHORT['']
            },
            ENERGY: {
                unit: UNITS.J,
                prefix: PREFIXES.SHORT['']
            },
            POWER: {
                unit: UNITS.W,
                prefix: PREFIXES.SHORT['']
            },
            PRESSURE: {
                unit: UNITS.Pa,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_CHARGE: {
                unit: UNITS.C,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_CAPACITANCE: {
                unit: UNITS.F,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_POTENTIAL: {
                unit: UNITS.V,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_RESISTANCE: {
                unit: UNITS.ohm,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_INDUCTANCE: {
                unit: UNITS.H,
                prefix: PREFIXES.SHORT['']
            },
            ELECTRIC_CONDUCTANCE: {
                unit: UNITS.S,
                prefix: PREFIXES.SHORT['']
            },
            MAGNETIC_FLUX: {
                unit: UNITS.Wb,
                prefix: PREFIXES.SHORT['']
            },
            MAGNETIC_FLUX_DENSITY: {
                unit: UNITS.T,
                prefix: PREFIXES.SHORT['']
            },
            FREQUENCY: {
                unit: UNITS.Hz,
                prefix: PREFIXES.SHORT['']
            }
        }
    };
    // Clone to create the other unit systems
    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT.c
    };
    UNIT_SYSTEMS.cgs.MASS = {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT['']
    };
    UNIT_SYSTEMS.cgs.FORCE = {
        unit: UNITS.dyn,
        prefix: PREFIXES.SHORT['']
    };
    UNIT_SYSTEMS.cgs.ENERGY = {
        unit: UNITS.erg,
        prefix: PREFIXES.NONE['']
    };
    // there are wholly 4 unique cgs systems for electricity and magnetism,
    // so let's not worry about it unless somebody complains
    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = {
        unit: UNITS.ft,
        prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.MASS = {
        unit: UNITS.lbm,
        prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.TEMPERATURE = {
        unit: UNITS.degF,
        prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.FORCE = {
        unit: UNITS.lbf,
        prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.ENERGY = {
        unit: UNITS.BTU,
        prefix: PREFIXES.BTU['']
    };
    UNIT_SYSTEMS.us.POWER = {
        unit: UNITS.hp,
        prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.PRESSURE = {
        unit: UNITS.psi,
        prefix: PREFIXES.NONE['']
    };
    // Add additional unit systems here.
    // Choose a unit system to seed the auto unit system.
    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    // Set the current unit system
    var currentUnitSystem = UNIT_SYSTEMS.auto;
    /**
   * Set a unit system for formatting derived units.
   * @memberof Unit
   * @param {string} [name] The name of the unit system.
   */ Unit.setUnitSystem = function(name) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNIT_SYSTEMS, name)) {
            currentUnitSystem = UNIT_SYSTEMS[name];
        } else {
            throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
        }
    };
    /**
   * Return the current unit system.
   * @memberof Unit
   * @return {string} The current unit system.
   */ Unit.getUnitSystem = function() {
        for(var _key in UNIT_SYSTEMS){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNIT_SYSTEMS, _key)) {
                if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
                    return _key;
                }
            }
        }
    };
    /**
   * Converters to convert from number to an other numeric type like BigNumber
   * or Fraction
   */ Unit.typeConverters = {
        BigNumber: function BigNumber(x) {
            if (x !== null && x !== void 0 && x.isFraction) return new _BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
            return new _BigNumber(x + ''); // stringify to prevent constructor error
        },
        Fraction: function Fraction(x) {
            return new _Fraction(x);
        },
        Complex: function Complex(x) {
            return x;
        },
        number: function number(x) {
            if (x !== null && x !== void 0 && x.isFraction) return _number(x);
            return x;
        }
    };
    /**
   * Retrieve the right converter function corresponding with this unit's
   * value
   *
   * @memberof Unit
   * @return {Function}
   */ Unit.prototype._numberConverter = function() {
        var convert = Unit.typeConverters[this.valueType()];
        if (convert) {
            return convert;
        }
        throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
    };
    /**
   * Retrieve the right convertor function corresponding with the type
   * of provided exampleValue.
   *
   * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
   *                        In case of an unknown type,
   * @return {Function}
   */ Unit._getNumberConverter = function(type) {
        if (!Unit.typeConverters[type]) {
            throw new TypeError('Unsupported type "' + type + '"');
        }
        return Unit.typeConverters[type];
    };
    // Add dimensions to each built-in unit
    for(var _key2 in UNITS){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNITS, _key2)) {
            var unit = UNITS[_key2];
            unit.dimensions = unit.base.dimensions;
        }
    }
    // Create aliases
    for(var _name2 in ALIASES){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(ALIASES, _name2)) {
            var _unit2 = UNITS[ALIASES[_name2]];
            var alias = {};
            for(var _key3 in _unit2){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(_unit2, _key3)) {
                    alias[_key3] = _unit2[_key3];
                }
            }
            alias.name = _name2;
            UNITS[_name2] = alias;
        }
    }
    /**
   * Checks if a character is a valid latin letter (upper or lower case).
   * Note that this function can be overridden, for example to allow support of other alphabets.
   * @memberof Unit
   * @param {string} c Tested character
   * @return {boolean} true if the character is a latin letter
   */ Unit.isValidAlpha = function isValidAlpha(c) {
        return /^[a-zA-Z]$/.test(c);
    };
    function assertUnitNameIsValid(name) {
        for(var i = 0; i < name.length; i++){
            c = name.charAt(i);
            if (i === 0 && !Unit.isValidAlpha(c)) {
                throw new Error('Invalid unit name (must begin with alpha character): "' + name + '"');
            }
            if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
                throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name + '"');
            }
        }
    }
    /**
   * Wrapper around createUnitSingle.
   * Example:
   *  createUnit( {
   *     foo: {
   *       prefixes: 'long',
   *       baseName: 'essence-of-foo'
   *     },
   *     bar: '40 foo',
   *     baz: {
   *       definition: '1 bar/hour',
   *       prefixes: 'long'
   *     }
   *   },
   *   {
   *     override: true
   *   })
   * @memberof Unit
   * @param {object} obj      Object map. Each key becomes a unit which is defined by its value.
   * @param {object} options
   * @return {Unit} the last created unit
   */ Unit.createUnit = function(obj, options) {
        if (typeof obj !== 'object') {
            throw new TypeError("createUnit expects first parameter to be of type 'Object'");
        }
        // Remove all units and aliases we are overriding
        if (options && options.override) {
            for(var _key4 in obj){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(obj, _key4)) {
                    Unit.deleteUnit(_key4);
                }
                if (obj[_key4].aliases) {
                    for(var i = 0; i < obj[_key4].aliases.length; i++){
                        Unit.deleteUnit(obj[_key4].aliases[i]);
                    }
                }
            }
        }
        // TODO: traverse multiple times until all units have been added
        var lastUnit;
        for(var _key5 in obj){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(obj, _key5)) {
                lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
            }
        }
        return lastUnit;
    };
    /**
   * Create a user-defined unit and register it with the Unit type.
   * Example:
   *  createUnitSingle('knot', '0.514444444 m/s')
   *
   * @memberof Unit
   * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
   * @param {string | Unit | object} definition      Definition of the unit in terms
   * of existing units. For example, '0.514444444 m / s'. Can be a Unit, a string,
   * or an Object. If an Object, may have the following properties:
   *   - definition {string | Unit} The definition of this unit.
   *   - prefixes {string} "none", "short", "long", "binary_short", or "binary_long".
   *     The default is "none".
   *   - aliases {Array} Array of strings. Example: ['knots', 'kt', 'kts']
   *   - offset {Numeric} An offset to apply when converting from the unit. For
   *     example, the offset for celsius is 273.15 and the offset for farhenheit
   *     is 459.67. Default is 0.
   *   - baseName {string} If the unit's dimension does not match that of any other
   *     base unit, the name of the newly create base unit. Otherwise, this property
   *     has no effect.
   *
   * @return {Unit}
   */ Unit.createUnitSingle = function(name, obj) {
        if (typeof obj === 'undefined' || obj === null) {
            obj = {};
        }
        if (typeof name !== 'string') {
            throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
        }
        // Check collisions with existing units
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNITS, name)) {
            throw new Error('Cannot create unit "' + name + '": a unit with that name already exists');
        }
        // TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.
        assertUnitNameIsValid(name);
        var defUnit = null; // The Unit from which the new unit will be created.
        var aliases = [];
        var offset = 0;
        var definition;
        var prefixes;
        var baseName;
        if (obj && obj.type === 'Unit') {
            defUnit = obj.clone();
        } else if (typeof obj === 'string') {
            if (obj !== '') {
                definition = obj;
            }
        } else if (typeof obj === 'object') {
            definition = obj.definition;
            prefixes = obj.prefixes;
            offset = obj.offset;
            baseName = obj.baseName;
            if (obj.aliases) {
                aliases = obj.aliases.valueOf(); // aliases could be a Matrix, so convert to Array
            }
        } else {
            throw new TypeError('Cannot create unit "' + name + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
        }
        if (aliases) {
            for(var i = 0; i < aliases.length; i++){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(UNITS, aliases[i])) {
                    throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
                }
            }
        }
        if (definition && typeof definition === 'string' && !defUnit) {
            try {
                defUnit = Unit.parse(definition, {
                    allowNoUnits: true
                });
            } catch (ex) {
                ex.message = 'Could not create unit "' + name + '" from "' + definition + '": ' + ex.message;
                throw ex;
            }
        } else if (definition && definition.type === 'Unit') {
            defUnit = definition.clone();
        }
        aliases = aliases || [];
        offset = offset || 0;
        if (prefixes && prefixes.toUpperCase) {
            prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
        } else {
            prefixes = PREFIXES.NONE;
        }
        // If defUnit is null, it is because the user did not
        // specify a defintion. So create a new base dimension.
        var newUnit = {};
        if (!defUnit) {
            // Add a new base dimension
            baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo
            if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
                throw new Error('Cannot create new base unit "' + name + '": a base unit with that name already exists (and cannot be overridden)');
            }
            BASE_DIMENSIONS.push(baseName);
            // Push 0 onto existing base units
            for(var b in BASE_UNITS){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(BASE_UNITS, b)) {
                    BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
                }
            }
            // Add the new base unit
            var newBaseUnit = {
                dimensions: []
            };
            for(var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++){
                newBaseUnit.dimensions[_i6] = 0;
            }
            newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
            newBaseUnit.key = baseName;
            BASE_UNITS[baseName] = newBaseUnit;
            newUnit = {
                name,
                value: 1,
                dimensions: BASE_UNITS[baseName].dimensions.slice(0),
                prefixes,
                offset,
                base: BASE_UNITS[baseName]
            };
            currentUnitSystem[baseName] = {
                unit: newUnit,
                prefix: PREFIXES.NONE['']
            };
        } else {
            newUnit = {
                name,
                value: defUnit.value,
                dimensions: defUnit.dimensions.slice(0),
                prefixes,
                offset
            };
            // Create a new base if no matching base exists
            var anyMatch = false;
            for(var _i7 in BASE_UNITS){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(BASE_UNITS, _i7)) {
                    var match = true;
                    for(var j = 0; j < BASE_DIMENSIONS.length; j++){
                        if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        anyMatch = true;
                        newUnit.base = BASE_UNITS[_i7];
                        break;
                    }
                }
            }
            if (!anyMatch) {
                baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo
                // Add the new base unit
                var _newBaseUnit = {
                    dimensions: defUnit.dimensions.slice(0)
                };
                _newBaseUnit.key = baseName;
                BASE_UNITS[baseName] = _newBaseUnit;
                currentUnitSystem[baseName] = {
                    unit: newUnit,
                    prefix: PREFIXES.NONE['']
                };
                newUnit.base = BASE_UNITS[baseName];
            }
        }
        Unit.UNITS[name] = newUnit;
        for(var _i8 = 0; _i8 < aliases.length; _i8++){
            var aliasName = aliases[_i8];
            var _alias = {};
            for(var _key6 in newUnit){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(newUnit, _key6)) {
                    _alias[_key6] = newUnit[_key6];
                }
            }
            _alias.name = aliasName;
            Unit.UNITS[aliasName] = _alias;
        }
        // delete the memoization cache because we created a new unit
        delete _findUnit.cache;
        return new Unit(null, name);
    };
    Unit.deleteUnit = function(name) {
        delete Unit.UNITS[name];
        // delete the memoization cache because we deleted a unit
        delete _findUnit.cache;
    };
    // expose arrays with prefixes, dimensions, units, systems
    Unit.PREFIXES = PREFIXES;
    Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit.BASE_UNITS = BASE_UNITS;
    Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit.UNITS = UNITS;
    return Unit;
}, {
    isClass: true
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/unit/function/createUnit.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCreateUnit": (()=>createCreateUnit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'createUnit';
var dependencies = [
    'typed',
    'Unit'
];
var createCreateUnit = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Unit } = _ref;
    /**
   * Create a user-defined unit and register it with the Unit type.
   *
   * Syntax:
   *
   *     math.createUnit({
   *       baseUnit1: {
   *         aliases: [string, ...]
   *         prefixes: object
   *       },
   *       unit2: {
   *         definition: string,
   *         aliases: [string, ...]
   *         prefixes: object,
   *         offset: number
   *       },
   *       unit3: string    // Shortcut
   *     })
   *
   *     // Another shortcut:
   *     math.createUnit(string, unit : string, [object])
   *
   * Examples:
   *
   *     math.createUnit('foo')
   *     math.createUnit('knot', {definition: '0.514444444 m/s', aliases: ['knots', 'kt', 'kts']})
   *     math.createUnit('mph', '1 mile/hour')
   *     math.createUnit('km', math.unit(1000, 'm'))
   *
   * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
   * @param {string, UnitDefinition, Unit} definition      Definition of the unit in terms of existing units. For example, '0.514444444 m / s'.
   * @param {Object} options   (optional) An object containing any of the following properties:
   *     - `prefixes {string}` "none", "short", "long", "binary_short", or "binary_long". The default is "none".
   *     - `aliases {Array}` Array of strings. Example: ['knots', 'kt', 'kts']
   *     - `offset {Numeric}` An offset to apply when converting from the unit. For example, the offset for celsius is 273.15. Default is 0.
   *
   * See also:
   *
   *     unit
   *
   * @return {Unit} The new unit
   */ return typed(name, {
        // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
        'Object, Object': function Object_Object(obj, options) {
            return Unit.createUnit(obj, options);
        },
        // Same as above but without the options.
        Object: function Object(obj) {
            return Unit.createUnit(obj, {});
        },
        // Shortcut method for creating one unit.
        'string, Unit | string | Object, Object': function string_Unit__string__Object_Object(name, def, options) {
            var obj = {};
            obj[name] = def;
            return Unit.createUnit(obj, options);
        },
        // Same as above but without the options.
        'string, Unit | string | Object': function string_Unit__string__Object(name, def) {
            var obj = {};
            obj[name] = def;
            return Unit.createUnit(obj, {});
        },
        // Without a definition, creates a base unit.
        string: function string(name) {
            var obj = {};
            obj[name] = {};
            return Unit.createUnit(obj, {});
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/type/unit/function/unit.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnitFunction": (()=>createUnitFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-client] (ecmascript)");
;
;
var name = 'unit';
var dependencies = [
    'typed',
    'Unit'
];
var createUnitFunction = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Unit } = _ref;
    /**
   * Create a unit. Depending on the passed arguments, the function
   * will create and return a new math.Unit object.
   * When a matrix is provided, all elements will be converted to units.
   *
   * Syntax:
   *
   *     math.unit(unit : string)
   *     math.unit(value : number, valuelessUnit : Unit)
   *     math.unit(value : number, valuelessUnit : string)
   *
   * Examples:
   *
   *    const kph = math.unit('km/h')   // returns Unit km/h (valueless)
   *    const v = math.unit(25, kph)    // returns Unit 25 km/h
   *    const a = math.unit(5, 'cm')    // returns Unit 50 mm
   *    const b = math.unit('23 kg')    // returns Unit 23 kg
   *    a.to('m')                       // returns Unit 0.05 m
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, string, createUnit
   *
   * @param {* | Array | Matrix} args   A number and unit.
   * @return {Unit | Array | Matrix}    The created unit
   */ return typed(name, {
        Unit: function Unit(x) {
            return x.clone();
        },
        string: function string(x) {
            if (Unit.isValuelessUnit(x)) {
                return new Unit(null, x); // a pure unit
            }
            return Unit.parse(x, {
                allowNoUnits: true
            }); // a unit with value, like '5cm'
        },
        'number | BigNumber | Fraction | Complex, string | Unit': function number__BigNumber__Fraction__Complex_string__Unit(value, unit) {
            return new Unit(value, unit);
        },
        'number | BigNumber | Fraction': function number__BigNumber__Fraction(value) {
            // dimensionless
            return new Unit(value);
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
}]);

//# sourceMappingURL=node_modules_mathjs_lib_esm_type_6128842e._.js.map